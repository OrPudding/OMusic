<template>
	<div class="demo-page">
		<!-- 歌曲信息 -->
		<div class="song">
			<marquee class="song-name" scrollamount="36" onclick="exit">
				{{ songName }}
			</marquee>
			<marquee class="singer-name" scrollamount="36">
				{{ songArtists }}
			</marquee>
		</div>

		<!-- 播放控制按钮 (未展开时显示) -->
		<div class="controls" if="{{ !expend }}">
			<image class="icon" src="/common/icon/prev.png" onclick="change(-1)" />
			<image
				class="icon"
				src="{{ playButtonIcon }}"
				onclick="playOrPause"
			/>
			<image class="icon" src="/common/icon/next.png" onclick="change(1)" />
		</div>

        <!-- 歌词容器 -->
        <div class="{{ expend ? 'lyrics-container-expended' : 'lyrics-container' }}" onclick="toggleLyricExpend" @swipe="handleLyricSwipe">
            <!-- 使用 for 循环动态渲染歌词行，代码更简洁 -->
            <text
                for="{{ line in visibleLyrics }}"
                class="{{ line.className }}"
            >
                {{ line.text }}
            </text>
        </div>

		<!-- 播放进度 (未展开时显示) -->
		<div class="progress" if="{{ !expend }}">
			<text class="play-time">{{ progressText }}</text>
<slider
    class="play-progress"
    min="0"
    max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}"
    step="1"
    value="{{ playerState.playDuration }}"
    onchange="onSliderChange"
></slider>

		</div>

		<!-- 底部操作 (未展开时显示) -->
		<div class="footer" if="{{ !expend }}"  @swipe="handleSwipe" >
		    <div class="footer-content-rect" if="{{ screenShape === 'rect' }}">
                <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                <image class="footer-icon" src="{{ downloadIcon }}" onclick="initiateDownload"></image>
                <image class="footer-icon" src="{{ playModeIcon }}" onclick="togglePlayMode"></image>
                <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
            </div>
        
            <!-- 圆屏 (circle) 或其他布局：只显示音量和列表两个按钮 -->
            <div class="footer-content-circle" else>
                <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
            </div>
		</div>
	</div>
</template>
<script>
import router from "@system.router";
import fetch from "@system.fetch";
import audio from "@system.audio";
import file from "@system.file";
import prompt from '@system.prompt';
import request from '@system.request';
import device from '@system.device';
import app from "@system.app";

// --- 1. 常量定义 (无变化) ---
const CONSTANTS = {
    API_SONG_URL: 'https://163api.qijieya.cn/song/url?id=',
    API_LYRIC_URL: 'https://163api.qijieya.cn/lyric?id=',
    API_DOWNLOAD_SONG_URL: 'https://163api.qijieya.cn/song/url?id=',
    DIR_MUSIC: 'internal://files/music/',
    DIR_LYRICS: 'internal://files/lyrics/',
    FILE_PLAY_LIST: 'internal://files/play_list.json',
    FILE_DOWNLOADED_SONGS: 'internal://files/downloaded_songs.json',
    SETTINGS_FILE_URI: 'internal://files/settings.json',
    COOKIE_FILE_URI: 'internal://files/cookie.txt',
    FILE_PLAYER_STATE: 'internal://files/player_state.json',
    MAX_PLAYBACK_RETRIES: 3,
    PLAY_TIMEOUT: 8000, // 播放超时时间8秒
};

// --- 文件服务封装 (无变化 ) ---
const fileService = {
    _promisify(fn, options) { return new Promise((resolve, reject) => { fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) }); }); },
    async readJson(uri, defaultValue = null) { try { const data = await this._promisify(file.readText, { uri }); return JSON.parse(data.text); } catch (e) { return defaultValue; } },
    async writeJson(uri, data) { try { await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) }); return true; } catch (e) { return false; } },
};

export default {
    private: {
        playerState: { isPlaying: false, playDuration: 0, currentLyricIndex: 0, lyricType: 'chinese' },
        currSong: null,
        lyrics: [],
        expend: false,
        downloadedSongs: {},
        settings: { lyrics: { japaneseMode: 'translation', cantoneseMode: 'romaji', englishMode: 'translation' },            audioQuality: {
                online: 64,
                download: 128
            } },
        isPlaying: false,
        cookie: null,
        isDownloadingLocked: false,
        wasRestored: false,
        retryCount: 0,
        screenShape: 'circle',
        playMode: 0,
        songBeingDownloaded: null,
        isFmMode: false,
        fmQueue: [],
        isFetchingFm: false,

                // 【新增】初始化标志位，防止重复执行恢复逻辑
                _isInitialized: false,
                _isInitialRefreshed: false,

        // --- 【健壮性核心】重新引入并优化的状态 ---
        pendingSongId: null,    // 目标歌曲ID，防止重复执行切歌
        playTimeoutId: null,    // 播放超时定时器，防止底层僵死导致死锁
    },

    protected: {
        playList: [],
        currentIndex: 0,
        songId: null,
        songInfo: null,
        triggerDownload: false,
        triggerPlayModeToggle: false,
        startFmMode: false,
    },

    computed: {
        songName() { return this.currSong ? this.currSong.name : "未知歌曲"; },
        songArtists() { return this.currSong ? this.currSong.artists : "未知艺术家"; },
        playButtonIcon() {
            if (this.pendingSongId && !this.playerState.isPlaying) return '/common/icon/loading.png'; // 切歌加载中
            return this.playerState.isPlaying ? '/common/icon/pause.png' : '/common/icon/play.png';
        },
        progressText() {
            const duration = this.currSong?.duration || 0;
            return `${this.second2time(this.playerState.playDuration)}/${this.second2time(duration)}`;
        },
        downloadIcon() {
            const icons = {
                downloading: '/common/icon/downloading.png',
                downloaded: '/common/icon/downloaded.png',
                not_downloaded: '/common/icon/download.png',
            };
            
            if (!this.currSong) {
                return icons.not_downloaded;
            }

            // 【核心修改2】: downloadIcon 的逻辑现在更健壮
            // 检查是否有下载任务正在进行，并且这个任务是针对当前歌曲的
            if (this.songBeingDownloaded && this.currSong.id === this.songBeingDownloaded.id) {
                 return icons.downloading;
            }

            if (this.downloadedSongs[this.currSong.id]) {
                return icons.downloaded;
            }

            return icons.not_downloaded;
        },

    playModeIcon() {
        if (this.isFmMode) {
                return '/common/icon/fm.png'; // 假设您有一个FM图标
            }
        const icons = [
            '/common/icon/loop.png',
            '/common/icon/single-loop.png',
            '/common/icon/random.png'
        ];
        return icons[this.playMode] || icons[0];
    },

        /**
          实现智能歌词显示逻辑
         */
         visibleLyrics() {
        if (!this.lyrics || this.lyrics.length === 0) {
            return [{ text: '暂无歌词', className: 'lyric-line current-lyric' }];
        }

        const lines = [];
        const currentLineData = this.lyrics[this.playerState.currentLyricIndex];
        if (!currentLineData) {
            return [{ text: '歌词加载中...', className: 'lyric-line current-lyric' }];
        }

        // --- 1. 展开状态 (逻辑不变) ---
        if (this.expend) {
            const offsets = [-2, -1, 0, 1, 2, 3, 4];
            for (const offset of offsets) {
                const index = this.playerState.currentLyricIndex + offset;
                if (index >= 0 && index < this.lyrics.length) {
                    const lineData = this.lyrics[index];
                    const isCurrent = offset === 0;
                    
                    lines.push({ 
                        text: lineData.original || lineData.text || '', 
                        className: `lyric-line ${isCurrent ? 'current-lyric' : 'secondary-lyric'}` 
                    });

                    if (isCurrent) {
                        const extraText = this.getExtraLyricText(lineData);
                        if (extraText) {
                            lines.push({ text: extraText, className: 'lyric-line extra-lyric' });
                        }
                    }
                }
            }
            return lines;
        }

        // --- 2. 未展开状态 (全新智能逻辑) ---
        
        const extraText = this.getExtraLyricText(currentLineData);
        const shouldShowExtra = !!extraText;

        // a) 如果是中文歌，或外文歌设置为"仅原文"，则进入此分支
        if (!shouldShowExtra) {
            // **核心修改点：根据屏幕形状决定显示的行数**
            const offsets = this.screenShape === 'rect' 
                ? [-2, -1, 0, 1, 2]  // 方屏：显示5行
                : [-1, 0, 1];        // 其他屏幕 (如圆形)：显示3行

            for (const offset of offsets) {
                const index = this.playerState.currentLyricIndex + offset;
                if (index >= 0 && index < this.lyrics.length) {
                    const lineData = this.lyrics[index];
                    const isCurrent = offset === 0;
                    lines.push({
                        text: lineData.original || lineData.text || '',
                        className: `lyric-line ${isCurrent ? 'current-lyric' : 'secondary-lyric'}`
                    });
                }
            }
        } 
        // b) 如果需要显示翻译或罗马音，则只显示当前行和附加行 (逻辑不变)
        else {
            lines.push({
                text: currentLineData.original || currentLineData.text || '',
                className: 'lyric-line current-lyric'
            });
            lines.push({
                text: extraText,
                className: 'lyric-line extra-lyric'
            });
        }
        
        return lines;
    }
    },

    async onInit() {
        // onInit 只负责准备环境，这部分是对的
        if (this.$app.$def.isActivated === false) { router.replace({ uri: '/pages/splash' }); return; }
        console.log("Player onInit: 准备基础环境。");
        this.bindAudioEvents();
        await this.loadSettings();
        await this.loadCookie();
        await this.loadDownloadedSongs();
        this.getDeviceInfo();
        
        // 【关键】onInit 依然要尝试恢复状态，为“直接打开”场景做准备
        await this.onRestoreState();
    },

    onReady() {
        // 【核心改动2】: onReady 成为唯一的播放入口
        console.log("Player onReady: 页面就绪，启动播放逻辑。");
        // 此时，无论是状态恢复还是外部传入，数据都已准备好
        this.startLogic();
    },
    
// player.js -> onShow
async onShow() {
    console.log("Player onShow: 页面显示。");

    // 【核心修复】如果当前是FM模式，直接返回，不做任何检查。
    if (this.isFmMode) {
        console.log("onShow: FM模式，跳过列表检查。");
        return;
    }

    // --- 以下是只在常规模式下执行的逻辑 ---
    console.log("onShow: 常规模式，同步数据并检查列表。");
    await this.loadDownloadedSongs();
    await this.loadListFromFile();

    if (this.currSong) {
        const stillInPlaylist = this.playList.some(song => song.id === this.currSong.id);
        if (!stillInPlaylist) {
            prompt.showToast({ message: "当前歌曲已从列表中移除" });
            this.change(1); 
        }
    }
},

    /**
     * @description 【洗心革面版】onRefresh 每次都完整检查所有指令
     */
     async onRefresh(query) {
        const params = query || {};
        console.log('Player onRefresh with params:', JSON.stringify(params));

        // ------------------------------------------------------------------
        //  【【【 这 是 唯 一 的 决 策 中 心 】】】
        // ------------------------------------------------------------------

        // 1. 最高优先级：处理特殊操作指令 (FM, 下载, 模式切换)
        //    注意：使用 `== 'true'` 来正确判断字符串布尔值
        if (params.startFmMode == 'true') {
            console.log("onRefresh: 收到启动FM指令，执行。");
            this.dostartFmMode(params.songId, params.songInfo);
            return; // 执行后必须返回
        }
        if (params.triggerDownload == 'true') {
            console.log("onRefresh: 收到下载指令，执行。");
            this.initiateDownload();
            return; // 执行后必须返回
        }
        if (params.triggerPlayModeToggle == 'true') {
            console.log("onRefresh: 收到播放模式切换指令，执行。");
            this.togglePlayMode();
            // 这个可以不返回，让后续逻辑继续
        }

        // 2. 次高优先级：处理新歌播放指令
        if (params.songId) {
            // 只有当新歌ID和当前播放的歌曲ID不同时，才执行播放
            if (!this.currSong || this.currSong.id != params.songId) {
                console.log(`onRefresh: 收到新歌指令 [${params.songId}]，执行播放。`);
                this.songId = params.songId;
                this.songInfo = params.songInfo ? JSON.parse(params.songInfo) : null;
                this.startLogic();
            } else {
                console.log(`onRefresh: 收到相同歌曲指令 [${params.songId}]，不执行操作。`);
            }
            return; // 无论是否播放，处理完 songId 后都应返回
        }

        // 3. 最低优先级：无任何指令传入
        //    这对应用户直接打开或从后台返回的场景。
        //    此时，onInit 中 onRestoreState 的结果已经生效，我们什么都不用做。
        console.log("onRefresh: 未收到任何有效指令，维持当前由 onInit 恢复的状态。");
    },

    async onRestoreState() {
        // 【关键】恢复状态前，检查 this.songId 是否已被 onRefresh 的前序步骤赋值
        // （虽然在新逻辑里不太可能，但作为保险措施保留）
        if (this.songId) {
            return false;
        }
        
        const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
        // ... 您的 onRestoreState 逻辑完全正确，保持不变 ...
        // ... 它会正确地恢复状态，并把 lastSongId 赋值给 this.songId ...
    },
    
    onHide() {
        console.log("Player onHide: 页面被隐藏。");
        if (!this.isDownloadingLocked) {
            this.onSaveState();
        } else {
            console.log("下载中，跳过状态保存。");
        }
    },

    onDestroy() {
        console.log("Player onDestroy: 页面被销毁。");
        audio.stop();
        if (!this.isDownloadingLocked) {
            this.onSaveState();
        }
    },

    onBackPress() {
        if (this.isDownloadingLocked) {
            prompt.showToast({ message: '正在下载，请勿退出' });
            return true;
        }
        this.onSaveState
        prompt.showToast({ message: '防误退出，点击顶部歌名以退出' })
        return true;
    },

// player.js -> handleSwipe
handleSwipe(e) {
    if (e.direction === 'left') {
        // 【核心修复】使用 this.isFmMode 进行判断
        if (this.isFmMode) {
            // FM模式下，左滑切换到下一首
            this.change(1);
        } else {
            // 常规模式下，左滑进入列表页
            router.push({ uri: '/pages/list' });
        }
    }
    // 可以在这里添加 right 方向的逻辑，比如右滑返回
    if (e.direction === 'right') {
        router.back();
    }
},

handleLyricSwipe(e) {
    if (e.direction === 'up') {
        this.goToLyrics();
    }
},


    // 新增：获取设备信息的方法
getDeviceInfo() {
    device.getInfo({
        success: (data) => {
            if (data.screenShape) {
                console.log(`设备屏幕形状: ${data.screenShape}`);
                this.screenShape = data.screenShape;
            }
        },
        fail: (data, code) => {
            console.error(`获取设备信息失败, code = ${code}`);
        }
    });
},



    // onSaveState 和 onRestoreState 保持您修正后的正确版本
    async onSaveState() {
        if (!this.currSong || !this.currSong.duration) return;
        const stateToSave = {
            lastSongId: this.currSong.id,
            lastPlayDuration: this.playerState.playDuration,
            playMode: this.playMode,
            duration: this.currSong.duration,
            timestamp: new Date().getTime(),
        };
        await fileService.writeJson(CONSTANTS.FILE_PLAYER_STATE, stateToSave);
    },

    async onRestoreState() {
        // 这个方法现在只负责“恢复”，不负责决策
        const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
        const isStateExpired = savedState?.timestamp ? (new Date().getTime() - savedState.timestamp > 12 * 3600 * 1000) : true;

        if (savedState && savedState.lastSongId && savedState.duration && !isStateExpired) {
            await this.loadListFromFile();
            const lastIndex = this.playList.findIndex(song => song.id === savedState.lastSongId);
            if (lastIndex > -1) {
                this.songId = savedState.lastSongId; // 将恢复的ID赋值给 this.songId
                this.currentIndex = lastIndex;
                this.playMode = savedState.playMode || 0;
                this.currSong = { ...this.playList[this.currentIndex], duration: savedState.duration };
                this.playerState.playDuration = savedState.lastPlayDuration;
                this.fetchLyric(this.songId);
                prompt.showToast({ message: "播放状态已恢复" });
                return true;
            }
        }
        return false;
    },

    async startLogic() {
        // startLogic 逻辑保持不变，它依赖于 this.songId
        if (!this.songId) {
            if (this.playList && this.playList.length > 0) {
                this.currentIndex = 0;
                this.playCurrent();
            } else {
                prompt.showToast({ message: "播放列表为空" });
            }
            return;
        }
        await this.loadListFromFile();
        const index = this.playList.findIndex(item => item && item.id == this.songId);
        if (index !== -1) {
            this.currentIndex = index;
        } else {
            if (this.songInfo && this.songInfo.id) {
                this.playList.unshift(this.songInfo);
                this.currentIndex = 0;
                await fileService.writeJson(CONSTANTS.FILE_PLAY_LIST, this.playList);
            } else {
                this.currentIndex = 0;
            }
        }
        if (this.playList.length > 0) {
            this.playCurrent();
        }
    },

    // --- 【新增】启动私人FM模式的方法 ---
    async dostartFmMode(initialSongId = null, initialSongInfo = null) {
        if (this.isFetchingFm) return;

        this.isFmMode = true;
        this.isFetchingFm = true;
        this.playList = []; // FM模式不使用全局播放列表
        this.fmQueue = [];
        audio.stop();
        prompt.showToast({ message: '正在开启私人FM...' });

        // 如果列表页传递了初始歌曲，直接使用
        if (initialSongId && initialSongInfo) {
            try {
                const song = JSON.parse(initialSongInfo);
                this.fmQueue.push(song);
            } catch(e) {
                console.error("解析FM初始歌曲信息失败");
            }
        }

        try {
            await this.fetchNextFmSongs(); // 获取一批新歌
            if (this.fmQueue.length > 0) {
                this.playCurrent(); // playCurrent 会处理FM队列的播放
            } else {
                prompt.showToast({ message: '无法获取FM歌曲，请检查网络' });
                this.isFmMode = false; // 失败则退出FM模式
            }
        } catch (error) {
            prompt.showToast({ message: '启动FM失败' });
            this.isFmMode = false;
        } finally {
            this.isFetchingFm = false;
        }
    },

    // --- 【新增】获取下一批FM歌曲的方法 ---
    async fetchNextFmSongs() {
        if (this.isFetchingFm) return;
        this.isFetchingFm = true;
        console.log("正在获取新的FM歌曲...");

        try {
            const request = this.$app.$def.requestService; // 假设requestService已在app中定义
            if (!request) throw new Error("内部服务错误");

            const url = `https://163api.qijieya.cn/personal_fm?timestamp=${new Date().getTime()}`;
            const response = await request.fetch({ url });

            if (response.data.data && response.data.data.length > 0) {
                const newSongs = response.data.data.map(s => ({
                    id: s.id,
                    name: s.name,
                    artists: s.artists.map(a => a.name).join(' / '),
                    // ... 其他必要字段
                }));
                this.fmQueue.push(...newSongs);
                console.log(`成功获取 ${newSongs.length} 首FM歌曲，当前队列长度: ${this.fmQueue.length}`);
            } else {
                prompt.showToast({ message: '没有更多FM推荐了' });
            }
        } catch (error) {
            console.error("获取FM歌曲失败:", error);
            prompt.showToast({ message: '获取新歌失败' });
        } finally {
            this.isFetchingFm = false;
        }
    },


    /**
     * **新增**: 辅助方法，用于获取附加歌词文本
     * @param {object} lineData - 当前歌词行的数据对象
     * @returns {string} - 附加歌词文本，如果没有则返回空字符串
     */
// player.ux -> getExtraLyricText()
getExtraLyricText(lineData) {
    if (!lineData) return '';
    let extraText = '';

    // 确保 settings.lyrics 存在，避免出错
    const lyricSettings = this.settings.lyrics || {};

    switch (this.playerState.lyricType) {
        case 'japanese':
            if (lyricSettings.japaneseMode === 'translation') {
                extraText = lineData.translation || '';
            } else if (lyricSettings.japaneseMode === 'romaji') {
                extraText = lineData.romaji || '';
            }
            break;
        
        // --- 核心修改：新增对 cantonese 类型的处理 ---
        case 'cantonese':
            if (lyricSettings.cantoneseMode === 'romaji') {
                extraText = lineData.romaji || '';
            }
            break;

        case 'english':
            if (lyricSettings.englishMode === 'translation') {
                extraText = lineData.translation || '';
            }
            break;
    }
    
    return extraText;
},


initiateDownload() {
        if (!this.currSong) { prompt.showToast({ message: '歌曲信息无效，无法下载' }); return; }
        if (this.downloadedSongs[this.currSong.id]) { prompt.showToast({ message: '歌曲已下载' }); return; }
        
        // 【核心修改3】: isDownloadingLocked 依然作为全局锁，但 songBeingDownloaded 用于绑定状态
        if (this.isDownloadingLocked) { 
            prompt.showToast({ message: '已有任务在下载中' }); 
            return; 
        }

        // 在这里，我们将发起下载时的歌曲信息存入 songBeingDownloaded
        this.songBeingDownloaded = { ...this.currSong }; // 创建一个副本，防止被外部修改
        
        this.executeDownload();
    },

    async executeDownload() {
        this.isDownloadingLocked = true;
        
        // 【核心修改4】: 不再引用 this.currSong，而是使用我们绑定的 songBeingDownloaded
        const songToDownload = this.songBeingDownloaded; 
        
        if (!songToDownload) {
            console.error("executeDownload 错误: songBeingDownloaded 为空。");
            this.isDownloadingLocked = false;
            return;
        }

        prompt.showToast({ message: `开始下载: ${songToDownload.name}` });

        try {
            // 所有后续操作都围绕 songToDownload 进行
            const { songInfo, lyricData } = await this.fetchSongAndLyricForDownload(songToDownload.id);
            if (!songInfo || !songInfo.url) throw new Error('无法获取歌曲下载信息');

            const lyricFilePath = `${CONSTANTS.DIR_LYRICS}${songToDownload.id}.json`;
            const songFilePath = `${CONSTANTS.DIR_MUSIC}${songToDownload.id}.mp3`;

            if (lyricData) await this.saveLyricFile(lyricFilePath, lyricData);

            const tempFileUri = await this.downloadSongFile(songInfo.url, `${songToDownload.id}.mp3`);
            if (!tempFileUri) throw new Error('歌曲文件下载失败');

            await this.moveSongFile(tempFileUri, songFilePath);

            // 【核心修改5】: 构造最终的下载信息对象时，也使用 songToDownload
            const downloadedInfo = { 
                ...songToDownload, // 使用下载任务开始时的歌曲信息
                localUri: songFilePath, 
                localLyricUri: lyricData ? lyricFilePath : null, 
                duration: songInfo.duration 
            };

            this.downloadedSongs[songToDownload.id] = downloadedInfo;
            await fileService.writeJson(CONSTANTS.FILE_DOWNLOADED_SONGS, this.downloadedSongs);

            prompt.showToast({ message: `${songToDownload.name} 下载成功`, duration: 5000 });

        } catch (error) {
            this.handleDownloadError(error.message);
            // 即使失败，也要基于正确的歌曲ID来清理
            file.delete({ uri: `${CONSTANTS.DIR_LYRICS}${songToDownload.id}.json` });
        } finally {
            // 【核心修改6】: 任务结束，重置所有状态
            this.isDownloadingLocked = false;
            this.songBeingDownloaded = null; 
        }
    },

    /**
     * **新增**: 统一构建带认证信息的URL
     * @param {string} baseUrl - 不带任何参数的基础URL
     * @returns {string} - 拼接了cookie参数（如果存在）的完整URL
     */
     buildAuthenticatedUrl(baseUrl) {
        if (this.cookie) {
            // 确保基础URL后面有 '?'
            const separator = baseUrl.includes('?') ? '&' : '?';
            return `${baseUrl}${separator}cookie=${encodeURIComponent(this.cookie)}`;
        }
        return baseUrl;
    },

    async fetchSongAndLyricForDownload(songId) {
        // 【修改5】: 下载时也动态构建带码率的 URL
        const downloadBitrate = this.settings.audioQuality.download * 1000; // 转换为 bps
        const songBaseUrl = `${CONSTANTS.API_DOWNLOAD_SONG_URL}${songId}`;
        const songUrlWithBitrate = `${songBaseUrl}&br=${downloadBitrate}`;

        const songUrl = this.buildAuthenticatedUrl(songUrlWithBitrate);
        const lyricUrl = this.buildAuthenticatedUrl(`${CONSTANTS.API_LYRIC_URL}${songId}`);

        console.log("Downloading with URL:", songUrl);

        const fetchPromise = (url) => new Promise((resolve, reject) => {
            // **移除**: 不再传递 header
            fetch.fetch({ url, responseType: 'text', success: resolve, fail: (data, code) => reject({ data, code }) });
        });

        try {
            const [songRes, lyricRes] = await Promise.all([
                fetchPromise(songUrl),
                fetchPromise(lyricUrl).catch(() => null)
            ]);
            const songData = JSON.parse(songRes.data)?.data?.[0];
            if (songData && songData.url) {
                if (!songData.freeTrialInfo) prompt.showToast({ message: "Cookie有效，获取到完整音源！" });
                else prompt.showToast({ message: "Cookie可能无效，获取到试听音源。" });
                return {
                    songInfo: { url: songData.url, duration: Math.floor(songData.time / 1000) },
                    lyricData: lyricRes ? JSON.parse(lyricRes.data) : null
                };
            } else {
                throw new Error('解析歌曲URL失败');
            }
        } catch (error) {
            console.error("fetchSongAndLyricForDownload 失败:", error);
            throw new Error('获取下载资源失败');
        }
    },

    saveLyricFile(path, data) {
        return new Promise((resolve, reject) => {
            if (!data) { resolve(); return; }
            file.writeText({ uri: path, text: JSON.stringify(data, null, 2), success: resolve, fail: reject });
        });
    },

    downloadSongFile(url, filename) {
    return new Promise((resolve) => {
        // 只在开始时提示一次
        prompt.showToast({ message: '已开始下载，请稍候...' });

        request.download({
            url,
            filename,
            success: (task) => {
                // 如果API支持进度回调，可以在这里监听
                // request.onProgressUpdate({ token: task.token, success: (progress) => { ... } });

                request.onDownloadComplete({
                    token: task.token,
                    success: (data) => {
                        prompt.showToast({ message: '歌曲文件下载完成', duration: 500 });
                        resolve(data.uri);
                    },
                    fail: () => {
                        prompt.showToast({ message: '下载失败，请重试。' });
                        resolve(null);
                    },
                });
            },
            fail: () => {
                prompt.showToast({ message: '下载启动失败，请检查链接。' });
                resolve(null);
            },
        });
    });
},



    moveSongFile(srcUri, dstUri) {
        return new Promise((resolve, reject) => {
            file.move({ srcUri, dstUri, success: resolve, fail: reject });
        });
    },

    handleDownloadError(message) {
        prompt.showToast({ message: message || '下载失败' });
        this.isDownloadingLocked = false;
    },

    // --- 【健壮性核心】最终版 playCurrent ---
    async playCurrent() {
        let songToPlay;

        // 1. 获取目标歌曲
        if (this.isFmMode) {
            if (this.fmQueue.length === 0) {
                await this.fetchNextFmSongs();
                if (this.fmQueue.length === 0) { this.resetPlayer(); return; }
            }
            songToPlay = this.fmQueue[0];
        } else {
            if (!this.playList || this.playList.length === 0) { this.resetPlayer(); return; }
            songToPlay = this.playList[this.currentIndex];
        }

        if (!songToPlay) {
            this.handlePlaybackError("无效的歌曲数据");
            return;
        }

        // 2. 【防重复】检查是否已在处理这首歌的播放请求
        if (this.pendingSongId === songToPlay.id) {
            return;
        }

        // 3. 【UI同步】立即更新UI，并进入“加载中”状态
        this.pendingSongId = songToPlay.id; // 设置目标ID，进入切歌状态
        this.updateUiForNewSong(songToPlay); // 封装UI更新逻辑

        // 4. 【防死锁】启动播放超时定时器
        this.startPlaybackTimeout();

        // 5. FM模式特殊处理
        if (this.isFmMode) {
            this.fmQueue.shift();
        }

        // 6. 异步获取URL并播放
        try {
            const downloadedInfo = this.downloadedSongs[songToPlay.id];
            if (downloadedInfo?.localUri) {
                await this.playLocal(songToPlay, downloadedInfo);
            } else {
                await this.playOnline(songToPlay);
            }
        } catch (error) {
            this.handlePlaybackError(error.message || "播放准备失败");
        }
    },


    // --- 【新增】UI更新辅助函数，提高代码可读性 ---
    updateUiForNewSong(song) {
        audio.stop(); // 立即停止旧歌，防止“回声”
        
        // 更新歌曲信息
        if (!this.currSong) {
            this.currSong = { ...song, duration: 0 };
        } else {
            this.currSong.id = song.id;
            this.currSong.name = song.name;
            this.currSong.artists = song.artists;
            this.currSong.duration = 0; // 先重置时长
        }
        
        // 重置播放状态
        this.playerState.playDuration = 0;
        this.resetLyrics();
        
        // 立即获取新歌词
        this.fetchLyric(song.id);
    },

    // --- 【新增】超时处理辅助函数 ---
    startPlaybackTimeout() {
        // 先清除可能存在的旧定时器
        if (this.playTimeoutId) {
            clearTimeout(this.playTimeoutId);
        }
        
        this.playTimeoutId = setTimeout(() => {
            console.error("!!! PLAYBACK TIMEOUT !!!");
            prompt.showToast({ message: '播放超时，请重试' });
            
            // 强制解锁，让用户可以再次操作
            this.pendingSongId = null;
            this.playTimeoutId = null;
            this.resetPlayer(); // 将播放器重置到干净状态

        }, CONSTANTS.PLAY_TIMEOUT);
    },


    async playLocal(song, downloadedInfo) {
        return new Promise((resolve, reject) => {
            file.access({
                uri: downloadedInfo.localUri,
                success: () => {
                    this.startPlayback({ ...song, ...downloadedInfo }, downloadedInfo.localUri);
                    this.fetchLyric(song.id);
                    resolve();
                },
                fail: () => {
                    prompt.showToast({ message: '本地文件失效，转为在线播放' });
                    this.playOnline(song).then(resolve).catch(reject);
                }
            });
        });
    },

    async playOnline(song) {
        this.isEnding = false;
        try {
            // 【修改4】: 动态构建带码率的 URL
            const onlineBitrate = this.settings.audioQuality.online * 1000; // 转换为 bps
            const baseUrl = `${CONSTANTS.API_SONG_URL}${song.id}`;
            const urlWithBitrate = `${baseUrl}&br=${onlineBitrate}`;
            
            const url = this.buildAuthenticatedUrl(urlWithBitrate);
            console.log("Playing online with URL:", url);

            const response = await new Promise((resolve, reject) => {
                // **移除**: 不再传递 header
                fetch.fetch({ url, responseType: 'text', success: resolve, fail: (data, code) => reject({ data, code }) });
            });

            const songData = JSON.parse(response.data)?.data?.[0];
            if (songData?.url) {
                const songInfo = { ...song, playUrl: songData.url, duration: Math.floor(songData.time / 1000) };
                this.startPlayback(songInfo, songData.url);
                // fetchLyricOnline 内部也会使用新的URL构建方式
                this.fetchLyricOnline(song.id);
            } else {
                throw new Error('获取播放链接失败');
            }
        } catch (error) {
            console.error("playOnline 失败:", error);
            throw error;
        }
    },
    
    // --- 【健壮性核心】最终版 startPlayback ---
    startPlayback(songWithDuration, src) {
        if (!src || typeof src !== 'string') {
            this.handlePlaybackError("无效的播放源");
            return;
        }
        
        // 合并精确时长到UI
        if (this.currSong && songWithDuration && songWithDuration.duration) {
            this.currSong.duration = songWithDuration.duration;
        }
        
        this.retryCount = 0;
        audio.stop();
        audio.src = src;
        audio.play();
    },




    // --- 【健壮性核心】最终版 change ---
    change(dir) {
        // 【防重复】如果正在切歌，则忽略新的手动请求
        if (this.pendingSongId) {
            prompt.showToast({ message: '正在切歌...' });
            return;
        }
        
        // 1. FM模式
        if (this.isFmMode) {
            if (dir < 0) {
                prompt.showToast({ message: '私人FM不支持上一首哦' });
                return;
            }
            this.playCurrent();
            return;
        }

        // 2. 常规模式
        if (!this.playList || this.playList.length === 0) return;

        switch (this.playMode) {
            case 0: case 1:
                this.currentIndex = (this.currentIndex + dir + this.playList.length) % this.playList.length;
                break;
            case 2:
                if (!this.shuffledPlayList || this.shuffledPlayList.length !== this.playList.length) {
                    this.generateShuffledList(false);
                }
                this.shuffledIndex = (this.shuffledIndex + dir + this.shuffledPlayList.length) % this.shuffledPlayList.length;
                this.currentIndex = this.shuffledPlayList[this.shuffledIndex];
                break;
        }
        
        this.playCurrent();
    },

    onSliderChange(e) {
        if (this.playerState.isPlaying || audio.duration > 0) {
            audio.currentTime = e.progress;
            this.updateLyric();
        }
    },

    toggleLyricExpend() { this.expend = !this.expend; },

    goToSongActions() {
        if (!this.currSong) { prompt.showToast({ message: '当前无播放歌曲' }); return; }
        router.push({ 
            uri: "/pages/volume", 
            params: { 
                currentSong: JSON.stringify(this.currSong),
                // 新增：传递屏幕形状信息
                screenShape: this.screenShape,
                playMode: this.playMode,
                isFmMode: this.isFmMode
            } 
        });
    },

// player.js -> togglePlayMode
togglePlayMode() {
    // 1. 如果当前是FM模式，则弹出确认对话框
    if (this.isFmMode) {
        prompt.showDialog({
            title: '退出私人FM',
            message: '您确定要退出私人FM吗？将会停止当前播放并返回常规列表模式。',
            buttons: [
                { text: '取消' }, 
                { text: '确定退出', color: '#FF453A' }
            ],
            success: async () => {
                // 2. 用户确认后，执行退出逻辑
                prompt.showToast({ message: '正在退出私人FM...' });
                this.isFmMode = false;
                this.fmQueue = []; // 清空FM队列

                // 重置播放器状态
                this.resetPlayer(); 
                
                // 尝试加载并播放常规列表的第一首歌
                // 使用 try...catch 避免在列表为空时报错
                try {
                    await this.startLogic();
                    prompt.showToast({ message: '已返回列表播放模式' });
                } catch (error) {
                    console.error("退出FM后启动常规播放失败:", error);
                    prompt.showToast({ message: '播放列表为空' });
                }
            },
            cancel: () => {
                // 3. 用户取消操作
                prompt.showToast({ message: '操作已取消' });
            }
        });
        return; // 弹出对话框后，立即返回，不执行后续代码
    }

    // 4. 如果不是FM模式，则执行常规的播放模式切换逻辑
    this.playMode = (this.playMode + 1) % 3;
    const modeText = ['列表循环', '单曲循环', '随机播放'];
    prompt.showToast({ message: modeText[this.playMode] });

    if (this.playMode === 2 && this.playList.length > 0) {
        this.generateShuffledList(true); // 切换到随机模式时，立即生成并定位
    }
},



    // --- 核心修改：新增生成随机列表的方法 ---
    generateShuffledList(locateCurrent = true) {
        console.log("生成新的随机播放列表...");
        this.shuffledPlayList = Array.from(this.playList.keys());
        
        for (let i = this.shuffledPlayList.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.shuffledPlayList[i], this.shuffledPlayList[j]] = [this.shuffledPlayList[j], this.shuffledPlayList[i]];
        }

        if (locateCurrent) {
            const currentShuffledIndex = this.shuffledPlayList.indexOf(this.currentIndex);
            this.shuffledIndex = (currentShuffledIndex !== -1) ? currentShuffledIndex : 0;
        }
        console.log("随机列表已生成, 当前随机索引:", this.shuffledIndex);
    },



    fetchLyric(songId) {
        this.resetLyrics();
        const downloadedInfo = this.downloadedSongs[songId];
        if (downloadedInfo?.localLyricUri) this.loadLyricFromFile(downloadedInfo.localLyricUri, songId);
        else this.fetchLyricOnline(songId);
    },

    loadLyricFromFile(uri, songId) {
        file.readText({
            uri: uri,
            success: (data) => { try { this.processAndMergeLyrics(JSON.parse(data.text)); } catch (e) { this.fetchLyricOnline(songId); } },
            fail: () => this.fetchLyricOnline(songId)
        });
    },

    async fetchLyricOnline(songId) {
        try {
            // **修改**: 使用辅助函数构建URL
            const url = this.buildAuthenticatedUrl(`${CONSTANTS.API_LYRIC_URL}${songId}`);
            console.log("Fetching lyric with URL:", url); // 调试日志

            const response = await new Promise((resolve, reject) => {
                // **移除**: 不再传递 header
                fetch.fetch({ url, responseType: 'text', success: resolve, fail: (data, code) => reject({ data, code }) });
            });
            this.processAndMergeLyrics(JSON.parse(response.data));
        } catch (error) { 
            this.lyrics = [{ time: 0, text: '歌词加载失败' }]; 
        }
    },

        processAndMergeLyrics(data) {
        if (!data?.lrc?.lyric) { this.lyrics = [{ time: 0, text: '暂无歌词' }]; return; }
        const original = this.parseLyric(data.lrc.lyric);
        const translation = data.tlyric?.lyric ? this.parseLyric(data.tlyric.lyric) : null;
        const romaji = data.romalrc?.lyric ? this.parseLyric(data.romalrc.lyric) : null;
        this.mergeLyrics(original, translation, romaji);
    },

    parseLyric(lrcString) {
        const lines = lrcString.split('\n'), result = [], timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
            const match = timeRegex.exec(line);
            if (match) {
                const time = parseInt(match[1]) * 60 + parseInt(match[2]) + parseInt(match[3].padEnd(3, '0')) / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) result.push({ time, text });
            }
        }
        return result;
    },

// player.ux -> mergeLyrics()
mergeLyrics(original, translation, romaji) {
    const createMap = (arr) => new Map(arr.map(item => [item.time.toFixed(3), item.text]));
    
    if (romaji && translation) {
        this.playerState.lyricType = 'japanese';
        const transMap = createMap(translation), romaMap = createMap(romaji);
        this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)), romaji: romaMap.get(line.time.toFixed(3)) }));
    } 
    // --- 核心修改：新增对“仅罗马音”情况的处理 ---
    else if (romaji && !translation) {
        this.playerState.lyricType = 'cantonese'; // 识别为粤语类型
        const romaMap = createMap(romaji);
        this.lyrics = original.map(line => ({ time: line.time, original: line.text, romaji: romaMap.get(line.time.toFixed(3)) }));
    }
    else if (translation) {
        this.playerState.lyricType = 'english';
        const transMap = createMap(translation);
        this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)) }));
    } else {
        this.playerState.lyricType = 'chinese';
        this.lyrics = original.map(line => ({ time: line.time, original: line.text }));
    }

    if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: '暂无歌词' }];
},


    updateLyric() {
        if (!this.lyrics || this.lyrics.length === 0) return;
        const currentTime = this.playerState.playDuration;
        let newIndex = this.lyrics.findIndex(line => line.time > currentTime);
        if (newIndex === -1) newIndex = this.lyrics.length;
        const finalIndex = Math.max(0, newIndex - 1);
        if (finalIndex !== this.playerState.currentLyricIndex) this.playerState.currentLyricIndex = finalIndex;
    },

    bindAudioEvents() {
        audio.onplay = () => {
            this.playerState.isPlaying = true;
            // 播放成功，清除目标ID和超时定时器
            if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
            this.pendingSongId = null;
            console.log("Event: onplay. Playback started, pending state cleared.");
        };

        audio.onpause = () => {
            this.playerState.isPlaying = false;
        };

        audio.onstop = () => {
            this.playerState.isPlaying = false;
            // 停止时也应清除状态，避免逻辑卡死
            if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
            this.pendingSongId = null;
        };

        audio.onerror = () => {
            this.handlePlaybackError("播放器发生错误");
        };

        audio.ontimeupdate = () => {
            // 仅在非切歌状态下更新进度，避免UI跳动
            if (!this.pendingSongId) {
                this.playerState.playDuration = audio.currentTime;
                this.updateLyric();
            }
        };

        // 【暴露问题，但不依赖】
        // onended 依然是自动切歌的唯一入口，但我们的健壮性逻辑能处理它的异常行为
        audio.onended = () => {
            console.log(`onended event triggered. Current time: ${audio.currentTime}, Duration: ${audio.duration}.`);
            
            // 检查是否是小米的BUG
            const timeDifference = Math.abs(audio.duration - audio.currentTime);
            if (audio.duration > 0 && timeDifference > 2) {
                console.error("!!! FRAMEWORK BUG DETECTED: PREMATURE ONENDED !!!");
            }

            // 无论如何，收到 onended 就执行切歌
            if (this.playMode === 1) {
                this.playCurrent();
            } else {
                this.change(1);
            }
        };
    },

    async loadSettings() {
        try {
            const data = await fileService.readJson(CONSTANTS.SETTINGS_FILE_URI);
            if (data) {
                // 【修改3】: 确保 player.ux 也能正确合并 audioQuality 设置
                this.settings = { 
                    ...this.settings, 
                    ...data, 
                    lyrics: { ...this.settings.lyrics, ...(data.lyrics || {}) },
                    // 新增合并逻辑
                    audioQuality: { ...this.settings.audioQuality, ...(data.audioQuality || {}) }
                };
                console.log("播放器设置加载成功，在线音质:", this.settings.audioQuality.online);
            }
        } catch (e) { 
            console.log("无法加载播放器设置，使用默认值。"); 
        }
    },


    async loadCookie() {
        try {
            
            let rawText;
            try {
                rawText = (await fileService._promisify(file.readText, { uri: CONSTANTS.COOKIE_FILE_URI })).text;
            } catch(e) {
                rawText = null;
            }

            this.cookie = rawText || null;
            if (this.cookie) {
                console.log("Cookie 加载成功。");
            }

        } catch (e) { 
            this.cookie = null; 
        }
    },

    async loadListFromFile() {
        this.playList = await fileService.readJson(CONSTANTS.FILE_PLAY_LIST, []);
    },

    async loadDownloadedSongs() {
        this.downloadedSongs = await fileService.readJson(CONSTANTS.FILE_DOWNLOADED_SONGS, {});
    },

    resetPlayer() {
        audio.stop();
        this.currSong = null;
        this.playerState.isPlaying = false;
        this.playerState.playDuration = 0;
        this.isChangingSong = false;
        this.retryCount = 0;
        this.resetLyrics();
    },

    resetLyrics() {
        this.lyrics = [];
        this.playerState.currentLyricIndex = 0;
    },

    // --- 【健壮性核心】最终版 handlePlaybackError ---
    handlePlaybackError(message) {
        // 发生任何错误时，都应清除切歌状态和超时，避免死锁
        if (this.playTimeoutId) {
            clearTimeout(this.playTimeoutId);
            this.playTimeoutId = null;
        }
        this.pendingSongId = null;
        
        this.retryCount++;
        prompt.showToast({ message: `${message} (尝试第 ${this.retryCount} 次)` });

        if (this.retryCount >= CONSTANTS.MAX_PLAYBACK_RETRIES) {
            prompt.showToast({ message: `多次尝试失败，已停止播放`, duration: 5000 });
            this.resetPlayer();
            return;
        }

        setTimeout(() => {
            this.change(1); // 尝试播放下一首
        }, 1500 + (this.retryCount * 1000));
    },


    second2time(second) {
        if (isNaN(second) || second < 0) return "00:00";
        const sec = Math.floor(second % 60).toString().padStart(2, "0");
        const min = Math.floor(second / 60).toString().padStart(2, "0");
        return `${min}:${sec}`;
    },    goToMenu() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请稍后' }); return; }
        if (this.isFmMode) {prompt.showToast({message: '当前处于FM模式！打开过多页面将导致中断！' });}
        router.push({ uri: "/pages/menu" });
    },    playOrPause() {
        if (!this.currSong) {
        prompt.showToast({ message: '没有可播放的歌曲' });
        return;
    }

    // --- 核心修正点 ---
    // 检查 audio.src 是否为空。如果为空，说明是状态恢复后首次点击播放。
    if (!audio.src) {
        console.log("首次播放（或状态恢复后播放），调用 startLogic 获取播放链接。");
        // 调用 startLogic 会获取有效的 src 并自动开始播放。
        this.startLogic(); 
        return; // 立即返回，因为 startLogic 会处理后续的播放状态
    }
        if (!this.currSong || this.isChangingSong) return;
        this.playerState.isPlaying ? audio.pause() : audio.play();
    },
    exit() {
        app.terminate();
    },
};
</script>

<style>
.demo-page {
	width: 466px;
	height: 466px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background-color: #000;
}

.play-button {
	width: 200px;
}

/* --- 歌词容器 --- */
.lyrics-container {
  width: 100%;
  height: 130px;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.lyrics-container-expended {
  width: 100%;
  height: 308px; /* 扩展高度以显示更多歌词 */
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

/* --- 歌词行通用样式 --- */
.lyric-line {
  width: 90%; /* 留出一些边距，避免紧贴屏幕边缘 */
  text-align: center;
  /* 默认所有歌词行都单行省略 */
  lines: 1; 
  text-overflow: ellipsis;
}

/* --- 次要歌词 (非当前高亮) --- */
.secondary-lyric {
  font-size: 22px;
  color: rgba(255, 255, 255, 0.5);
  height: 35px;
}

/* --- 当前高亮歌词 --- */
.current-lyric {
  font-size: 26px;
  color: #3ae1ff;
  font-weight: bold;
  lines: 1;
  text-overflow: ellipsis;
}

/* --- 附加歌词 (翻译/罗马音) --- */
.extra-lyric {
  font-size: 24px;
  color: rgba(255, 255, 255, 0.8);
}

/* 
 * **核心修改**: 
 * 当歌词容器处于展开状态 (.lyrics-container-expended) 时，
 * 其内部的 .current-lyric 和 .extra-lyric 将不再限制行数。
 */
.lyrics-container-expended,.current-lyric,
.lyrics-container-expended,.extra-lyric {
    lines: -1; /* -1 表示不限制行数，实现完整显示 */
}


/* --- 其他样式 (无变化) --- */
.progress {
	height: 60px;
	width: 320px;
	flex-direction: column;
	align-items: center;
}

.play-time {
	text-align: left;
	color: #ffffff;
	font-size: 22px;
	margin: 5px;
}

.play-progress {
    width: 80%;
	selected-color: #3ae1ff;
	block-color: #ffffff;
	padding-left: 0px;
	padding-right: 0px;
	margin: 0 20px;
}

.song {
	width: 320px;
	height: 80px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

.song-name {
	width: 320px;
	font-size: 32px;
	color: #ffffff;
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
}

.singer-name {
	width: 300px;
	font-size: 24px;
	color: rgba(255, 255, 255, 0.8);
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
}

.controls {
	width: 360px;
	justify-content: space-between;
	align-items: center;
}

.icon {
	width: 80px;
	height: 80px;
}

.footer {
	height: 75px;
	width: 100%; /* 让 footer 占满宽度以容纳内部容器 */
	justify-content: center; /* 让内部容器居中 */
	align-items: center;
}

/* 新增：方屏 footer 内部容器样式 */
.footer-content-rect {
    width: 90%; /* 在方屏上使用更宽的布局 */
    justify-content: space-around;
    align-items: center;
}

/* 新增：圆屏 footer 内部容器样式 (即您原来的 .footer 样式) */
.footer-content-circle {
    width: 320px;
    justify-content: space-around;
    align-items: center;
}

.footer-icon {
  width: 64px;
  height: 64px;
}


@media screen and (shape: rect) {
    .lyrics-container {
        height: 180px;
    }
    .lyrics-container-expended {
        height: 394px;
    }
    .current-lyric {
  lines: -1;
  text-overflow: ellipsis;
}
.progress {
	height: 60px;
	width: 400px;
}
.secondary-lyric {
  height: 45px;
}
}
</style>
