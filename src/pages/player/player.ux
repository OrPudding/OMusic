<template>
	<div class="demo-page">
		<!-- 1. 歌曲信息 (保持在顶部) -->
		<div class="song" onswipe="handleHeaderSwipe">
			<marquee class="song-name" scrollamount="36">{{ songName }}</marquee>
			<marquee class="singer-name" scrollamount="36">{{ songArtists }}</marquee>
		</div>
		<!-- 2. 核心内容区域: 使用 show 属性切换视图，避免销毁和重建 -->

        <!-- 视图 0: 播放器主界面 (swiperCurrentIndex === 0 时渲染) -->
        <div if="{{ swiperCurrentIndex === 0 }}" class="swiper-item player-view" onswipe="handleSwipe">
            <!-- a. 播放控制按钮 -->
            <div class="controls">
                <!-- Prev -->
                <image class="icon pressable {{ prevBtnClass }} {{ prevBtnAnim }}"
                       src="/common/icon/prev.png"
                       ontouchstart="pressDown('prevBtn')"
                       ontouchend="pressRelease('prevBtn')"
                       ontouchcancel="pressCancel('prevBtn')"
                       onclick="change(-1)" />
              
                <!-- Play/Pause -->
                <image class="pressable {{ playBtnClass }} {{ playBtnAnim }}"
                       src="{{ playButtonIcon }}"
                       ontouchstart="pressDown('playBtn')"
                       ontouchend="pressRelease('playBtn')"
                       ontouchcancel="pressCancel('playBtn')"
                       onclick="onPlayBtnClick" />
              
                <!-- Next -->
                <image class="icon pressable {{ nextBtnClass }} {{ nextBtnAnim }}"
                       src="/common/icon/next.png"
                       ontouchstart="pressDown('nextBtn')"
                       ontouchend="pressRelease('nextBtn')"
                       ontouchcancel="pressCancel('nextBtn')"
                       onclick="change(1)" />
              </div>
              
              
            <!-- b. 播放进度条 -->
            <div class="progress">
                <div class="progress-text">
                <text class="play-time">{{ progressCurrentTime }}</text>
                <text class="play-time">{{ progressTotalTime }}</text>
                </div>
                <slider class="play-progress {{ sliderAnim }}"  
                        min="0" 
                        max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}" 
                        step="1" 
                        value="{{ playerState.playDuration }}" 
                        onchange="onSliderChange"
                        ontouchstart="onSliderTouchStart"
                        ontouchend="onSliderTouchEnd"
                        ontouchcancel="onSliderTouchCancel">
                </slider>
            </div>
            <!-- c. 底部操作栏 -->
            <div class="footer">
                <div class="footer-content">
                    <image class="footer-icon pressable {{volumeBtnClass}} {{volumeBtnAnim}}" src="/common/icon/volume.png" 
                    ontouchstart="pressDown('volumeBtn')"
                    ontouchend="pressRelease('volumeBtn')"
                    ontouchcancel="pressCancel('volumeBtn')"
                    onclick="goToSongActions"></image>
                    <image class="footer-icon footer-icon-down pressable {{downloadBtnClass}} {{downloadBtnAnim}}" src="/common/icon/download.png" 
                    ontouchstart="pressDown('downloadBtn')"
                    ontouchend="pressRelease('downloadBtn')"
                    ontouchcancel="pressCancel('downloadBtn')"
                    onclick="initiateDownload"></image>
                    <image class="footer-icon pressable {{menuBtnClass}} {{menuBtnAnim}}" src="/common/icon/play-list.png" 
                    ontouchstart="pressDown('menuBtn')"
                    ontouchend="pressRelease('menuBtn')"
                    ontouchcancel="pressCancel('menuBtn')"
                    onclick="goToMenu"></image>
                </div>
            </div>
        </div>


        <image class="little-icon" src="{{ downloadIcon }}" if="{{ downloadIcon && swiperCurrentIndex === 0 }}"></image>

<!-- 视图 1: 歌词页 -->
<scroll
    show="{{ swiperCurrentIndex === 1 }}"
    id="lyricsScrollView"
    class="lyrics-scroll-view"
    scroll-y="true"
    onswipe="handleSwipe"
>
    <div class="lyrics-list-padding-top"></div>

<!-- 【请替换此部分】 -->
<!-- 硬编码64个渲染管道 -->
<div for="{{(index, line) in lyricGroup0}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup1}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup2}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup3}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup4}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup5}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup6}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup7}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup8}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup9}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup10}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup11}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup12}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup13}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup14}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup15}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup16}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup17}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup18}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup19}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup20}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup21}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup22}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup23}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup24}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup25}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup26}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup27}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup28}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup29}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup30}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup31}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup32}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup33}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup34}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup35}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup36}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup37}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup38}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup39}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup40}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup41}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup42}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup43}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup44}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup45}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup46}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup47}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup48}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup49}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup50}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup51}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup52}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup53}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup54}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup55}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup56}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup57}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup58}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup59}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup60}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup61}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup62}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup63}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>


    <div class="lyrics-list-padding-bottom"></div>
</scroll>

                <!-- 3. 手动添加的页面指示器 (放置在最外层，不影响 if/else 结构) 
                <div if="swiperCurrentIndex === 1" class="manual-indicator">
                    <div class="indicator-dot {{ swiperCurrentIndex === 0 ? 'indicator-dot-active' : '' }}"></div>
                    <div class="indicator-dot {{ swiperCurrentIndex === 1 ? 'indicator-dot-active' : '' }}"></div>
                </div>
-->
	</div>
</template>

<style>
/* --- 基础布局 --- */
.demo-page {
    width: 100%;
    height: 100%;
    flex-direction: column;
    justify-content: flex-start; /* 从顶部开始布局 */
    align-items: center;
    background-color: #000;
}
.song { 
    width: 100%; 
    height: 90px; /* 歌曲信息区域高度 */
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    flex-shrink: 0; /* 防止被压缩 */
    padding-top: 30px;
}
.song-name { 
    width: 360px; 
    font-size: 32px; 
    color: #ffffff; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
    font-weight: bold;
}
.singer-name { 
    width: 300px; 
    font-size: 24px; 
    /* 【修改】使用固定颜色代替透明度 */
    color: #cccccc; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
    font-weight: bold;
}

/* --- Swiper 容器与子项 --- */
.content-swiper {
    width: 100%;
    /* 让 swiper 占据剩余的所有空间 */
    flex-grow: 1; 
    indicator-size: 10px;
    /* 【修改】使用固定颜色代替透明度 */
    indicator-color: #555555;
    indicator-selected-color: #BAC3FF;
    indicator-bottom: 10px; /* 指示器位置微调 */
}
/* --- Swiper 容器与子项 --- */
/* 将 .content-swiper 修改为 .swiper-item 并添加 flex-grow */
.swiper-item {
    width: 100%;
    flex-grow: 1; /* 让视图占据剩余的所有空间 */
    flex-direction: column;
    align-items: center;
}

/* --- 手动指示器样式 --- */
.manual-indicator {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    height: 20px;
    flex-direction: row;
    justify-content: center;
    align-items: center;
}
.indicator-dot {
    width: 10px;
    height: 10px;
    border-radius: 5px;
    background-color: #555555; /* 对应原 indicator-color */
    margin: 0 5px;
}
.indicator-dot-active {
    background-color: #BAC3FF; /* 对应原 indicator-selected-color */
}

/* 播放器视图内部布局 */
.player-view {
    justify-content: space-around; /* 让三个部分均匀分布 */
    padding: 20px 0;
}
.controls {
    width: 92%;
	justify-content: space-around; /* 按钮间距更均匀 */
	align-items: center;
}
.icon {
	width: 85px;
	height: 107px;
    margin-top: 16px;
}
.icon-play-pause {
    width: 132px;
    height: 132px;
    margin-bottom: 6px;
}
.progress { 
    height: 80px; 
    width: 90%; 
    flex-direction: column; 
    align-items: center; 
}
.progress-text {
    width: 80%;
    justify-content: space-between;
}
.play-time { 
    text-align: left; 
    color: #ffffff; 
    font-size: 24px; 
    margin: 5px; 
    font-weight: bold;
}
.play-progress { 
    width: 80%; 
    selected-color: #BAC3FF; 
    block-color: #ffffff; 
    padding-left: 0px; 
    padding-right: 0px; 
    margin: 0 20px; 
    transform-origin: 50% 50%;
}


/* 按下：轻微收紧（更克制） */
.slider-press-down {
  animation-name: SliderPressDown;
  animation-duration: 80ms;
  animation-timing-function: cubic-bezier(0.25, 0.55, 0.25, 1);
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}
/* 松开：平稳回到位，极小过冲（可选） */
.slider-press-up {
  animation-name: SliderPressUp;
  animation-duration: 140ms;
  animation-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}

@keyframes SliderPressDown {
  0%   { transform: scale(1, 1); opacity: 1; }
  100% { transform: scale(1.00, 0.96); opacity: 0.8; }
}

/* 这里过冲非常小；如果你想完全无过冲，我下面给你“无过冲版” */
@keyframes SliderPressUp {
  0%   { transform: scale(1.00, 0.96); opacity: 0.8; }
  70%  { transform: scale(1.00, 1.01); opacity: 1; }
  100% { transform: scale(1, 1); opacity: 1; }
}

.footer { 
    width: 100%; 
    justify-content: center; 
    align-items: center; 
}

.footer-content{ 
    width: 360px; 
    justify-content: space-around; 
}
.footer-icon { 
    width: 91px; 
    height: 66px; 
}
.little-icon {
    position: absolute;
    top: 353px;
    left: 244px;
    width: 41px;
    height: 41px;
}
.footer-icon-down {
    margin-top: 40px;
}
/* --- 歌词视图样式 (已优化 - 无透明度版) --- */
.lyrics-scroll-view {
    width: 100%;
    height: 376px;
    padding:0 10px;
    flex-direction: column;
    align-items: center;
}
.lyrics-list-padding-top, .lyrics-list-padding-bottom {
    height: 150px; 
}
.lyric-line-wrapper {
    width: 100%;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3px 0;
}
.is-current-wrapper {
    /* 【修改】使用固定颜色代替透明度 */
    background-color: #1A1A1A; 
    border-radius: 50%;
}
/* 【【【新增】】】 点击选中时的蓝色边框样式 */
.is-selected-wrapper {
    border: 3px solid #1A1A1A; /* 使用主题蓝色作为边框颜色 */
    border-radius: 50%;       /* 使用一个固定的圆角值 */
}
.lyric-line {
    width: 90%;
    text-align: center;
    lines: -1;
    
    /* 【核心修改】默认状态：非当前行，使用灰色代替白色+透明度 */
    color: #999999; 
    font-size: 26px;
}
/* 【核心修改】当前行的激活状态 */
.current-lyric {
    /* 【移除】opacity: 1; (已是默认) */
    color: #BAC3FF;
    font-weight: bold;
    font-size: 28px;
    padding: 6px 0;
}

.extra-lyric {
    font-size: 22px;
    /* 【修改】使用固定颜色代替白色+透明度 */
    color: #BBBBBB;
    padding-bottom: 6px;
}
/* --- 评论区占位符 --- */
.comments-view {
    justify-content: center;
    /* 【修改】使用固定颜色代替透明度 */
    color: #666666;
}
.placeholder-icon {
    width: 60px;
    height: 60px;
    /* 【修改】使用固定颜色代替透明度 */
    color: #4D4D4D;
}
.placeholder-text {
    font-size: 24px;
    margin-top: 8px;
}
.pressable {
  /* 尺寸由具体按钮决定 */
  padding: 6px;                /* 动画安全区 */
  margin-bottom: 6px;

  align-items: center;
  justify-content: center;

  /* 关键：原点下移，避免向上被裁 */
  transform-origin: 50% 62%;

  opacity: 1;
  transform: scale(1);
}

/* 静态暗压态（按住时） */
.is-down {
  transform: scale(0.92);
  opacity: 0.75;
}

/* 按下瞬间动画：保留你最初的 ease-out */
.press-down {
  animation-name: PressDown;
  animation-duration: 80ms;
  animation-timing-function: ease-out;
  animation-iteration-count: 1;
  animation-fill-mode: none;   /* 关键：不留最终态 */
}

/* 抬起回弹：保留你最初觉得“最好”的曲线 */
.press-up {
  animation-name: PressUp;
  animation-duration: 140ms;
  animation-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
  animation-iteration-count: 1;
  animation-fill-mode: forwards;
}

@keyframes PressDown {
  0%   { transform: scale(1);    opacity: 1; }
  100% { transform: scale(0.92); opacity: 0.75; }
}

/* 132px 资源：峰值控制在 1.04，避免遮挡 */
@keyframes PressUp {
  0%   { transform: scale(0.92); opacity: 0.75; }
  100% { transform: scale(1);    opacity: 1; }
}

/* --- 媒体查询 --- */
@media screen and (shape: rect) {
    .controls {
        height: 208px;
        width: 380px;
    }
    .icon{
        margin-top: 0px;
    }
    .progress {
        width: 432px;
        height: 80px;
    }
    .footer-content{ 
    width: 90%; 
    justify-content: space-around; 
    align-items: center; 
}
.footer-icon-down {
    margin-top: 0px;
}.little-icon {
    position: absolute;
    top:384px;
    left: 228px;
}
    .lyrics-scroll-view {
        height: 424px;
    }
    .is-current-wrapper {
        /* 【修改】使用固定颜色代替透明度 */
        background-color: #1A1A1A;
        border-radius: 24px;
    }
        /* 【【【新增】】】 确保方形屏幕下选中样式也生效 */
        .is-selected-wrapper {
        border-radius: 24px;
    }
    .lyrics-list-padding-top, .lyrics-list-padding-bottom {
        height: 190px;
    }
    /* 方形屏幕下字体也相应缩小 */
    .secondary-lyric { font-size: 24px; }
    .current-lyric { font-size: 26px; }
    .extra-lyric { font-size: 19px; }
}
@media screen and (shape: circle) {
    .song-name { 
        width: 260px; }
    
}
</style>


<script>
import router from "@system.router";
import audio from "@system.audio";
import file from "@system.file";
import prompt from '@system.prompt';
import device from '@system.device';
import app from "@system.app";
import brightness from "@system.brightness";

import apiService from '../../services/api.js';
import throttle from '../../utils/throttle.js';

const CONSTANTS = {
    DIR_MUSIC: 'internal://files/music/',
    DIR_LYRICS: 'internal://files/lyrics/',
    FILE_PLAY_LIST: 'internal://files/play_list.json',
    FILE_DOWNLOADED_SONGS: 'internal://files/downloaded_songs.json',
    SETTINGS_FILE_URI: 'internal://files/settings.json',
    COOKIE_FILE_URI: 'internal://files/cookie.txt',
    FILE_PLAYER_STATE: 'internal://files/player_state.json',
    MAX_PLAYBACK_RETRIES: 3,
    PLAY_TIMEOUT: 8000,
};

const REVERSE_DIRECTIONS = {
    left: 'right',
    right: 'left',
    up: 'down',
    down: 'up'
};

const fileService = {
    _promisify(fn, options) { return new Promise((resolve, reject) => { fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) }); }); },
    async readJson(uri, defaultValue = null) { try { const data = await this._promisify(file.readText, { uri }); return JSON.parse(data.text); } catch (e) { return defaultValue; } },
    async writeJson(uri, data) { try { await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) }); return true; } catch (e) { return false; } },
};

export default {
    private: {
    playerState: {
      isPlaying: false,
      playDuration: 0,
      currentLyricIndex: -1, // 当前高亮行在原始lyrics数组中的索引
      lyricType: 'chinese'
    },

    currSong: null,
    lyrics: [], // 原始歌词数据 (带time, original, translation等)

    // --- 核心优化数据结构 ---
    lyricLines: [],

    // 声明64个渲染管道
    lyricGroup0: [], lyricGroup1: [], lyricGroup2: [], lyricGroup3: [],
    lyricGroup4: [], lyricGroup5: [], lyricGroup6: [], lyricGroup7: [],
    lyricGroup8: [], lyricGroup9: [], lyricGroup10: [], lyricGroup11: [],
    lyricGroup12: [], lyricGroup13: [], lyricGroup14: [], lyricGroup15: [],
    lyricGroup16: [], lyricGroup17: [], lyricGroup18: [], lyricGroup19: [],
    lyricGroup20: [], lyricGroup21: [], lyricGroup22: [], lyricGroup23: [],
    lyricGroup24: [], lyricGroup25: [], lyricGroup26: [], lyricGroup27: [],
    lyricGroup28: [], lyricGroup29: [], lyricGroup30: [], lyricGroup31: [],
    lyricGroup32: [], lyricGroup33: [], lyricGroup34: [], lyricGroup35: [],
    lyricGroup36: [], lyricGroup37: [], lyricGroup38: [], lyricGroup39: [],
    lyricGroup40: [], lyricGroup41: [], lyricGroup42: [], lyricGroup43: [],
    lyricGroup44: [], lyricGroup45: [], lyricGroup46: [], lyricGroup47: [],
    lyricGroup48: [], lyricGroup49: [], lyricGroup50: [], lyricGroup51: [],
    lyricGroup52: [], lyricGroup53: [], lyricGroup54: [], lyricGroup55: [],
    lyricGroup56: [], lyricGroup57: [], lyricGroup58: [], lyricGroup59: [],
    lyricGroup60: [], lyricGroup61: [], lyricGroup62: [], lyricGroup63: [],

    swiperCurrentIndex: 0, // 你强调的 DOM if 开关：绝不删除

    downloadedSongs: {},

    settings: {
      lyrics: { japaneseMode: 'translation', cantoneseMode: 'romaji', englishMode: 'translation' },
      lyricAdvanceTime: 1.5,
      gestures: { left: 'lyrics', right: 'playlist', up: 'none', down: 'none' },
      audioQuality: { online: 64, download: 128 }
    },

    cookie: null,
    isDownloadingLocked: false,
    retryCount: 0,
    screenShape: 'circle',
    playMode: 0,
    songBeingDownloaded: null,

    isFmMode: false,
    fmQueue: [],
    isFetchingFm: false,

    pendingSongId: null,
    playTimeoutId: null,
    needsRefresh: false,

    _lyricsScrollView: null,
    selectedLyricIndex: -1,
    selectionTimeoutId: null,
    _gestureToLyrics: null,
    isSliderDragging: false,

    prevBtnClass: '',
  prevBtnAnim: '',
  playBtnClass: '',
  playBtnAnim: '',
  nextBtnClass: '',
  nextBtnAnim: '',
  sliderClass: '',
  sliderAnim: '',
  volumeBtnClass: '',
    volumeBtnAnim: '',
    downloadBtnClass: '',
    downloadBtnAnim: '',
    menuBtnClass: '',
    menuBtnAnim: '',
    _playBtnDown: false,

    // =========================
    // 【新增】最小增量：恢复进度用
    // -1 表示不需要恢复；>=0 表示下次播放需要seek到这里
    // =========================
    resumeTime: -1,
  },

  protected: {
    playList: [],
    currentIndex: 0,
    currentLyricIndex: -1,

    songId: null,
    songInfo: null,

    triggerDownload: false,
    triggerPlayModeToggle: false,
    startFmMode: false,
  },

  computed: {
    songName() { return this.currSong ? this.currSong.name : "未知歌曲"; },
    songArtists() { return this.currSong ? this.currSong.artists : "未知艺术家"; },
    playButtonIcon() {
      if (this.pendingSongId && !this.playerState.isPlaying) return '/common/icon/loading.png';
      return this.playerState.isPlaying ? '/common/icon/pause.png' : '/common/icon/play.png';
    },
    progressCurrentTime() {
      return this.second2time(this.playerState.playDuration);
    },
    progressTotalTime() {
      const duration = this.currSong?.duration || 0;
      return this.second2time(duration);
    },
    downloadIcon() {
      const icons = { downloading: '/common/icon/waiting_icon.png', downloaded: '/common/icon/done_icon.png', not_downloaded: null };
      if (!this.currSong) return icons.not_downloaded;
      if (this.songBeingDownloaded && this.currSong.id === this.songBeingDownloaded.id) return icons.downloading;
      if (this.downloadedSongs[this.currSong.id]) return icons.downloaded;
      return icons.not_downloaded;
    },
    playModeIcon() {
      if (this.isFmMode) return '/common/icon/fm.png';
      const icons = ['/common/icon/loop.png', '/common/icon/single-loop.png', '/common/icon/random.png'];
      return icons[this.playMode] || icons[0];
    },
  },
    async onInit() {
        if (this.$app.$def.isActivated !== true) { router.replace({ uri: '/pages/splash' }); return; }
        console.log("Player onInit: 准备基础环境。");
        this.throttledSliderChange = throttle(this.applySliderChange, 50);
        
        this.bindAudioEvents();
        await this.loadSettings();
        await this.loadCookie();
        await this.loadDownloadedSongs();
        this.getDeviceInfo();
        await this.onRestoreState();
    },

    onShow() {
        console.log("Player onShow: 页面显示，标记需要刷新。");
        this.needsRefresh = true;
        
        // 【优化】如果当前在歌词页，保持屏幕常亮
        if (this.swiperCurrentIndex === 1) {
            brightness.setKeepScreenOn({ keepScreenOn: true });
        }
    },

    async onRefresh(query) {
        const params = query || {};
        console.log('Player onRefresh with params:', JSON.stringify(params));

        if (this.needsRefresh) {
            console.log("onRefresh: 加载核心数据。");
            await this.loadDownloadedSongs();
            await this.loadListFromFile();
            this.needsRefresh = false;
        }

        if (params.triggerDownload) { this.initiateDownload(); return; }
        if (params.startFmMode) { this.dostartFmMode(params.songId, params.songInfo); return; }
        if (params.triggerPlayModeToggle) { this.togglePlayMode(); }

        if (params.songId) {
            if (!this.currSong || this.currSong.id != params.songId) {
                console.log(`onRefresh: 收到新歌指令 [${params.songId}]`);
                this.songId = params.songId;
                this.songInfo = params.songInfo ? JSON.parse(params.songInfo) : null;
                await this.startLogic();
            }
            return; 
        }

        if (this.currSong) {
            const stillInPlaylist = this.playList.some(song => song.id === this.currSong.id);
            if (!stillInPlaylist) {
                prompt.showToast({ message: "当前歌曲已从列表中移除" });
                await this.change(1); 
            }
        }
    },

    onDestroy() {
        console.log("Player onDestroy: 页面被销毁。");
        audio.stop();
        // 【优化】确保即使在下载中退出，也能尝试保存状态
        this.onSaveState();
        // 清理所有定时器
        if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
        // 如果有其他定时器也在这里清理
        brightness.setKeepScreenOn({ keepScreenOn: false }); // 关闭屏幕常亮
        console.log("播放器已销毁，状态已保存，资源已释放。");
    },

    onBackPress() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请勿退出' }); return true; }
        this.onSaveState();
        // 优化提示，让用户知道如何真正退出
        prompt.showToast({ message: '顶栏右滑退出应用' });
        return true; // 返回 true 表示消费该事件，应用不会退出
    },

    pressDown(key) {
  // 清动画，保证可重复触发
  this[key + 'Anim'] = '';
  // 进入静态暗压态
  this[key + 'Class'] = 'is-down';
  // 按下瞬间动画（可选，但手感更好）
  setTimeout(() => {
    this[key + 'Anim'] = 'press-down';
  }, 0);
},

pressRelease(key) {
  // 移除暗压态
  this[key + 'Class'] = '';
  // 回弹动画一发
  this[key + 'Anim'] = '';
  setTimeout(() => {
    this[key + 'Anim'] = 'press-up';
  }, 0);
},

pressCancel(key) {
  // 兜底复位（滑出 / touchcancel / 业务 return）
  this[key + 'Class'] = '';
  this[key + 'Anim'] = '';
},
onPlayBtnUp() {
  // 抬起：移除暗压态 + 跑回弹
  this._releasePlayBtnWithPop();
},

onPlayBtnClick() {
  // 点击：无论业务是否 return，都保证按钮恢复
  this._releasePlayBtnWithPop();

  // 再执行业务逻辑
  this.playOrPause();
},

_releasePlayBtnWithPop() {
  // 1) 先去掉暗压
  this.playBtnClass = '';

  // 2) 让回弹动画每次都能重播：先清空再 set
  this.playBtnAnim = '';
  setTimeout(() => { this.playBtnAnim = 'press-up'; }, 0);
},

    async onRestoreState() {
    if (this.songId) return false;

    const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
    const isStateExpired = savedState?.timestamp
        ? (new Date().getTime() - savedState.timestamp > 12 * 3600 * 1000)
        : true;

    if (savedState && savedState.lastSongId && savedState.duration && !isStateExpired) {
        await this.loadListFromFile();
        const lastIndex = this.playList.findIndex(song => song && song.id === savedState.lastSongId);

        if (lastIndex > -1) {
            console.log(`onRestoreState: 恢复歌曲: ${this.playList[lastIndex].name}`);

            this.songId = savedState.lastSongId;
            this.currentIndex = lastIndex;
            this.playMode = savedState.playMode || 0;

            this.currSong = { ...this.playList[this.currentIndex], duration: savedState.duration };

            // 先把 UI 进度设置为保存值，避免初始显示 00:00
            this.playerState.playDuration = savedState.lastPlayDuration || 0;

            // 记录：等真正 onplay 后再做恢复 seek
            this._pendingRestoreTime = this.playerState.playDuration;

            // 只获取歌词数据（不强制渲染也行，你原逻辑保持）
            this.fetchLyric(this.songId);

            prompt.showToast({ message: "播放状态已恢复" });
            return true;
        }
    }
    return false;
},


    // --- 交互与UI方法 ---
    handleHeaderSwipe(e) {
        const direction = e.direction; // 'left', 'right', 'up', 'down'
        if (direction === 'right') {
            this.exit();
        }
    },
    handleSwipe(e) {
        const direction = e.direction; // 'left', 'right', 'up', 'down'

        // 【新增】如果正在拖动进度条，忽略滑动手势
        if (this.isSliderDragging) {
            console.log("进度条拖动中，忽略滑动手势");
            return;
        }

        // 场景一：当前在播放器主页 (封面页)
        if (this.swiperCurrentIndex === 0) {
            const action = this.settings.gestures[direction];
            
            if (action && action !== 'none') {
                // 如果动作是切换到歌词页
                if (action === 'lyrics') {
                    // 记录下是哪个手势进入了歌词页
                    this._gestureToLyrics = direction; 
                    this.switchToLyricsView();
                } else {
                    // 执行其他通用操作
                    this.executeGestureAction(action);
                }
            }
        } 
        // 场景二：当前在歌词页
        else if (this.swiperCurrentIndex === 1) {
            // 检查当前滑动方向是否是进入歌词页手势的"相反方向"
            if (this._gestureToLyrics && direction === REVERSE_DIRECTIONS[this._gestureToLyrics]) {
                this.switchToPlayerView();
            }
            //右滑也返回播放器主页
            else if (direction === 'right') {
                this.switchToPlayerView();
            }
        }
    },
    onSliderTouchStart() {
  this.isSliderDragging = true;
  this._sliderPressDown();
},

onSliderTouchEnd() {
  this.isSliderDragging = false;
  this._sliderPressUp();
},

onSliderTouchCancel() {
  this.isSliderDragging = false;
  this._sliderPressReset();
},

_sliderPressDown() {
  // 重触发：先清空再上
  this.sliderAnim = '';

    this.sliderAnim = 'slider-press-down';

  // 防御：有些设备不会触发 touchend/cancel（极少见），给个兜底复位
  clearTimeout(this._sliderAnimFailsafe);
  this._sliderAnimFailsafe = setTimeout(() => {
    this._sliderPressReset();
  }, 800);
},

_sliderPressUp() {
  // 无论有没有歌曲，都必须恢复（避免你提到的“无歌曲卡住”）
  this.sliderAnim = '';
  this.$nextTick(() => {
    this.sliderAnim = 'slider-press-up';
  });

  clearTimeout(this._sliderAnimTimer);
  this._sliderAnimTimer = setTimeout(() => {
    this.sliderAnim = '';
  }, 190);

  clearTimeout(this._sliderAnimFailsafe);
},

_sliderPressReset() {
  clearTimeout(this._sliderAnimTimer);
  clearTimeout(this._sliderAnimFailsafe);
  this.sliderAnim = '';
},


    // 辅助方法：执行通用手势操作 (不包括视图切换)
    executeGestureAction(action) {
        console.log(`执行手势操作: ${action}`);
        switch (action) {
            case 'playlist':
                router.push({ uri: "/pages/list", params: { listType: "playlist", targetSongId: this.currSong.id } });
                break;
            case 'search':
                router.push({ uri: "/pages/search" });
                break;
            case 'user':
                router.push({ uri: "/pages/user" });
                break;
            case 'settings':
                router.push({ uri: "/pages/settings" });
                break;
            case 'prev':
                this.change(-1);
                break;
            case 'next':
                this.change(1);
                break;
            // 注意：'lyrics' 的处理已移至 handleSwipe 中
            default:
                console.log(`未知的自定义手势操作: ${action}`);
                break;
        }
    },
/**
 * [规范化] 1. 数据入口：获取新歌词时调用
 * - 职责：解析歌词，构建唯一的扁平状态数组 `lyricLines`，并分发引用到渲染管道。
 */
 processAndMergeLyrics(data) {
    // a. 解析歌词，获得原始数据 this.lyrics (逻辑不变)
    if (!data?.lrc?.lyric) {
        this.lyrics = [{ time: 0, text: '暂无歌词' }];
    } else {
        const original = this.parseLyric(data.lrc.lyric);
        const translation = data.tlyric?.lyric ? this.parseLyric(data.tlyric.lyric) : null;
        const romaji = data.romalrc?.lyric ? this.parseLyric(data.romalrc.lyric) : null;
        this.mergeLyrics(original, translation, romaji);
    }
    
    // b. 构建【单一事实来源】的扁平状态数组 this.lyricLines
    this.lyricLines = this.lyrics.map((line, index) => ({
        id: `lyric-${line.time}-${index}`,
        originalIndex: index, // 全局唯一索引，至关重要
        original: line.original || line.text || '',
        extra: null,
        isCurrent: false,
        isSelected: false,
    }));

    // c. 将 lyricLines 中的对象引用，分发到10个只读的渲染管道中
    this.distributeLyricsToGroups();
    
    // d. 立即根据当前播放时间更新一次高亮状态
    this.updateLyric();
},

distributeLyricsToGroups() {
  const NUM_GROUPS = 64;

  for (let i = 0; i < NUM_GROUPS; i++) this[`lyricGroup${i}`] = [];

  const lines = this.lyricLines; // 原始数组只读使用
  const total = lines ? lines.length : 0;
  if (!total) {
    this._lyricGroupMeta = [];
    return;
  }

  const base = Math.floor(total / NUM_GROUPS);
  const remainder = total % NUM_GROUPS;

  this._lyricGroupMeta = new Array(NUM_GROUPS);

  let cursor = 0;
  for (let g = 0; g < NUM_GROUPS; g++) {
    const count = base + (g < remainder ? 1 : 0);
    const start = cursor;
    const end = cursor + count - 1;

    // slice：不修改 lyricLines；只创建 group 的数组“壳”
    this[`lyricGroup${g}`] = count > 0 ? lines.slice(cursor, cursor + count) : [];
    cursor += count;

    this._lyricGroupMeta[g] = { start, end, count };
  }
},

getLyricGroupIndex(lyricIndex) {
  const meta = this._lyricGroupMeta;
  if (!meta || meta.length !== 64 || lyricIndex < 0) return -1;

  let lo = 0, hi = meta.length - 1;
  while (lo <= hi) {
    const mid = (lo + hi) >> 1;
    const m = meta[mid];
    if (!m || m.count <= 0) return -1;

    if (lyricIndex < m.start) hi = mid - 1;
    else if (lyricIndex > m.end) lo = mid + 1;
    else return mid;
  }
  return -1;
},


refreshLyricGroupsByIndex(indices) {
  if (!indices || !indices.length) return;

  const touched = new Set();
  for (let i = 0; i < indices.length; i++) {
    const g = this.getLyricGroupIndex(indices[i]);
    if (g >= 0) touched.add(g);
  }

  touched.forEach((g) => {
    const key = `lyricGroup${g}`;
    const arr = this[key];
    // 只重建该组数组引用，触发该组 DOM 刷新；不动 lyricLines
    this[key] = arr ? arr.slice() : [];
  });
},


/**
 * [规范化] 3. 状态重置：切歌或重置播放器时调用
 * - 职责：清空所有与歌词相关的数据状态。
 */
resetLyrics() {
    this.lyrics = [];
    this.lyricLines = [];
    this.playerState.currentLyricIndex = -1;
    this.selectedLyricIndex = -1;
    
    for (let i = 0; i < 64; i++) { this[`lyricGroup${i}`] = []; }
this._lyricGroupMeta = [];


    if (this.selectionTimeoutId) {
        clearTimeout(this.selectionTimeoutId);
        this.selectionTimeoutId = null;
    }
},

updateLyric() {
  if (this.swiperCurrentIndex !== 1) return;
  if (!this.lyrics || this.lyrics.length === 0) return;
  if (!this.lyricLines || this.lyricLines.length !== this.lyrics.length) return;

    const lookaheadTime = this.playerState.playDuration + (this.settings.lyricAdvanceTime || 1.5);
    const oldIndex = this.playerState.currentLyricIndex;

    // a. 二分查找：最后一个 time <= lookaheadTime 的行
    let newIndex = 0;
    let low = 0;
    let high = this.lyrics.length - 1;
    while (low <= high) {
        const mid = Math.floor((low + high) / 2);
        if (this.lyrics[mid].time > lookaheadTime) {
            high = mid - 1;
        } else {
            newIndex = mid;
            low = mid + 1;
        }
    }

    // b. 索引未变：不做任何 DOM 刷新（关键：停止每秒刷新）
    if (newIndex === oldIndex) return;

    // c. 在状态中心 lyricLines 上修改属性
    if (oldIndex >= 0) {
        this.lyricLines[oldIndex].isCurrent = false;
        this.lyricLines[oldIndex].extra = null;
    }
    if (newIndex >= 0) {
        this.lyricLines[newIndex].isCurrent = true;
        this.lyricLines[newIndex].extra = this.getExtraLyricText(this.lyrics[newIndex]);
    }

    // d. 只刷新受影响的 group（旧高亮组 + 新高亮组）
    this.refreshLyricGroupsByIndex([oldIndex, newIndex]);

    // e. 更新索引并滚动
    this.playerState.currentLyricIndex = newIndex;
    this.$nextTick(() => { this.scrollToCurrentLyric(); });
},



/**
 * [最终修正] 歌词行点击事件
 * - 修正双击跳转逻辑，避免刷新冲突。
 */
 onLyricLineClick(line, originalIndex) {
    const index = originalIndex;

    if (this.selectedLyricIndex !== index) { // 首次点击
        if (this.playerState.isPlaying) { audio.pause(); }
        
        this.clearSelectionTimeout();
        this.updateLyricSelection(this.selectedLyricIndex, false);
        this.selectedLyricIndex = index;
        this.updateLyricSelection(index, true);

        this.startSelectionTimeout();
        prompt.showToast({ message: `已暂停，再次点击跳转` ,duration: 200});
    } 
    else { // 第二次点击 (确认跳转)
        this.clearSelectionTimeout();
        
// 二次点击确认跳转：清选中 + 只刷新该行所在 group（防止选中框残留）
if (this.selectedLyricIndex !== -1) {
    const prevSel = this.selectedLyricIndex;
    this.lyricLines[prevSel].isSelected = false;
    this.selectedLyricIndex = -1;

    // 只刷受影响 group：保证选中态立即从 UI 消失
    this.refreshLyricGroupsByIndex([prevSel]);
}


        // 跳转并播放
        const targetTime = this.lyrics[index].time;
        audio.currentTime = targetTime;
        audio.play();
        prompt.showToast({ message: `已跳转到 ${this.second2time(targetTime)}` ,duration: 200});
        
        // updateLyric() 会计算新的高亮行，并触发一次完整的、正确的UI刷新。
        this.updateLyric(); 
        this.$nextTick(() => this.scrollToCurrentLyric(true));
    }
},


/**
 * [最终修正] 重置选中状态 (例如在2秒超时后调用)
 * - 这个函数现在只负责在需要明确取消选中框时，才触发UI刷新。
 */
resetLyricSelection() {
    if (this.selectedLyricIndex !== -1) {
        // 调用 updateLyricSelection 来确保UI上的选中框被移除
        this.updateLyricSelection(this.selectedLyricIndex, false);
        this.selectedLyricIndex = -1;
    }
},

updateLyricSelection(index, isSelected) {
    if (index < 0 || index >= this.lyricLines.length) return;

    const line = this.lyricLines[index];
    if (line && line.isSelected !== isSelected) {
        line.isSelected = isSelected;
        // 只刷新该行所在 group
        this.refreshLyricGroupsByIndex([index]);
    }
},



// 视图切换函数保持不变，但调用时机已由 handleSwipe 控制
switchToLyricsView() {
  if (this.swiperCurrentIndex === 1) return;
  console.log("显示歌词视图");

  // 1) 强制复位所有按钮暗压 / 动画
  this.resetAllPressStates();

  // 2) 退出沉浸（理论上在播放器页不该有，但兜底）
  this.exitImmersiveIfNeeded();

  // 3) 切换视图
  this.swiperCurrentIndex = 1;

  // 4) 开启常亮（防御式）
  try {
    if (brightness && typeof brightness.setKeepScreenOn === 'function') {
      brightness.setKeepScreenOn({ keepScreenOn: true });
    }
  } catch (e) {
    console.log('setKeepScreenOn(true) fail:', e);
  }

  // 5) 歌词滚动对齐
  this.$nextTick(() => {
    if (!this._lyricsScrollView) {
      this._lyricsScrollView = this.$element('lyricsScrollView');
    }
    this.scrollToCurrentLyric(true);
  });
},
/**
 * 【【【逻辑修正】】】
 * 滑回播放器页面时的处理
 */
 switchToPlayerView() {
  if (this.swiperCurrentIndex === 0) return;
  console.log("显示播放器视图");

  // 1) 复位所有按钮暗压 / 动画
  this.resetAllPressStates();

  // 2) 退出沉浸模式（如果在歌词页点了当前行）
  this.exitImmersiveIfNeeded();

  // 3) 切换视图
  this.swiperCurrentIndex = 0;

  // 4) 关闭常亮（防御式）
  try {
    if (brightness && typeof brightness.setKeepScreenOn === 'function') {
      brightness.setKeepScreenOn({ keepScreenOn: false });
    }
  } catch (e) {
    console.log('setKeepScreenOn(false) fail:', e);
  }

  // 5) 如果存在一个待处理的选中操作：无条件恢复播放 + 清选中
  if (this.selectedLyricIndex !== -1) {
    this.clearSelectionTimeout();
    audio.play();                // 【关键】无条件继续播放
    this.resetLyricSelection();
  }
},


    resetAllPressStates() {
  const keys = ['prevBtn', 'playBtn', 'nextBtn'];
  for (const key of keys) {
    const cls = key + 'Class';
    const anim = key + 'Anim';
    if (this.hasOwnProperty(cls)) this[cls] = '';
    if (this.hasOwnProperty(anim)) this[anim] = '';
  }
},

exitImmersiveIfNeeded() {
  if (!this.isImmersive) return;
  this.isImmersive = false;
  if (this._stopImmersiveTick) this._stopImmersiveTick();
},


    /**
     * 启动2秒后自动取消选中的定时器
     */
     startSelectionTimeout() {
        this.selectionTimeoutId = setTimeout(() => {
            prompt.showToast({ message: '选中已取消' ,duration: 200});
            
            // 【关键】无条件继续播放
            audio.play();
            
            this.resetLyricSelection();
        }, 2000);
    },

    /**
     * 【【【逻辑修正】】】
     * 清除定时器，但不改变播放状态
     */
    clearSelectionTimeout() {
        if (this.selectionTimeoutId) {
            clearTimeout(this.selectionTimeoutId);
            this.selectionTimeoutId = null;
        }
    },


    getDeviceInfo() { device.getInfo({ success: (data) => { if (data.screenShape) this.screenShape = data.screenShape; }, fail: (data, code) => console.error(`获取设备信息失败, code = ${code}`) }); },
    async onSaveState() {
        if (!this.currSong || !this.currSong.duration) return;
        const stateToSave = { lastSongId: this.currSong.id, lastPlayDuration: this.playerState.playDuration, playMode: this.playMode, duration: this.currSong.duration, timestamp: new Date().getTime() };
        await fileService.writeJson(CONSTANTS.FILE_PLAYER_STATE, stateToSave);
    },
    playOrPause() {
  if (!this.currSong) {
    // 如果还没选中歌，先加载第一首（不播），再由用户再次点击播放
    if (this.playList && this.playList.length > 0) {
      this.currentIndex = 0;
      this.loadCurrentOnly();
    }
    prompt.showToast({ message: '没有可播放的歌曲' });
    return;
  }

  // 用户主动播放：如果没有 src，直接走 playCurrent（会 startPlayback）
  if (!audio.src) {
    this.playCurrent();
    return;
  }

  if (!this.isChangingSong) {
    this.playerState.isPlaying ? audio.pause() : audio.play();
  }
},

// 真正执行 seek 的方法（仅用户拖动触发）
applySliderChange(progress) {
    // 恢复期间禁止 slider seek
    if (this._restoreSeeking) return;

    const now = Date.now();
    if (this._ignoreSliderUntilTs && now < this._ignoreSliderUntilTs) return;

    // 只有用户拖动才允许 seek（防 UI 回写触发 onchange）
    if (!this.isSliderDragging) return;

    const p = Number(progress);
    if (!isFinite(p) || p < 0) return;

    const dur = (this.currSong && typeof this.currSong.duration === 'number') ? this.currSong.duration : 0;
    if (!(dur > 0)) return;

    const target = Math.max(0, Math.min(p, dur - 0.2));
    const cur = Number(audio.currentTime) || 0;
    if (Math.abs(cur - target) < 0.25) return;

    // console.log(`[Throttled] Applying seek to: ${target}`);
    audio.currentTime = target;

    this.playerState.playDuration = target;
    this.updateLyric();
},

// 进度条 onchange 事件处理函数（仅用户拖动触发）
onSliderChange(e) {
    if (this._restoreSeeking) return;

    const now = Date.now();
    if (this._ignoreSliderUntilTs && now < this._ignoreSliderUntilTs) return;

    if (!this.isSliderDragging) return;

    this.throttledSliderChange(e.progress);
},


goToSongActions() {
    if (!this.currSong) {
        prompt.showToast({ message: '当前无播放歌曲' });
        return;
    }

    // 等待按钮 press-up 动画完成再跳转（克制延迟）
    clearTimeout(this._navDelayTimer);
    this._navDelayTimer = setTimeout(() => {
        router.push({
            uri: "/pages/volume",
            params: {
                currentSong: JSON.stringify(this.currSong),
                screenShape: this.screenShape,
                playMode: this.playMode,
                isFmMode: this.isFmMode
            }
        });
    }, 140); // 和 press-up 动画时长对齐
},

    togglePlayMode() {
        if (this.isFmMode) {
            prompt.showDialog({
                title: '退出私人FM', message: '您确定要退出私人FM吗？将会停止当前播放并返回常规列表模式。', buttons: [{ text: '取消' }, { text: '确定退出', color: '#FF453A' }],
                success: async () => {
                    prompt.showToast({ message: '正在退出私人FM...' });
                    this.isFmMode = false; this.fmQueue = []; this.resetPlayer();
                    try { await this.startLogic(); prompt.showToast({ message: '已返回列表播放模式' }); } catch (error) { prompt.showToast({ message: '播放列表为空' }); }
                },
                cancel: () => prompt.showToast({ message: '操作已取消' })
            });
            return;
        }
        this.playMode = (this.playMode + 1) % 3;
        const modeText = ['列表循环', '单曲循环', '随机播放'];
        prompt.showToast({ message: modeText[this.playMode] });
        if (this.playMode === 2 && this.playList.length > 0) this.generateShuffledList(true);
    },
    goToMenu() {
    if (this._navLock) return;

    if (this.isDownloadingLocked) {
        prompt.showToast({ message: '正在下载，请稍后' });
        return;
    }

    if (this.isFmMode) {
        prompt.showToast({ message: '当前处于FM模式！打开过多页面将导致中断！' });
        // 不 return，和你原逻辑一致
    }

    this._navLock = true;

    clearTimeout(this._navDelayTimer);
    this._navDelayTimer = setTimeout(() => {
        this._navLock = false;
        router.push({ uri: "/pages/menu" });
    }, 140); // 与按钮 press-up 动画对齐
},

    exit() { app.terminate(); },
    // --- 下载逻辑 (已重构并使用闭包管理周期性提示) ---
    initiateDownload() {
        // 1. 前置检查 (保持不变)
        if (typeof this.downloadedSongs !== 'object' || this.downloadedSongs === null) {
            prompt.showToast({ message: '下载列表未准备好，请稍后重试' });
            this.loadDownloadedSongs();
            return;
        }
        if (!this.currSong) { prompt.showToast({ message: '歌曲信息无效，无法下载' }); return; }
        if (this.downloadedSongs[this.currSong.id]) { prompt.showToast({ message: '歌曲已下载' }); return; }
        if (this.isDownloadingLocked) { prompt.showToast({ message: '已有任务在下载中' }); return; }

        // 2. 【【【核心】】】在方法作用域顶部声明一个变量，用于存储定时器ID
        let downloadToastTimer = null;

        // 3. 初始提示
        prompt.showToast({ message: `开始准备下载: ${this.currSong.name}` });

        // 4. 调用下载服务
        this.$app.$def.downloadService.start(
            this.currSong,
            { cookie: this.cookie, downloadBitrate: this.settings.audioQuality.download },
            {
                onStart: (song) => {
                    this.isDownloadingLocked = true;
                    this.songBeingDownloaded = { ...song };

                    // 【【【核心】】】创建定时器，并将其ID赋值给外部作用域的变量
                    downloadToastTimer = setInterval(() => {
                        if (this.songBeingDownloaded) {
                            prompt.showToast({ message: `下载中` ,duration: 500});
                        }
                    }, 3000);
                },
                
                onSuccess: async (downloadedInfo) => {
                    // ... (成功逻辑保持不变)
                    try {
                        const updatedSongs = { ...this.downloadedSongs, [downloadedInfo.id]: downloadedInfo };
                        await fileService.writeJson(CONSTANTS.FILE_DOWNLOADED_SONGS, updatedSongs);
                        this.downloadedSongs = updatedSongs;
                        prompt.showToast({ message: `${downloadedInfo.name} 下载并记录成功`, duration: 5000 });
                    } catch (error) {
                        console.error("写入下载记录失败:", error);
                        prompt.showToast({ message: `歌曲已下载，但保存记录失败: ${error.message}` });
                    }
                },
                
                onError: (errorMessage) => {
                    // ... (失败逻辑保持不变)
                    prompt.showToast({ message: `下载失败: ${errorMessage}` });
                },
                
                onFinish: () => {
                    // 【【【核心】】】
                    // onFinish 回调作为闭包，可以访问并清除在外部作用域中声明的 downloadToastTimer
                    if (downloadToastTimer) {
                        clearInterval(downloadToastTimer);
                        console.log("下载提示定时器已清除。");
                    }

                    this.isDownloadingLocked = false;
                    this.songBeingDownloaded = null;
                }
            }
        );
    },


    /**
     * 【核心修正】: startLogic 不再处理恢复逻辑，职责更单一
     */
     async startLogic() {
        // 【移除】所有与 wasRestored 相关的逻辑
        
        if (!this.songId) {
  await this.loadListFromFile();
  if (this.playList && this.playList.length > 0) {
    this.currentIndex = 0;

    // 没有正在播放歌曲：只加载第一首，不播放
    // 判定依据：没有 src 或者当前未处于播放态
    const noActivePlayback = !audio.src || !this.playerState.isPlaying;
    if (noActivePlayback) {
      this.loadCurrentOnly();
    } else {
      this.playCurrent();
    }
  } else {
    prompt.showToast({ message: "播放列表为空" });
  }
  return;
}


        await this.loadListFromFile();
        const index = this.playList.findIndex(item => item && String(item.id) === String(this.songId));
        
        if (index !== -1) {
            this.currentIndex = index;
        } else {
            if (this.songInfo && this.songInfo.id) {
                this.playList.unshift(this.songInfo);
                this.currentIndex = 0;
                await fileService.writeJson(CONSTANTS.FILE_PLAY_LIST, this.playList);
            } else {
                this.currentIndex = 0;
            }
        }

        if (this.playList.length > 0) {
            this.playCurrent();
        }
    },
    async playCurrent() {
        let songToPlay;
        if (this.isFmMode) {
            if (this.fmQueue.length === 0) {
                await this.fetchNextFmSongs();
                if (this.fmQueue.length === 0) { this.resetPlayer(); return; }
            }
            songToPlay = this.fmQueue[0];
        } else {
            if (!this.playList || this.playList.length === 0) { this.resetPlayer(); return; }
            songToPlay = this.playList[this.currentIndex];
        }
        if (!songToPlay) { this.handlePlaybackError("无效的歌曲数据"); return; }
        if (this.pendingSongId === songToPlay.id) return;
        this.pendingSongId = songToPlay.id;
        this.updateUiForNewSong(songToPlay);
        this.startPlaybackTimeout();
        if (this.isFmMode) this.fmQueue.shift();
        try {
            const downloadedInfo = this.downloadedSongs[songToPlay.id];
            if (downloadedInfo?.localUri) await this.playLocal(songToPlay, downloadedInfo);
            else await this.playOnline(songToPlay);
        } catch (error) { this.handlePlaybackError(error.message || "播放准备失败"); }
    },
    loadCurrentOnly() {
  // 仅设置当前歌曲与UI，不触发播放
  let songToLoad = null;

  if (this.isFmMode) {
    // FM 模式没有“列表第一首不播放”的意义；这里按你需求做保护
    if (!this.fmQueue || this.fmQueue.length === 0) return;
    songToLoad = this.fmQueue[0];
  } else {
    if (!this.playList || this.playList.length === 0) return;
    songToLoad = this.playList[this.currentIndex] || this.playList[0];
    if (!songToLoad) return;
    // 兜底：如果 currentIndex 越界
    this.currentIndex = this.playList.findIndex(s => s && s.id === songToLoad.id);
    if (this.currentIndex < 0) this.currentIndex = 0;
  }

  // 清理播放相关状态，但保留 UI
  audio.stop();
  this.pendingSongId = null;
  if (this.playTimeoutId) { clearTimeout(this.playTimeoutId); this.playTimeoutId = null; }

  // 关键：只更新 UI，不 startPlayback
  this.updateUiForNewSong(songToLoad);

  // 明确状态为未播放
  this.playerState.isPlaying = false;
  this.playerState.playDuration = 0;

  // 注意：updateUiForNewSong 里已经 fetchLyric 了
},

updateUiForNewSong(song) {
    audio.stop();

    if (!this.currSong) this.currSong = { ...song, duration: 0 };
    else {
      this.currSong.id = song.id;
      this.currSong.name = song.name;
      this.currSong.artists = song.artists;
      this.currSong.duration = 0;
    }

    // 【关键】只有在“不是恢复播放”的情况下，才清零进度
    if (this.resumeTime < 0) {
      this.playerState.playDuration = 0;
    }

    this.resetLyrics();
    this.fetchLyric(song.id);
  },
    startPlaybackTimeout() {
        if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
        this.playTimeoutId = setTimeout(() => {
            console.error("!!! PLAYBACK TIMEOUT !!!");
            prompt.showToast({ message: '播放超时，请重试' });
            this.pendingSongId = null; this.playTimeoutId = null; this.resetPlayer();
        }, CONSTANTS.PLAY_TIMEOUT);
    },
    async playLocal(song, downloadedInfo) {
        return new Promise((resolve, reject) => {
            file.access({
                uri: downloadedInfo.localUri,
                success: () => { this.startPlayback({ ...song, ...downloadedInfo }, downloadedInfo.localUri); this.fetchLyric(song.id); resolve(); },
                fail: () => { prompt.showToast({ message: '本地文件失效，转为在线播放' }); this.playOnline(song).then(resolve).catch(reject); }
            });
        });
    },
    async playOnline(song) {
    this.isEnding = false;
    try {
        const songInfo = await apiService.getSongPlaybackInfo(song.id, this.settings.audioQuality.online, this.cookie);
        const fullSongInfo = { ...song, playUrl: songInfo.url, duration: songInfo.duration };
        this.startPlayback(fullSongInfo, songInfo.url);
    } catch (error) {
        console.error("playOnline 失败:", error);
        throw error;
    }
},
startPlayback(songWithDuration, src) {
    if (!src || typeof src !== 'string') {
        this.handlePlaybackError("无效的播放源");
        return;
    }

    if (this.currSong && songWithDuration && songWithDuration.duration) {
        this.currSong.duration = songWithDuration.duration;
    }

    this.retryCount = 0;

    // 启动前 stop 没问题
    audio.stop();
    audio.src = src;

    // 如果存在待恢复时间：进入恢复期（屏蔽 timeupdate/slider 的抢写）
    if (typeof this._pendingRestoreTime === 'number' && this._pendingRestoreTime > 0) {
        this._restoreSeeking = true;
        const now = Date.now();
        this._ignoreTimeupdateUntilTs = now + 2500; // 覆盖启动阶段的 timeupdate=0
        this._ignoreSliderUntilTs = now + 2500;     // 覆盖启动阶段 slider 回写
    }

    audio.play();
},

seekOnce(t) {
    const target0 = Number(t) || 0;
    if (target0 <= 0) {
        this._restoreSeeking = false;
        return;
    }

    // 恢复期：先锁住
    this._restoreSeeking = true;

    const armIgnoreWindows = (ms) => {
        const now = Date.now();
        this._ignoreTimeupdateUntilTs = Math.max(this._ignoreTimeupdateUntilTs || 0, now + ms);
        this._ignoreSliderUntilTs = Math.max(this._ignoreSliderUntilTs || 0, now + ms);
    };

    armIgnoreWindows(1800);

    let tries = 0;
    const maxTries = 10;

    const finish = () => {
        // 延迟释放：避免 seek 后立刻 timeupdate=0 或 slider 回写造成闪动
        setTimeout(() => {
            this._restoreSeeking = false;
            armIgnoreWindows(400);
        }, 600);
    };

    const attempt = () => {
        tries++;
        audio.getPlayState({
            success: (st) => {
                const dur = st && typeof st.duration === 'number' ? st.duration : 0;
                const ok = st && (st.state === 'play' || st.state === 'pause');

                if (ok && dur > 0) {
                    const target = Math.max(0, Math.min(target0, dur - 0.2));

                    // 如果已经非常接近，就不重复 seek
                    const cur = Number(audio.currentTime) || 0;
                    if (Math.abs(cur - target) > 0.25) {
                        audio.currentTime = target;
                    }

                    // UI 固定到目标值（不等 timeupdate）
                    this.playerState.playDuration = target;
                    this.updateLyric();

                    finish();
                    return;
                }

                if (tries < maxTries) setTimeout(attempt, 120);
                else finish();
            },
            fail: () => {
                if (tries < maxTries) setTimeout(attempt, 120);
                else finish();
            }
        });
    };

    attempt();
},

    change(dir) {
        if (this.pendingSongId) { prompt.showToast({ message: '正在切歌...' }); return; }
        if (this.isFmMode) { if (dir < 0) { prompt.showToast({ message: '私人FM不支持上一首哦' }); return; } this.playCurrent(); return; }
        if (!this.playList || this.playList.length === 0) return;
        switch (this.playMode) {
            case 0: case 1: this.currentIndex = (this.currentIndex + dir + this.playList.length) % this.playList.length; break;
            case 2:
                if (!this.shuffledPlayList || this.shuffledPlayList.length !== this.playList.length) this.generateShuffledList(false);
                this.shuffledIndex = (this.shuffledIndex + dir + this.shuffledPlayList.length) % this.shuffledPlayList.length;
                this.currentIndex = this.shuffledPlayList[this.shuffledIndex];
                break;
        }
        this.playCurrent();
    },

    generateShuffledList(locateCurrent = true) {
        console.log("生成新的随机播放列表...");
        this.shuffledPlayList = Array.from(this.playList.keys());
        
        for (let i = this.shuffledPlayList.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.shuffledPlayList[i], this.shuffledPlayList[j]] = [this.shuffledPlayList[j], this.shuffledPlayList[i]];
        }

        if (locateCurrent) {
            const currentShuffledIndex = this.shuffledPlayList.indexOf(this.currentIndex);
            this.shuffledIndex = (currentShuffledIndex !== -1) ? currentShuffledIndex : 0;
        }
        console.log("随机列表已生成, 当前随机索引:", this.shuffledIndex);
    },

    // --- FM 模式逻辑 (已重构) ---
    async dostartFmMode(initialSongId = null, initialSongInfo = null) {
        if (this.isFetchingFm) return;

        this.isFmMode = true;
        this.isFetchingFm = true;
        this.playList = [];
        this.fmQueue = [];
        audio.stop();
        prompt.showToast({ message: '正在开启私人FM...' });

        if (initialSongId && initialSongInfo) {
            try { this.fmQueue.push(JSON.parse(initialSongInfo)); }
            catch(e) { console.error("解析FM初始歌曲信息失败"); }
        }

        try {
            await this.fetchNextFmSongs();
            if (this.fmQueue.length > 0) this.playCurrent();
            else { prompt.showToast({ message: '无法获取FM歌曲，请检查网络' }); this.isFmMode = false; }
        } catch (error) {
            prompt.showToast({ message: '启动FM失败' });
            this.isFmMode = false;
        } finally {
            this.isFetchingFm = false;
        }
    },
    async fetchNextFmSongs() {
        if (this.isFetchingFm) return;
        this.isFetchingFm = true;
        console.log("正在获取新的FM歌曲...");
        try {
            const newSongs = await apiService.getPersonalFmSongs(this.cookie);
            if (newSongs.length > 0) {
                this.fmQueue.push(...newSongs);
                console.log(`成功获取 ${newSongs.length} 首FM歌曲，当前队列长度: ${this.fmQueue.length}`);
            } else {
                prompt.showToast({ message: '没有更多FM推荐了' });
            }
        } catch (error) {
            console.error("获取FM歌曲失败:", error);
            prompt.showToast({ message: '获取新歌失败' });
        } finally {
            this.isFetchingFm = false;
        }
    },

// 【【【进阶优化：更可靠的缓存检查】】】
fetchLyric(songId) {
    this.resetLyrics();
    const lyricFilePath = `${CONSTANTS.DIR_LYRICS}${songId}.json`;
    const downloadedInfo = this.downloadedSongs[songId];

    // 优先使用下载记录中的路径（如果有）
    const finalLyricPath = downloadedInfo?.localLyricUri || lyricFilePath;

    // 直接检查文件是否存在
    file.access({
        uri: finalLyricPath,
        success: () => {
            // 文件存在，直接从本地加载
            console.log(`发现本地歌词缓存: ${finalLyricPath}`);
            this.loadLyricFromFile(finalLyricPath, songId);
        },
        fail: () => {
            // 文件不存在，从在线获取（并会自动缓存）
            console.log(`本地无歌词缓存，从网络获取: ${songId}`);
            this.fetchLyricOnline(songId);
        }
    });
},

    loadLyricFromFile(uri, songId) {
        file.readText({
            uri: uri,
            success: (data) => { try { this.processAndMergeLyrics(JSON.parse(data.text)); } catch (e) { this.fetchLyricOnline(songId); } },
            fail: () => this.fetchLyricOnline(songId)
        });
    },
// 【【【核心修改：播放在线歌曲时也缓存歌词】】】
async fetchLyricOnline(songId) {
    const lyricFilePath = `${CONSTANTS.DIR_LYRICS}${songId}.json`;

    try {
        // 1. 从网络获取歌词数据
        const lyricData = await apiService.getLyricData(songId, this.cookie);

        // 2. 异步将歌词数据写入本地文件进行缓存
        //    我们不需要等待它完成，可以立即尝试从本地加载。
        //    使用 fileService 封装的方法，它内部处理了 Promise。
        fileService.writeJson(lyricFilePath, lyricData)
            .then(() => {
                console.log(`歌词缓存成功: ${songId}.json`);
            })
            .catch(err => {
                console.error(`歌词文件写入失败: ${err.message}`);
            });

        // 3. 立即使用刚获取的数据渲染歌词，保证首次播放的体验
        this.processAndMergeLyrics(lyricData);

    } catch (error) {
        // 如果网络请求失败，则显示加载失败
        console.error("在线获取歌词失败:", error);
        this.lyrics = [{ time: 0, text: '歌词加载失败' }];
        // 清空可能存在的旧的、不完整的渲染数据
        this.processAndMergeLyrics(null);
    }
},

    parseLyric(lrcString) {
        const lines = lrcString.split('\n'), result = [], timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
            const match = timeRegex.exec(line);
            if (match) {
                const time = parseInt(match[1]) * 60 + parseInt(match[2]) + parseInt(match[3].padEnd(3, '0')) / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) result.push({ time, text });
            }
        }
        return result;
    },
    mergeLyrics(original, translation, romaji) {
        const createMap = (arr) => new Map(arr.map(item => [item.time.toFixed(3), item.text]));
        if (romaji && translation) {
            this.playerState.lyricType = 'japanese';
            const transMap = createMap(translation), romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)), romaji: romaMap.get(line.time.toFixed(3)) }));
        } 
        else if (romaji && !translation) {
            this.playerState.lyricType = 'cantonese';
            const romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, romaji: romaMap.get(line.time.toFixed(3)) }));
        }
        else if (translation) {
            this.playerState.lyricType = 'english';
            const transMap = createMap(translation);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)) }));
        } else {
            this.playerState.lyricType = 'chinese';
            this.lyrics = original.map(line => ({ time: line.time, original: line.text }));
        }
        if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: '暂无歌词' }];
    },
    getExtraLyricText(lineData) {
        if (!lineData) return '';
        let extraText = '';
        const lyricSettings = this.settings.lyrics || {};
        switch (this.playerState.lyricType) {
            case 'japanese':
                if (lyricSettings.japaneseMode === 'translation') extraText = lineData.translation || '';
                else if (lyricSettings.japaneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'cantonese':
                if (lyricSettings.cantoneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'english':
                if (lyricSettings.englishMode === 'translation') extraText = lineData.translation || '';
                break;
        }
        return extraText;
    },

    /**
     * 【【【核心重构】】】
     * 滚动到当前歌词，优化DOM查询
     * @param {boolean} isInitial - 是否是初次进入页面
     */
    scrollToCurrentLyric(isInitial = false) {
        if (this.swiperCurrentIndex !== 1 || !this._lyricsScrollView || this.playerState.currentLyricIndex < 0) {
            return;
        }

        const lineElement = this.$element(`lyric-line-${this.playerState.currentLyricIndex}`);
        if (!lineElement) return;

        // 使用回调链避免竞态
        this._lyricsScrollView.getBoundingClientRect({
            success: (scrollRect) => {
                lineElement.getBoundingClientRect({
                    success: (lineRect) => {
                        const targetCenterY = scrollRect.height * 0.4;
                        const lineTopInContainer = lineRect.top - scrollRect.top;
                        const scrollOffset = (lineTopInContainer + lineRect.height / 2) - targetCenterY;
                        
                        this._lyricsScrollView.scrollBy({ 
                            top: scrollOffset, 
                            // 初次进入时无动画，后续切换有动画
                            behavior: isInitial ? 'instant' : 'smooth' 
                        });
                    }
                });
            }
        });
    },
    
    bindAudioEvents() {
    // onplay：同步状态 + 如有 pending restore time，则在此处触发一次 seekOnce
    audio.onplay = () => {
        // 同步播放态
        if (!this.playerState.isPlaying) {
            this.playerState.isPlaying = true;
        }

        // 清超时等待
        if (this.playTimeoutId) {
            clearTimeout(this.playTimeoutId);
            this.playTimeoutId = null;
        }
        this.pendingSongId = null;

        // 如果需要恢复进度：只在这里做一次
        if (typeof this._pendingRestoreTime === 'number' && this._pendingRestoreTime > 0) {
            const t = this._pendingRestoreTime;
            this._pendingRestoreTime = null; // 确保只做一次
            this.seekOnce(t);
        }

        console.log("Event: onplay (synced).");
    };

    // ontimeupdate：恢复期禁止写入 0，避免 UI 00:00 闪一下
    audio.ontimeupdate = () => {
        // 等待切歌阶段不更新（你原逻辑保留）
        if (this.pendingSongId) return;

        // 恢复期 / 屏蔽窗口：不更新 UI，不跑歌词（关键）
        const now = Date.now();
        if (this._restoreSeeking) return;
        if (this._ignoreTimeupdateUntilTs && now < this._ignoreTimeupdateUntilTs) return;

        this.playerState.playDuration = audio.currentTime;
        this.updateLyric();
    };

  // 暂停事件：只做状态同步，不要再 audio.pause()
  audio.onpause = () => {
    this.playerState.isPlaying = false;
    console.log("Event: onpause (synced).");
  };

  audio.onstop = () => {
    this.playerState.isPlaying = false;

    if (this.playTimeoutId) {
      clearTimeout(this.playTimeoutId);
      this.playTimeoutId = null;
    }
    this.pendingSongId = null;
    console.log("Event: onstop.");
  };

  audio.onended = () => {
    console.log(`Event: onended. t=${audio.currentTime}, dur=${audio.duration}`);
    const diff = Math.abs((audio.duration || 0) - (audio.currentTime || 0));
    if ((audio.duration || 0) > 0 && diff > 2) {
      console.error("Warning: onended early trigger suspected.");
    }

    if (this.playMode === 1) this.playCurrent();
    else this.change(1);
  };

  // 系统/耳机控制：这些是“外部请求”，由我们执行动作
  audio.onctrlplayprev = () => {
    prompt.showToast({ message: '上一首' });
    this.change(-1);
  };

  audio.onctrlplaynext = () => {
    prompt.showToast({ message: '下一首' });
    this.change(1);
  };

  audio.onctrlvolumeup = () => {
    audio.getPlayState({
      success: (state) => {
        const v = typeof state.volume === 'number' ? state.volume : 0.5;
        const newV = v > 0.9 ? 1 : v + 0.1;
        audio.volume = newV;
        prompt.showToast({ message: `音量: ${Math.round(newV * 100)}%` });
      },
      fail: (data, code) => console.error(`[ctrl] getPlayState failed: code=${code}`)
    });
  };

  audio.onctrlvolumedown = () => {
    audio.getPlayState({
      success: (state) => {
        const v = typeof state.volume === 'number' ? state.volume : 0.5;
        const newV = v < 0.1 ? 0 : v - 0.1;
        audio.volume = newV;
        prompt.showToast({ message: `音量: ${Math.round(newV * 100)}%` });
      },
      fail: (data, code) => console.error(`[ctrl] getPlayState failed: code=${code}`)
    });
  };
},


    // --- 数据加载与重置 ---
    async loadSettings() {
        try {
            const data = await fileService.readJson(CONSTANTS.SETTINGS_FILE_URI);
            if (data) {
                // 【【【修改】】】确保 gestures 能被正确合并
                this.settings = { 
                    ...this.settings, 
                    ...data, 
                    lyrics: { ...this.settings.lyrics, ...(data.lyrics || {}) }, 
                    audioQuality: { ...this.settings.audioQuality, ...(data.audioQuality || {}) },
                    gestures: { ...this.settings.gestures, ...(data.gestures || {}) } // 新增合并
                };
                console.log("播放器设置加载成功，手势配置:", this.settings.gestures);
            }
        } catch (e) { console.log("无法加载播放器设置，使用默认值。"); }
    },
    async loadCookie() {
        try {
            let rawText;
            try { rawText = (await fileService._promisify(file.readText, { uri: CONSTANTS.COOKIE_FILE_URI })).text; }
            catch(e) { rawText = null; }
            this.cookie = rawText || null;
            if (this.cookie) console.log("Cookie 加载成功。");
        } catch (e) { this.cookie = null; }
    },
    async loadListFromFile() { this.playList = await fileService.readJson(CONSTANTS.FILE_PLAY_LIST, []); },
    async loadDownloadedSongs() { this.downloadedSongs = await fileService.readJson(CONSTANTS.FILE_DOWNLOADED_SONGS, {}); },
    resetPlayer() {
        audio.stop();
        this.currSong = null;
        this.playerState.isPlaying = false;
        this.playerState.playDuration = 0;
        this.isChangingSong = false;
        this.retryCount = 0;
        this.resetLyrics();
    },

    // --- 错误处理 ---
    handlePlaybackError(message) {
        if (this.playTimeoutId) { clearTimeout(this.playTimeoutId); this.playTimeoutId = null; }
        this.pendingSongId = null;
        this.retryCount++;
        prompt.showToast({ message: `${message} (尝试第 ${this.retryCount} 次)` });
        if (this.retryCount >= CONSTANTS.MAX_PLAYBACK_RETRIES) {
            prompt.showToast({ message: `多次尝试失败，已停止播放`, duration: 5000 });
            this.resetPlayer();
            return;
        }
        setTimeout(() => { this.change(1); }, 1500 + (this.retryCount * 1000));
    },

    // --- 工具函数 ---
    second2time(second) {
        if (isNaN(second) || second < 0) return "00:00";
        const sec = Math.floor(second % 60).toString().padStart(2, "0");
        const min = Math.floor(second / 60).toString().padStart(2, "0");
        return `${min}:${sec}`;
    },
};
</script>
