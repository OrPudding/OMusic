<template>
	<div class="demo-page">
		<!-- 歌曲信息 -->
		<div class="song">
			<marquee class="song-name" scrollamount="36">
				{{ songName }}
			</marquee>
			<marquee class="singer-name" scrollamount="36">
				{{ songArtists }}
			</marquee>
		</div>

		<!-- 播放控制按钮 (未展开时显示) -->
		<div class="controls" if="{{ !expend }}">
			<image class="icon" src="/common/icon/prev.png" onclick="change(-1)" />
			<image
				class="icon"
				src="{{ playButtonIcon }}"
				onclick="playOrPause"
			/>
			<image class="icon" src="/common/icon/next.png" onclick="change(1)" />
		</div>

        <!-- 歌词容器 -->
        <div class="{{ expend ? 'lyrics-container-expended' : 'lyrics-container' }}" onclick="toggleLyricExpend">
            <!-- 使用 for 循环动态渲染歌词行，代码更简洁 -->
            <text
                for="{{ line in visibleLyrics }}"
                class="{{ line.className }}"
            >
                {{ line.text }}
            </text>
        </div>

		<!-- 播放进度 (未展开时显示) -->
		<div class="progress" if="{{ !expend }}">
			<text class="play-time">{{ progressText }}</text>
<slider
    class="play-progress"
    min="0"
    max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}"
    step="1"
    value="{{ playerState.playDuration }}"
    onchange="onSliderChange"
></slider>

		</div>

		<!-- 底部操作 (未展开时显示) -->
		<div class="footer" if="{{ !expend }}">
			<image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions" />
			<image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu" />
		</div>
	</div>
</template>
<script>
import router from "@system.router";
import fetch from "@system.fetch";
import audio from "@system.audio";
import file from "@system.file";
import prompt from '@system.prompt';

// --- 1. 常量定义 ---
const CONSTANTS = {
    API_SONG_URL: 'https://163api.qijieya.cn/song/url?br=320000&id=',
    API_LYRIC_URL: 'https://163api.qijieya.cn/lyric?id=',
    DIR_MUSIC: 'internal://files/music/',
    DIR_LYRICS: 'internal://files/lyrics/',
    FILE_PLAY_LIST: 'internal://files/play_list.json',
    FILE_DOWNLOADED_SONGS: 'internal://files/downloaded_songs.json',
    SETTINGS_FILE_URI: 'internal://files/settings.json',
    COOKIE_FILE_URI: 'internal://files/cookie.txt',
};

export default {
    private: {
        playerState: { isPlaying: false, playDuration: 0, currentLyricIndex: 0, lyricType: 'chinese' },
        currSong: null,
        lyrics: [],
        expend: false,
        downloadedSongs: {},
        settings: { lyrics: { japaneseMode: 'translation', englishMode: 'translation' } },
        cookie: null,
    },

    protected: {
        playList: [],
        currentIndex: 0,
        songId: null,
    },

    computed: {
        songName( ) {
            return this.currSong ? this.currSong.name : "未知歌曲";
        },
        songArtists() {
            return this.currSong ? this.currSong.artists : "未知艺术家";
        },
        playButtonIcon() {
            return this.playerState.isPlaying ? '/common/icon/pause.png' : '/common/icon/play.png';
        },
        progressText() {
            const duration = this.currSong?.duration || 0;
            return `${this.second2time(this.playerState.playDuration)}/${this.second2time(duration)}`;
        },
        visibleLyrics() {
            if (!this.lyrics || this.lyrics.length === 0) {
                return [{ text: this.expend ? '暂无歌词' : '', className: 'lyric-line current-lyric' }];
            }
            const lines = [];
            const offsets = this.expend ? [-2, -1, 0, 1, 2, 3, 4] : [-1, 0, 1];
            for (const offset of offsets) {
                const index = this.playerState.currentLyricIndex + offset;
                if (index >= 0 && index < this.lyrics.length) {
                    const lineData = this.lyrics[index];
                    const isCurrent = offset === 0;
                    lines.push({
                        text: lineData.original || lineData.text || '',
                        className: `lyric-line ${isCurrent ? 'current-lyric' : 'secondary-lyric'}`
                    });
                    if (isCurrent) {
                        let extraText = '';
                        if (this.playerState.lyricType === 'japanese') {
                            switch (this.settings.lyrics.japaneseMode) {
                                case 'translation': extraText = lineData.translation || ''; break;
                                case 'romaji': extraText = lineData.romaji || ''; break;
                            }
                        } else if (this.playerState.lyricType === 'english') {
                            if (this.settings.lyrics.englishMode === 'translation') {
                                extraText = lineData.translation || '';
                            }
                        }
                        if (extraText) {
                            lines.push({ text: extraText, className: 'lyric-line extra-lyric' });
                        }
                    }
                }
            }
            return lines;
        }
    },

    async onInit() {
        if (this.playList && typeof this.playList === 'string') {
            try { this.playList = JSON.parse(this.playList); } catch (e) { this.playList = []; }
        }
        
        await this.loadSettings();
        await this.loadCookie();
        
        if (!this.playList || this.playList.length === 0) {
            await this.loadListFromFile();
        }
        
        await this.loadDownloadedSongs();
        
        this.bindAudioEvents();
    },

    onReady() {
        if (!this.playList || this.playList.length === 0) {
            prompt.showToast({ message: '播放列表为空' });
            return;
        }
        let startIndex = 0;
        if (this.songId) {
            const index = this.playList.findIndex(item => item && item.id == this.songId);
            if (index !== -1) {
                startIndex = index;
            } else {
                prompt.showToast({ message: '找不到指定歌曲，已为您播放第一首' });
            }
        }
        this.currentIndex = startIndex;
        this.playCurrent();
    },
    
    async onShow() {
        await this.loadSettings();
        await this.loadCookie();
        await this.loadListFromFile();
        await this.loadDownloadedSongs();
    },

    async loadSettings() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: CONSTANTS.SETTINGS_FILE_URI, success: resolve, fail: reject }));
            const loadedSettings = JSON.parse(data.text);
            this.settings = { ...this.settings, ...loadedSettings, lyrics: { ...this.settings.lyrics, ...(loadedSettings.lyrics || {}) } };
        } catch (e) {
            console.log("无法加载播放器设置，使用默认值。");
        }
    },

    async loadCookie() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: CONSTANTS.COOKIE_FILE_URI, success: resolve, fail: reject }));
            this.cookie = (data && data.text) ? data.text : null;
        } catch (e) {
            this.cookie = null;
        }
    },

    playCurrent() {
        if (!this.playList || this.playList.length === 0) {
            this.resetPlayer();
            return;
        }
        const song = this.playList[this.currentIndex];
        if (!song) {
            this.handlePlaybackError("无效的歌曲数据");
            return;
        }
        const downloadedInfo = this.downloadedSongs[song.id];
        if (downloadedInfo?.localUri) {
            this.playLocal(song, downloadedInfo);
        } else {
            this.playOnline(song);
        }
    },

    playLocal(song, downloadedInfo) {
        file.access({
            uri: downloadedInfo.localUri,
            success: () => {
                this.startPlayback({ ...song, ...downloadedInfo }, downloadedInfo.localUri);
                this.fetchLyric(song.id);
            },
            fail: () => {
                prompt.showToast({ message: '本地文件失效，转为在线播放' });
                this.playOnline(song);
            }
        });
    },

    async playOnline(song) {
        try {
            let headers = {};
            if (this.cookie) {
                headers['Cookie'] = this.cookie;
            }

            const response = await new Promise((resolve, reject) => {
                fetch.fetch({
                    url: `${CONSTANTS.API_SONG_URL}${song.id}`,
                    header: headers,
                    responseType: 'text',
                    success: resolve,
                    fail: (data, code) => reject({ data, code }),
                });
            });

            const songData = JSON.parse(response.data)?.data?.[0];
            if (songData?.url) {
                const songInfo = { ...song, playUrl: songData.url, duration: Math.floor(songData.time / 1000) };
                this.startPlayback(songInfo, songData.url);
                this.fetchLyricOnline(song.id);
            } else {
                this.handlePlaybackError('获取播放链接失败');
            }

        } catch (error) {
            console.error("playOnline 失败:", error);
            this.handlePlaybackError('网络请求失败');
        }
    },

    startPlayback(song, src) {
        this.currSong = song;
        audio.stop();
        audio.src = src;
        audio.play();
    },

    playOrPause() {
        if (!this.currSong) return;
        this.playerState.isPlaying ? audio.pause() : audio.play();
    },

    change(dir) {
        if (!this.playList || this.playList.length === 0) return;
        const newIndex = (this.currentIndex + dir + this.playList.length) % this.playList.length;
        this.currentIndex = newIndex;
        this.playCurrent();
    },

    onSliderChange(e) {
        audio.currentTime = e.progress;
        this.updateLyric();
    },

    toggleLyricExpend() {
        this.expend = !this.expend;
    },

    goToSongActions() {
        if (!this.currSong) {
            prompt.showToast({ message: '当前无播放歌曲' });
            return;
        }
        router.push({
            uri: "/pages/volume",
            params: { currentSong: JSON.stringify(this.currSong) }
        });
    },

    goToMenu() {
        router.push({ uri: "/pages/menu" });
    },

    fetchLyric(songId) {
        this.resetLyrics();
        const downloadedInfo = this.downloadedSongs[songId];
        if (downloadedInfo?.localLyricUri) {
            this.loadLyricFromFile(downloadedInfo.localLyricUri, songId);
        } else {
            this.fetchLyricOnline(songId);
        }
    },

    loadLyricFromFile(uri, songId) {
        file.readText({
            uri: uri,
            success: (data) => {
                try { this.processAndMergeLyrics(JSON.parse(data.text)); } catch (e) { this.fetchLyricOnline(songId); }
            },
            fail: () => this.fetchLyricOnline(songId)
        });
    },

    async fetchLyricOnline(songId) {
        try {
            let headers = {};
            if (this.cookie) {
                headers['Cookie'] = this.cookie;
            }

            const response = await new Promise((resolve, reject) => {
                fetch.fetch({
                    url: `${CONSTANTS.API_LYRIC_URL}${songId}`,
                    header: headers,
                    responseType: 'text',
                    success: resolve,
                    fail: (data, code) => reject({ data, code }),
                });
            });
            
            this.processAndMergeLyrics(JSON.parse(response.data));

        } catch (error) {
            this.lyrics = [{ time: 0, text: '歌词加载失败' }];
        }
    },

    processAndMergeLyrics(data) {
        if (!data?.lrc?.lyric) {
            this.lyrics = [{ time: 0, text: '暂无歌词' }];
            return;
        }
        const original = this.parseLyric(data.lrc.lyric);
        const translation = data.tlyric?.lyric ? this.parseLyric(data.tlyric.lyric) : null;
        const romaji = data.romalrc?.lyric ? this.parseLyric(data.romalrc.lyric) : null;
        this.mergeLyrics(original, translation, romaji);
    },

    parseLyric(lrcString) {
        const lines = lrcString.split('\n');
        const result = [];
        const timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
            const match = timeRegex.exec(line);
            if (match) {
                const time = parseInt(match[1]) * 60 + parseInt(match[2]) + parseInt(match[3].padEnd(3, '0')) / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) result.push({ time, text });
            }
        }
        return result;
    },

    mergeLyrics(original, translation, romaji) {
        const createMap = (arr) => new Map(arr.map(item => [item.time.toFixed(3), item.text]));
        if (romaji && translation) {
            this.playerState.lyricType = 'japanese';
            const transMap = createMap(translation);
            const romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)), romaji: romaMap.get(line.time.toFixed(3)) }));
        } else if (translation) {
            this.playerState.lyricType = 'english';
            const transMap = createMap(translation);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)) }));
        } else {
            this.playerState.lyricType = 'chinese';
            this.lyrics = original.map(line => ({ time: line.time, original: line.text }));
        }
        if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: '暂无歌词' }];
    },

    updateLyric() {
        if (!this.lyrics || this.lyrics.length === 0) return;
        const currentTime = this.playerState.playDuration;
        let newIndex = this.lyrics.findIndex(line => line.time > currentTime);
        if (newIndex === -1) newIndex = this.lyrics.length;
        const finalIndex = Math.max(0, newIndex - 1);
        if (finalIndex !== this.playerState.currentLyricIndex) {
            this.playerState.currentLyricIndex = finalIndex;
        }
    },

    bindAudioEvents() {
        audio.onplay = () => { this.playerState.isPlaying = true; };
        audio.onpause = () => { this.playerState.isPlaying = false; };
        audio.onstop = () => { this.playerState.isPlaying = false; };
        audio.ontimeupdate = () => {
            this.playerState.playDuration = audio.currentTime;
            this.updateLyric();
        };
        audio.onended = () => { this.change(1); };
    },

    async loadListFromFile() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: CONSTANTS.FILE_PLAY_LIST, success: resolve, fail: reject }));
            this.playList = JSON.parse(data.text || '[]');
        } catch (e) { this.playList = []; }
    },

    async loadDownloadedSongs() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: CONSTANTS.FILE_DOWNLOADED_SONGS, success: resolve, fail: reject }));
            this.downloadedSongs = JSON.parse(data.text || '{}');
        } catch (e) { this.downloadedSongs = {}; }
    },

    resetPlayer() {
        audio.stop();
        this.currSong = null;
        this.playerState.isPlaying = false;
        this.playerState.playDuration = 0;
        this.resetLyrics();
    },

    resetLyrics() {
        this.lyrics = [];
        this.playerState.currentLyricIndex = 0;
    },

    handlePlaybackError(message) {
        prompt.showToast({ message });
        setTimeout(() => this.change(1), 1500);
    },

    second2time(second) {
        if (isNaN(second) || second < 0) return "00:00";
        const sec = Math.floor(second % 60).toString().padStart(2, "0");
        const min = Math.floor(second / 60).toString().padStart(2, "0");
        return `${min}:${sec}`;
    },
};
</script>

<style>
.demo-page {
	width: 466px;
	height: 466px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
	background-color: #000;
}

.play-button {
	width: 200px;
}

/* <style> */
/* ... 已有样式 ... */

.lyrics-container {
  width: 100%;
  height: 100px;
  flex-direction: column;
  justify-content: center;
  align-items: center;
}

.lyrics-container-expended {
  width: 100%;
  height: 308px; /* 扩展高度以显示更多歌词 */
  flex-direction: column;
  justify-content: center;
  align-items: center;
}


.lyric-line {
  width: 100%;
  text-align: center;
  lines: 1; /* 允许最多显示两行，以防文本过长 */
  text-overflow: ellipsis;
}

.secondary-lyric {
  font-size: 22px;
  color: rgba(255, 255, 255, 0.5);
  height: 35px; /* 预留空间 */
}

.current-lyric-wrapper {
  flex-direction: column;
  align-items: center;
  margin: 2px 0;
}

.current-lyric {
  font-size: 26px;
  color: #3ae1ff; /* 高亮颜色 */
  font-weight: bold;
}

.extra-lyric {
  font-size: 24px;
  color: rgba(255, 255, 255, 0.8);
}


.progress {
	height: 60px;
	width: 320px;
	flex-direction: column;
	align-items: center;
}

.play-time {
	text-align: left;
	color: #ffffff;
	font-size: 22px;
	margin: 5px;
}

.play-progress {
	/* 添加 slider 特有的样式 */
	selected-color: #3ae1ff;
	block-color: #ffffff;
	padding-left: 0px;
	padding-right: 0px;
	margin: 0 20px;
}

.song {
	width: 320px;
	height: 100px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

.song-name {
	width: 320px;
	font-size: 32px;
	color: #ffffff;
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
}

.singer-name {
	width: 300px;
	font-size: 24px;
	color: rgba(255, 255, 255, 0.8);
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
}

.controls {
	width: 360px;
	justify-content: space-between;
	align-items: center;
}

.icon {
	width: 80px;
	height: 80px;
}

.footer-icon {
  width: 64px;
  height: 64px;
}



.footer {
	height: 80px;
	width: 320px;
	justify-content: space-around;
	align-items: center;
}
</style>
