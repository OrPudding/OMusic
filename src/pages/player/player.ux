<template>
	<div class="demo-page">
		<!-- 1. 歌曲信息 (保持在顶部) -->
		<div class="song">
			<marquee class="song-name" scrollamount="36" onclick="exit">{{ songName }}</marquee>
			<marquee class="singer-name" scrollamount="36">{{ songArtists }}</marquee>
		</div>
        
        <!-- 2. 核心内容区域 -> Swiper (现在是主要容器) -->
        <swiper 
            class="content-swiper" 
            indicator="true" 
            loop="false" 
            onchange="onSwiperChange"
            id="contentSwiper"
        >
            <!-- 视图 0: 播放器主界面 -->
            <div class="swiper-item player-view">
                <!-- a. 播放控制按钮 -->
                <div class="controls">
                    <image class="icon" src="/common/icon/prev.png" onclick="change(-1)" />
                    <image class="icon" src="{{ playButtonIcon }}" onclick="playOrPause" />
                    <image class="icon" src="/common/icon/next.png" onclick="change(1)" />
                </div>
                <!-- b. 播放进度条 -->
                <div class="progress">
                    <text class="play-time">{{ progressText }}</text>
                    <slider class="play-progress" min="0" max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}" step="1" value="{{ playerState.playDuration }}" onchange="onSliderChange"></slider>
                </div>
                <!-- c. 底部操作栏 -->
                <div class="footer">
                    <div class="footer-content-rect" if="{{ screenShape === 'rect' }}">
                        <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                        <image class="footer-icon" src="{{ downloadIcon }}" onclick="initiateDownload"></image>
                        <image class="footer-icon" src="{{ playModeIcon }}" onclick="togglePlayMode"></image>
                        <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
                    </div>
                    <div class="footer-content-circle" else>
                        <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                        <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
                    </div>
                </div>
            </div>

<!-- 视图 1: 歌词 -->
<!-- 视图 1: 歌词 -->
<div class="swiper-item">
    <scroll id="lyricsScrollView" class="lyrics-scroll-view" scroll-y="true">
        <div class="lyrics-list-padding-top"></div>
        
        <!-- 保持此结构以支持未来的歌词特性 -->
        <div
            for="{{(index, line) in fullVisibleLyrics}}"
            tid="line.id" 
            id="lyric-line-{{ index }}"
            class="lyric-line-wrapper {{ line.isCurrent ? 'is-current-wrapper' : '' }}"
        >
            <text class="lyric-line {{ line.isCurrent ? 'current-lyric' : 'secondary-lyric' }}">
                {{ line.original }}
            </text>
            <text if="{{ line.isCurrent && line.extra }}" class="lyric-line extra-lyric">
                {{ line.extra }}
            </text>
        </div>
    
        <div class="lyrics-list-padding-bottom"></div>
    </scroll>
</div>



            <!-- 视图 2: 评论 
            <div class="swiper-item comments-view">
                <image class="placeholder-icon" src="/common/icon/comment.png"></image>
                <text class="placeholder-text">评论区即将上线</text>
            </div>-->
        </swiper>
	</div>
</template>

<style>
/* --- 基础布局 --- */
.demo-page {
    width: 100%;
    height: 100%;
    flex-direction: column;
    justify-content: flex-start; /* 从顶部开始布局 */
    align-items: center;
    background-color: #000;
}
.song { 
    width: 100%; 
    height: 90px; /* 歌曲信息区域高度 */
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    flex-shrink: 0; /* 防止被压缩 */
    padding-top: 10px;
}
.song-name { 
    width: 320px; 
    font-size: 32px; 
    color: #ffffff; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
}
.singer-name { 
    width: 300px; 
    font-size: 24px; 
    /* 【修改】使用固定颜色代替透明度 */
    color: #CCCCCC; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
}

/* --- Swiper 容器与子项 --- */
.content-swiper {
    width: 100%;
    /* 让 swiper 占据剩余的所有空间 */
    flex-grow: 1; 
    indicator-size: 10px;
    /* 【修改】使用固定颜色代替透明度 */
    indicator-color: #555555;
    indicator-selected-color: #3ae1ff;
    indicator-bottom: 10px; /* 指示器位置微调 */
}
.swiper-item {
    width: 100%;
    height: 100%;
    flex-direction: column;
    align-items: center;
}

/* 播放器视图内部布局 */
.player-view {
    justify-content: space-around; /* 让三个部分均匀分布 */
    padding: 20px 0;
}
.controls {
	width: 360px;
    height: 144px;
	justify-content: space-around; /* 按钮间距更均匀 */
	align-items: center;
}
.icon {
	width: 90px;
	height: 90px;
}
.progress { 
    height: 80px; 
    width: 90%; 
    flex-direction: column; 
    align-items: center; 
}
.play-time { 
    text-align: left; 
    color: #ffffff; 
    font-size: 24px; 
    margin: 5px; 
}
.play-progress { 
    width: 80%; 
    selected-color: #3ae1ff; 
    block-color: #ffffff; 
    padding-left: 0px; 
    padding-right: 0px; 
    margin: 0 20px; 
}
.footer { 
    height: 75px; 
    width: 100%; 
    justify-content: center; 
    align-items: center; 
}
.footer-content-rect { 
    width: 90%; 
    justify-content: space-around; 
    align-items: center; 
}
.footer-content-circle { 
    width: 320px; 
    justify-content: space-around; 
    align-items: center; 
}
.footer-icon { 
    width: 64px; 
    height: 64px; 
}

/* --- 歌词视图样式 (已优化 - 无透明度版) --- */
.lyrics-scroll-view {
    width: 100%;
    height: 100%;
    padding:0 10px;
    flex-direction: column;
    align-items: center;
}
.lyrics-list-padding-top, .lyrics-list-padding-bottom {
    height: 150px; 
}
.lyric-line-wrapper {
    width: 100%;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3px 0;
}
.is-current-wrapper {
    /* 【修改】使用固定颜色代替透明度 */
    background-color: #1A1A1A; 
    border-radius: 50%;
}
.lyric-line {
    width: 90%;
    text-align: center;
    lines: -1;
    
    /* 【核心修改】默认状态：非当前行，使用灰色代替白色+透明度 */
    color: #999999; 
    font-size: 24px;
}

/* 【核心修改】当前行的激活状态 */
.current-lyric {
    /* 【移除】opacity: 1; (已是默认) */
    color: #3ae1ff;
    font-weight: bold;
    font-size: 26px;
    padding: 6px 0;
}

.extra-lyric {
    font-size: 20px;
    /* 【修改】使用固定颜色代替白色+透明度 */
    color: #BBBBBB;
    padding-bottom: 6px;
}


/* --- 评论区占位符 --- */
.comments-view {
    justify-content: center;
    /* 【修改】使用固定颜色代替透明度 */
    color: #666666;
}
.placeholder-icon {
    width: 60px;
    height: 60px;
    /* 【修改】使用固定颜色代替透明度 */
    color: #4D4D4D;
}
.placeholder-text {
    font-size: 24px;
    margin-top: 8px;
}

/* --- 媒体查询 --- */
@media screen and (shape: rect) {
    .song-name {
        padding-top: 20px;
    }
    .progress {
        width: 400px;
    }
    .is-current-wrapper {
        /* 【修改】使用固定颜色代替透明度 */
        background-color: #1A1A1A;
        border-radius: 24px;
    }
    .lyrics-list-padding-top, .lyrics-list-padding-bottom {
        height: 190px;
    }
    /* 方形屏幕下字体也相应缩小 */
    .secondary-lyric { font-size: 24px; }
    .current-lyric { font-size: 26px; }
    .extra-lyric { font-size: 19px; }
}
</style>


<script>
import router from "@system.router";
import audio from "@system.audio";
import file from "@system.file";
import prompt from '@system.prompt';
import device from '@system.device';
import app from "@system.app";

// --- 1. 引入新的服务模块 ---
import apiService from '../../services/api.js';
import throttle from '../../utils/throttle.js';

// --- 2. 常量和文件服务封装 (保持不变) ---
const CONSTANTS = {
    DIR_MUSIC: 'internal://files/music/',
    DIR_LYRICS: 'internal://files/lyrics/',
    FILE_PLAY_LIST: 'internal://files/play_list.json',
    FILE_DOWNLOADED_SONGS: 'internal://files/downloaded_songs.json',
    SETTINGS_FILE_URI: 'internal://files/settings.json',
    COOKIE_FILE_URI: 'internal://files/cookie.txt',
    FILE_PLAYER_STATE: 'internal://files/player_state.json',
    MAX_PLAYBACK_RETRIES: 3,
    PLAY_TIMEOUT: 8000,
};

const fileService = {
    _promisify(fn, options) { return new Promise((resolve, reject) => { fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) }); }); },
    async readJson(uri, defaultValue = null) { try { const data = await this._promisify(file.readText, { uri }); return JSON.parse(data.text); } catch (e) { return defaultValue; } },
    async writeJson(uri, data) { try { await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) }); return true; } catch (e) { return false; } },
};

export default {
    private: {
        playerState: { isPlaying: false, playDuration: 0, currentLyricIndex: 0, lyricType: 'chinese' },
        currSong: null,
        lyrics: [],
    // expend: false, // <--- 删除此行
    swiperCurrentIndex: 0, // <--- 添加此行
        downloadedSongs: {},
        settings: { lyrics: { japaneseMode: 'translation', cantoneseMode: 'romaji', englishMode: 'translation' },lyricAdvanceTime:1.8, audioQuality: { online: 64, download: 128 } },
        isPlaying: false,
        cookie: null,
        isDownloadingLocked: false,
        wasRestored: false,
        retryCount: 0,
        screenShape: 'circle',
        playMode: 0,
        songBeingDownloaded: null,
        isFmMode: false,
        fmQueue: [],
        isFetchingFm: false,
        _isInitialized: false,
        _isInitialRefreshed: false,
        pendingSongId: null,
        playTimeoutId: null,
        needsRefresh: false,
        // 【新增】缓存滚动容器元素，避免重复查询
        _lyricsScrollView: null,
    },

    protected: {
        playList: [],
        currentIndex: 0,
        songId: null,
        songInfo: null,
        triggerDownload: false,
        triggerPlayModeToggle: false,
        startFmMode: false,
    },
    
    computed: {
        swiperHeight() { return this.expend ? this.screenShape === 'rect' ? 438 : 390 : this.screenShape === 'rect' ? 260 : 180; },
        songName() { return this.currSong ? this.currSong.name : "未知歌曲"; },
        songArtists() { return this.currSong ? this.currSong.artists : "未知艺术家"; },
        playButtonIcon() {
            if (this.pendingSongId && !this.playerState.isPlaying) return '/common/icon/loading.png';
            return this.playerState.isPlaying ? '/common/icon/pause.png' : '/common/icon/play.png';
        },
        progressText() {
            const duration = this.currSong?.duration || 0;
            return `${this.second2time(this.playerState.playDuration)}/${this.second2time(duration)}`;
        },
        downloadIcon() {
            const icons = { downloading: '/common/icon/downloading.png', downloaded: '/common/icon/downloaded.png', not_downloaded: '/common/icon/download.png' };
            if (!this.currSong) return icons.not_downloaded;
            if (this.songBeingDownloaded && this.currSong.id === this.songBeingDownloaded.id) return icons.downloading;
            if (this.downloadedSongs[this.currSong.id]) return icons.downloaded;
            return icons.not_downloaded;
        },
        playModeIcon() {
            if (this.isFmMode) return '/common/icon/fm.png';
            const icons = ['/common/icon/loop.png', '/common/icon/single-loop.png', '/common/icon/random.png'];
            return icons[this.playMode] || icons[0];
        },
        fullVisibleLyrics() {
        if (!this.lyrics || this.lyrics.length === 0) return [];

        return this.lyrics.map((line, index) => {
            const isCurrent = index === this.playerState.currentLyricIndex;
            
            // 【【【性能优化点】】】
            // 为每个列表项生成一个稳定且唯一的 ID
            // 使用时间戳和索引结合，确保即使时间戳重复（在某些不规范的lrc文件中），ID依然唯一
            const uniqueId = `lyric-${line.time}-${index}`;

            return {
                id: uniqueId, // <--- 新增的唯一ID，用于 tid
                original: line.original || line.text || '',
                extra: isCurrent ? this.getExtraLyricText(line) : null,
                isCurrent: isCurrent,
            };
        });
    },
    },


    // --- 生命周期函数 (保持不变) ---
    async onInit() {
        if (this.$app.$def.isActivated !== true) { router.replace({ uri: '/pages/splash' }); return; }
        console.log("Player onInit: 准备基础环境。");
        this.throttledSliderChange = throttle(this.applySliderChange, 200);
        
        // ... 您已有的 onInit 剩余代码 ...
        this.bindAudioEvents();
        await this.loadSettings();
        await this.loadCookie();
        await this.loadDownloadedSongs();
        this.getDeviceInfo();
        await this.onRestoreState();
    },
    async onShow() {
    console.log("Player onShow: 页面显示。");
    
    // 【【【核心修正】】】
    // onShow 抢跑 onRefresh，所以它不能执行任何重量级或有副作用的操作。
    // 我们在这里只设置一个标志，告诉 onRefresh 需要重新加载数据。
    this.needsRefresh = true;
    
    // 移除所有 await 和状态修改逻辑，避免污染 onRefresh 的执行环境。
    // console.log("onShow: 常规模式，同步数据并检查列表。");
    // await this.loadDownloadedSongs();
    // await this.loadListFromFile();
    // if (this.currSong) { ... }
},
async onRefresh(query) {
    const params = query || {};
    console.log('Player onRefresh with params:', JSON.stringify(params));

    // 【【【核心修正】】】
    // onRefresh 现在是所有逻辑的唯一权威入口。

    // 1. 检查 onShow 设置的标志，如果需要，则加载核心数据
    if (this.needsRefresh) {
        console.log("onRefresh: 检测到 needsRefresh 标志，开始加载数据。");
        await this.loadDownloadedSongs();
        await this.loadListFromFile();
        this.needsRefresh = false; // 重置标志
    }

    // 2. 优先处理所有传入的明确指令
    if (params.triggerDownload) {
        console.log("onRefresh: 收到下载指令，执行。");
        this.initiateDownload();
        return;
    }
    if (params.startFmMode) {
        console.log("onRefresh: 收到启动FM指令，执行。");
        this.dostartFmMode(params.songId, params.songInfo);
        return;
    }
    if (params.triggerPlayModeToggle) {
        console.log("onRefresh: 收到播放模式切换指令，执行。");
        this.togglePlayMode();
    }

    // 3. 处理播放新歌的指令
    if (params.songId) {
        if (!this.currSong || this.currSong.id != params.songId) {
            console.log(`onRefresh: 收到新歌指令 [${params.songId}]，执行播放。`);
            this.songId = params.songId;
            this.songInfo = params.songInfo ? JSON.parse(params.songInfo) : null;
            await this.startLogic();
        } else {
            console.log(`onRefresh: 收到相同歌曲指令 [${params.songId}]，不执行操作。`);
        }
        // 处理完新歌指令后，不再执行后续逻辑
        return; 
    }

    // 4. 如果没有任何新指令，才执行之前 onShow 的检查逻辑
    console.log("onRefresh: 无新指令，检查当前歌曲状态。");
    if (this.currSong) {
        const stillInPlaylist = this.playList.some(song => song.id === this.currSong.id);
        if (!stillInPlaylist) {
            prompt.showToast({ message: "当前歌曲已从列表中移除" });
            // 在这里统一处理，比如播放下一首
            await this.change(1); 
        }
    }
    
    // 之前的 "onRefresh: 未收到任何有效指令..." 日志可以移除，因为逻辑已经更清晰了
},

    /**
     * 【核心修正】: 恢复你在 onDestroy 中的 onSaveState 调用
     */
     onDestroy() {
        console.log("Player onDestroy: 页面被销毁。");
        audio.stop();
        if (!this.isDownloadingLocked) {
            this.onSaveState(); // 【恢复】
        }
        prompt.showToast({ message: '播放已暂停' });
    },

    onBackPress() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请勿退出' }); return true; }
        this.onSaveState();
        prompt.showToast({ message: '防误退出，点击顶部歌名以退出' });
        return true;
    },

    /**
     * 【核心修正】: 恢复 onRestoreState 的完整功能，但不触发播放
     */
    async onRestoreState() {
        if (this.songId) return false;

        const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
        const isStateExpired = savedState?.timestamp ? (new Date().getTime() - savedState.timestamp > 12 * 3600 * 1000) : true;

        if (savedState && savedState.lastSongId && savedState.duration && !isStateExpired) {
            await this.loadListFromFile();
            const lastIndex = this.playList.findIndex(song => song && song.id === savedState.lastSongId);

            if (lastIndex > -1) {
                console.log(`onRestoreState: 成功恢复状态，歌曲: ${this.playList[lastIndex].name}`);
                
                // 【关键】只恢复数据和UI，不调用任何播放方法
                this.songId = savedState.lastSongId;
                this.currentIndex = lastIndex;
                this.playMode = savedState.playMode || 0;
                this.currSong = { ...this.playList[this.currentIndex], duration: savedState.duration };
                this.playerState.playDuration = savedState.lastPlayDuration || 0;
                
                this.fetchLyric(this.songId);
                
                prompt.showToast({ message: "播放状态已恢复" });
                return true;
            }
        }
        return false;
    },

    // --- 交互与UI方法 ---
    handleSwipe(e) {
        if (e.direction === 'left') {
            if (this.isFmMode) this.change(1);
            else router.push({ uri: '/pages/list' });
        }
        if (e.direction === 'right') router.back();
    },
    onSwiperChange(e) {
        this.swiperCurrentIndex = e.index;
        
        // 当用户滑动到歌词页时，主动触发一次滚动，确保位置正确
        if (this.swiperCurrentIndex === 1) {
            this.scrollToCurrentLyric(); 
        }
    },
    getDeviceInfo() { device.getInfo({ success: (data) => { if (data.screenShape) this.screenShape = data.screenShape; }, fail: (data, code) => console.error(`获取设备信息失败, code = ${code}`) }); },
    async onSaveState() {
        if (!this.currSong || !this.currSong.duration) return;
        const stateToSave = { lastSongId: this.currSong.id, lastPlayDuration: this.playerState.playDuration, playMode: this.playMode, duration: this.currSong.duration, timestamp: new Date().getTime() };
        await fileService.writeJson(CONSTANTS.FILE_PLAYER_STATE, stateToSave);
    },
    playOrPause() {
        if (!this.currSong) { prompt.showToast({ message: '没有可播放的歌曲' }); return; }
        if (!audio.src) { this.startLogic(); return; }
        if (!this.isChangingSong) this.playerState.isPlaying ? audio.pause() : audio.play();
    },
        // 真正执行 seek 的方法
        applySliderChange(progress) {
        console.log(`[Throttled] Applying seek to: ${progress}`);
        if (this.playerState.isPlaying || audio.duration > 0) {
            audio.currentTime = progress;
            this.updateLyric(); // 手动更新歌词以保证UI响应
        }
    },

    // 进度条的 onchange 事件处理函数
    onSliderChange(e) {
        // 3. 调用节流后的函数，而不是直接操作 audio
        //    注意：这里需要通过 this 来调用
        this.throttledSliderChange(e.progress);
    },
    goToSongActions() {
        if (!this.currSong) { prompt.showToast({ message: '当前无播放歌曲' }); return; }
        router.push({ uri: "/pages/volume", params: { currentSong: JSON.stringify(this.currSong), screenShape: this.screenShape, playMode: this.playMode, isFmMode: this.isFmMode } });
    },
    togglePlayMode() {
        if (this.isFmMode) {
            prompt.showDialog({
                title: '退出私人FM', message: '您确定要退出私人FM吗？将会停止当前播放并返回常规列表模式。', buttons: [{ text: '取消' }, { text: '确定退出', color: '#FF453A' }],
                success: async () => {
                    prompt.showToast({ message: '正在退出私人FM...' });
                    this.isFmMode = false; this.fmQueue = []; this.resetPlayer();
                    try { await this.startLogic(); prompt.showToast({ message: '已返回列表播放模式' }); } catch (error) { prompt.showToast({ message: '播放列表为空' }); }
                },
                cancel: () => prompt.showToast({ message: '操作已取消' })
            });
            return;
        }
        this.playMode = (this.playMode + 1) % 3;
        const modeText = ['列表循环', '单曲循环', '随机播放'];
        prompt.showToast({ message: modeText[this.playMode] });
        if (this.playMode === 2 && this.playList.length > 0) this.generateShuffledList(true);
    },
    goToMenu() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请稍后' }); return; }
        if (this.isFmMode) { prompt.showToast({ message: '当前处于FM模式！打开过多页面将导致中断！' }); }
        router.push({ uri: "/pages/menu" });
    },
    exit() { app.terminate(); },
    // --- 下载逻辑 (已重构并使用闭包管理周期性提示) ---
    initiateDownload() {
        // 1. 前置检查 (保持不变)
        if (typeof this.downloadedSongs !== 'object' || this.downloadedSongs === null) {
            prompt.showToast({ message: '下载列表未准备好，请稍后重试' });
            this.loadDownloadedSongs();
            return;
        }
        if (!this.currSong) { prompt.showToast({ message: '歌曲信息无效，无法下载' }); return; }
        if (this.downloadedSongs[this.currSong.id]) { prompt.showToast({ message: '歌曲已下载' }); return; }
        if (this.isDownloadingLocked) { prompt.showToast({ message: '已有任务在下载中' }); return; }

        // 2. 【【【核心】】】在方法作用域顶部声明一个变量，用于存储定时器ID
        let downloadToastTimer = null;

        // 3. 初始提示
        prompt.showToast({ message: `开始准备下载: ${this.currSong.name}` });

        // 4. 调用下载服务
        this.$app.$def.downloadService.start(
            this.currSong,
            { cookie: this.cookie, downloadBitrate: this.settings.audioQuality.download },
            {
                onStart: (song) => {
                    this.isDownloadingLocked = true;
                    this.songBeingDownloaded = { ...song };

                    // 【【【核心】】】创建定时器，并将其ID赋值给外部作用域的变量
                    downloadToastTimer = setInterval(() => {
                        if (this.songBeingDownloaded) {
                            prompt.showToast({ message: `下载中` ,duration: 500});
                        }
                    }, 3000);
                },
                
                onSuccess: async (downloadedInfo) => {
                    // ... (成功逻辑保持不变)
                    try {
                        const updatedSongs = { ...this.downloadedSongs, [downloadedInfo.id]: downloadedInfo };
                        await fileService.writeJson(CONSTANTS.FILE_DOWNLOADED_SONGS, updatedSongs);
                        this.downloadedSongs = updatedSongs;
                        prompt.showToast({ message: `${downloadedInfo.name} 下载并记录成功`, duration: 5000 });
                    } catch (error) {
                        console.error("写入下载记录失败:", error);
                        prompt.showToast({ message: `歌曲已下载，但保存记录失败: ${error.message}` });
                    }
                },
                
                onError: (errorMessage) => {
                    // ... (失败逻辑保持不变)
                    prompt.showToast({ message: `下载失败: ${errorMessage}` });
                },
                
                onFinish: () => {
                    // 【【【核心】】】
                    // onFinish 回调作为闭包，可以访问并清除在外部作用域中声明的 downloadToastTimer
                    if (downloadToastTimer) {
                        clearInterval(downloadToastTimer);
                        console.log("下载提示定时器已清除。");
                    }

                    this.isDownloadingLocked = false;
                    this.songBeingDownloaded = null;
                }
            }
        );
    },


    /**
     * 【核心修正】: startLogic 不再处理恢复逻辑，职责更单一
     */
     async startLogic() {
        // 【移除】所有与 wasRestored 相关的逻辑
        
        if (!this.songId) {
            await this.loadListFromFile();
            if (this.playList && this.playList.length > 0) {
                this.currentIndex = 0;
                this.playCurrent();
            } else {
                prompt.showToast({ message: "播放列表为空" });
            }
            return;
        }

        await this.loadListFromFile();
        const index = this.playList.findIndex(item => item && String(item.id) === String(this.songId));
        
        if (index !== -1) {
            this.currentIndex = index;
        } else {
            if (this.songInfo && this.songInfo.id) {
                this.playList.unshift(this.songInfo);
                this.currentIndex = 0;
                await fileService.writeJson(CONSTANTS.FILE_PLAY_LIST, this.playList);
            } else {
                this.currentIndex = 0;
            }
        }

        if (this.playList.length > 0) {
            this.playCurrent();
        }
    },
    async playCurrent() {
        let songToPlay;
        if (this.isFmMode) {
            if (this.fmQueue.length === 0) {
                await this.fetchNextFmSongs();
                if (this.fmQueue.length === 0) { this.resetPlayer(); return; }
            }
            songToPlay = this.fmQueue[0];
        } else {
            if (!this.playList || this.playList.length === 0) { this.resetPlayer(); return; }
            songToPlay = this.playList[this.currentIndex];
        }
        if (!songToPlay) { this.handlePlaybackError("无效的歌曲数据"); return; }
        if (this.pendingSongId === songToPlay.id) return;
        this.pendingSongId = songToPlay.id;
        this.updateUiForNewSong(songToPlay);
        this.startPlaybackTimeout();
        if (this.isFmMode) this.fmQueue.shift();
        try {
            const downloadedInfo = this.downloadedSongs[songToPlay.id];
            if (downloadedInfo?.localUri) await this.playLocal(songToPlay, downloadedInfo);
            else await this.playOnline(songToPlay);
        } catch (error) { this.handlePlaybackError(error.message || "播放准备失败"); }
    },
    updateUiForNewSong(song) {
        audio.stop();
        if (!this.currSong) this.currSong = { ...song, duration: 0 };
        else { this.currSong.id = song.id; this.currSong.name = song.name; this.currSong.artists = song.artists; this.currSong.duration = 0; }
        this.playerState.playDuration = 0;
        this.resetLyrics();
        this.fetchLyric(song.id);
    },
    startPlaybackTimeout() {
        if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
        this.playTimeoutId = setTimeout(() => {
            console.error("!!! PLAYBACK TIMEOUT !!!");
            prompt.showToast({ message: '播放超时，请重试' });
            this.pendingSongId = null; this.playTimeoutId = null; this.resetPlayer();
        }, CONSTANTS.PLAY_TIMEOUT);
    },
    async playLocal(song, downloadedInfo) {
        return new Promise((resolve, reject) => {
            file.access({
                uri: downloadedInfo.localUri,
                success: () => { this.startPlayback({ ...song, ...downloadedInfo }, downloadedInfo.localUri); this.fetchLyric(song.id); resolve(); },
                fail: () => { prompt.showToast({ message: '本地文件失效，转为在线播放' }); this.playOnline(song).then(resolve).catch(reject); }
            });
        });
    },
    async playOnline(song) {
        this.isEnding = false;
        try {
            const songInfo = await apiService.getSongPlaybackInfo(song.id, this.settings.audioQuality.online, this.cookie);
            const fullSongInfo = { ...song, playUrl: songInfo.url, duration: songInfo.duration };
            this.startPlayback(fullSongInfo, songInfo.url);
            this.fetchLyricOnline(song.id);
        } catch (error) { console.error("playOnline 失败:", error); throw error; }
    },
    startPlayback(songWithDuration, src) {
        if (!src || typeof src !== 'string') { this.handlePlaybackError("无效的播放源"); return; }
        if (this.currSong && songWithDuration && songWithDuration.duration) this.currSong.duration = songWithDuration.duration;
        this.retryCount = 0; audio.stop(); audio.src = src; audio.play();
    },
    change(dir) {
        if (this.pendingSongId) { prompt.showToast({ message: '正在切歌...' }); return; }
        if (this.isFmMode) { if (dir < 0) { prompt.showToast({ message: '私人FM不支持上一首哦' }); return; } this.playCurrent(); return; }
        if (!this.playList || this.playList.length === 0) return;
        switch (this.playMode) {
            case 0: case 1: this.currentIndex = (this.currentIndex + dir + this.playList.length) % this.playList.length; break;
            case 2:
                if (!this.shuffledPlayList || this.shuffledPlayList.length !== this.playList.length) this.generateShuffledList(false);
                this.shuffledIndex = (this.shuffledIndex + dir + this.shuffledPlayList.length) % this.shuffledPlayList.length;
                this.currentIndex = this.shuffledPlayList[this.shuffledIndex];
                break;
        }
        this.playCurrent();
    },

    generateShuffledList(locateCurrent = true) {
        console.log("生成新的随机播放列表...");
        this.shuffledPlayList = Array.from(this.playList.keys());
        
        for (let i = this.shuffledPlayList.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.shuffledPlayList[i], this.shuffledPlayList[j]] = [this.shuffledPlayList[j], this.shuffledPlayList[i]];
        }

        if (locateCurrent) {
            const currentShuffledIndex = this.shuffledPlayList.indexOf(this.currentIndex);
            this.shuffledIndex = (currentShuffledIndex !== -1) ? currentShuffledIndex : 0;
        }
        console.log("随机列表已生成, 当前随机索引:", this.shuffledIndex);
    },

    // --- FM 模式逻辑 (已重构) ---
    async dostartFmMode(initialSongId = null, initialSongInfo = null) {
        if (this.isFetchingFm) return;

        this.isFmMode = true;
        this.isFetchingFm = true;
        this.playList = [];
        this.fmQueue = [];
        audio.stop();
        prompt.showToast({ message: '正在开启私人FM...' });

        if (initialSongId && initialSongInfo) {
            try { this.fmQueue.push(JSON.parse(initialSongInfo)); }
            catch(e) { console.error("解析FM初始歌曲信息失败"); }
        }

        try {
            await this.fetchNextFmSongs();
            if (this.fmQueue.length > 0) this.playCurrent();
            else { prompt.showToast({ message: '无法获取FM歌曲，请检查网络' }); this.isFmMode = false; }
        } catch (error) {
            prompt.showToast({ message: '启动FM失败' });
            this.isFmMode = false;
        } finally {
            this.isFetchingFm = false;
        }
    },
    async fetchNextFmSongs() {
        if (this.isFetchingFm) return;
        this.isFetchingFm = true;
        console.log("正在获取新的FM歌曲...");
        try {
            const newSongs = await apiService.getPersonalFmSongs(this.cookie);
            if (newSongs.length > 0) {
                this.fmQueue.push(...newSongs);
                console.log(`成功获取 ${newSongs.length} 首FM歌曲，当前队列长度: ${this.fmQueue.length}`);
            } else {
                prompt.showToast({ message: '没有更多FM推荐了' });
            }
        } catch (error) {
            console.error("获取FM歌曲失败:", error);
            prompt.showToast({ message: '获取新歌失败' });
        } finally {
            this.isFetchingFm = false;
        }
    },

    // --- 歌词处理逻辑 (保持不变) ---
    fetchLyric(songId) {
        this.resetLyrics();
        const downloadedInfo = this.downloadedSongs[songId];
        if (downloadedInfo?.localLyricUri) this.loadLyricFromFile(downloadedInfo.localLyricUri, songId);
        else this.fetchLyricOnline(songId);
    },
    loadLyricFromFile(uri, songId) {
        file.readText({
            uri: uri,
            success: (data) => { try { this.processAndMergeLyrics(JSON.parse(data.text)); } catch (e) { this.fetchLyricOnline(songId); } },
            fail: () => this.fetchLyricOnline(songId)
        });
    },
    async fetchLyricOnline(songId) {
        try {
            const lyricData = await apiService.getLyricData(songId, this.cookie);
            this.processAndMergeLyrics(lyricData);
        } catch (error) { 
            this.lyrics = [{ time: 0, text: '歌词加载失败' }]; 
        }
    },
    processAndMergeLyrics(data) {
        if (!data?.lrc?.lyric) { this.lyrics = [{ time: 0, text: '暂无歌词' }]; return; }
        const original = this.parseLyric(data.lrc.lyric);
        const translation = data.tlyric?.lyric ? this.parseLyric(data.tlyric.lyric) : null;
        const romaji = data.romalrc?.lyric ? this.parseLyric(data.romalrc.lyric) : null;
        this.mergeLyrics(original, translation, romaji);
    },
    parseLyric(lrcString) {
        const lines = lrcString.split('\n'), result = [], timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
            const match = timeRegex.exec(line);
            if (match) {
                const time = parseInt(match[1]) * 60 + parseInt(match[2]) + parseInt(match[3].padEnd(3, '0')) / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) result.push({ time, text });
            }
        }
        return result;
    },
    mergeLyrics(original, translation, romaji) {
        const createMap = (arr) => new Map(arr.map(item => [item.time.toFixed(3), item.text]));
        if (romaji && translation) {
            this.playerState.lyricType = 'japanese';
            const transMap = createMap(translation), romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)), romaji: romaMap.get(line.time.toFixed(3)) }));
        } 
        else if (romaji && !translation) {
            this.playerState.lyricType = 'cantonese';
            const romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, romaji: romaMap.get(line.time.toFixed(3)) }));
        }
        else if (translation) {
            this.playerState.lyricType = 'english';
            const transMap = createMap(translation);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)) }));
        } else {
            this.playerState.lyricType = 'chinese';
            this.lyrics = original.map(line => ({ time: line.time, original: line.text }));
        }
        if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: '暂无歌词' }];
    },
    getExtraLyricText(lineData) {
        if (!lineData) return '';
        let extraText = '';
        const lyricSettings = this.settings.lyrics || {};
        switch (this.playerState.lyricType) {
            case 'japanese':
                if (lyricSettings.japaneseMode === 'translation') extraText = lineData.translation || '';
                else if (lyricSettings.japaneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'cantonese':
                if (lyricSettings.cantoneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'english':
                if (lyricSettings.englishMode === 'translation') extraText = lineData.translation || '';
                break;
        }
        return extraText;
    },
    /**
     * 新增方法：用于从代码层面切换到歌词页。
     * 例如，可以绑定到一个按钮的点击事件上。
     */
     goToLyricsPage() {
        this.$element('contentSwiper').swipeTo({
            index: 1
        });
    },
    /**
     * 【【【核心优化函数】】】
     * 歌词更新逻辑
     * 此函数由 audio.ontimeupdate 触发
     */
     updateLyric() {
        // 1. 早期退出：如果歌词数据还没准备好，或当前不在歌词页，直接返回。
        if (!this.lyrics || this.lyrics.length === 0 || this.swiperCurrentIndex !== 1) {
            return;
        }

        // 2. 引入“幽灵时间”进行计算，以实现歌词提前高亮。
        const preSwitchOffset = this.settings.lyricAdvanceTime || 1.8;
        const lookaheadTime = this.playerState.playDuration + preSwitchOffset;

        // 3. 时间范围快速检查 (高性能路径)，避免在歌词行未变化时进行不必要的计算。
        const currentIndex = this.playerState.currentLyricIndex;
        const currentLine = this.lyrics[currentIndex];
        const nextLine = this.lyrics[currentIndex + 1];
        if (nextLine && lookaheadTime >= currentLine.time && lookaheadTime < nextLine.time) {
            return; // 当前行无需变化，直接返回
        }

        // 4. 执行完整的查找逻辑 (低频路径)，找到当前应该高亮的新索引。
        let newIndex = this.lyrics.findIndex(line => line.time > lookaheadTime);
        if (newIndex === -1) {
            newIndex = this.lyrics.length > 0 ? this.lyrics.length - 1 : 0;
        } else {
            newIndex = Math.max(0, newIndex - 1);
        }
        
        // 5. 【关键】只有在计算出的新索引与当前索引不同时，才执行更新和滚动。
        if (newIndex !== currentIndex) {
            // a. 立即更新数据状态。
            //    这会触发框架在下一个渲染周期中去更新DOM（即改变高亮行的class）。
            this.playerState.currentLyricIndex = newIndex;
            
            // b. 【关键】使用 $nextTick，确保在DOM更新完成后再执行滚动。
            this.$nextTick(() => {
                this.scrollToCurrentLyric();
            });
        }
    },

    /**
     * 【【【核心优化函数 - 已修复居中偏移问题】】】
     * 滚动到当前高亮歌词
     */
     scrollToCurrentLyric() {
        // 1. 检查页面是否在歌词页
        if (this.swiperCurrentIndex !== 1) {
            return;
        }

        // 2. 检查滚动容器是否已缓存
        if (!this._lyricsScrollView) {
            this._lyricsScrollView = this.$element('lyricsScrollView');
            if (!this._lyricsScrollView) return; // 如果获取失败则退出
        }

        // 3. 获取当前高亮行元素 (这是包含主歌词和附加歌词的整个wrapper div)
        const lineElement = this.$element(`lyric-line-${this.playerState.currentLyricIndex}`);
        if (!lineElement) return;

        // 4. 将两次 getBoundingClientRect 合并到一个回调链中
        this._lyricsScrollView.getBoundingClientRect({
            success: (scrollRect) => {
                lineElement.getBoundingClientRect({
                    success: (lineRect) => {
                        // 【【【核心修复】】】
                        // 这里的 lineRect.height 是当前高亮区块的【实际渲染高度】。
                        // 当显示附加歌词时，这个值会自然变大。
                        
                        // 1. 计算滚动容器的目标中线位置 (例如，容器高度的40%处)
                        const targetCenterY = scrollRect.height * 0.4;
                        
                        // 2. 计算当前高亮区块的顶部边缘，在其父容器(滚动区域)中的相对位置
                        const lineTopInContainer = lineRect.top - scrollRect.top;
                        
                        // 3. 计算为了让【高亮区块的中心】对齐到【目标中线】所需的滚动量
                        //    公式解读:
                        //    a. (lineTopInContainer + lineRect.height / 2) 是高亮区块的中心线位置
                        //    b. 减去 targetCenterY，就是中心线之间的距离，即需要滚动的偏移量
                        const scrollOffset = (lineTopInContainer + lineRect.height / 2) - targetCenterY;
                        
                        // 4. 执行滚动
                        this._lyricsScrollView.scrollBy({ 
                            top: scrollOffset, 
                            behavior: 'smooth' 
                        });
                    }
                });
            }
        });
    },

    // --- 播放器事件绑定 (已补全系统全局控制事件) ---
    bindAudioEvents() {
        // 同步播放/暂停状态
        audio.onplay = () => {
            if (!this.playerState.isPlaying) {
                this.playerState.isPlaying = true;
                if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
                audio.play();
                this.pendingSongId = null;
                console.log("Global Control: PLAY state synced.");
            }
        };
        
        audio.onpause = () => {
            if (this.playerState.isPlaying) {
                this.playerState.isPlaying = false;
                audio.pause();
                console.log("Global Control: PAUSE state synced.");
            }
        };

        // 停止时触发 (通常由 audio.stop() 或切歌引起)
        audio.onstop = () => {
            this.playerState.isPlaying = false;
            // 如果是因切换歌曲等原因停止，也应清除超时和等待状态
            if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
            this.pendingSongId = null;
            console.log("Event: onstop. 播放已停止。");
        };

        // 发生错误时触发
        audio.onerror = () => {
            this.handlePlaybackError("播放器发生错误");
        };

        // 播放进度更新时触发
        audio.ontimeupdate = () => {
            // 只有在非“等待播放”状态下才更新进度，防止新歌加载时进度条乱跳
            if (!this.pendingSongId) {
                this.playerState.playDuration = audio.currentTime;
                this.updateLyric(); // 同步更新歌词
            }
        };

        // 当前歌曲播放自然结束时触发
        audio.onended = () => {
            console.log(`Event: onended. 播放结束。当前时间: ${audio.currentTime}, 总时长: ${audio.duration}.`);
            
            // 【关键】防御性检查，防止框架提前触发 onended 的 BUG
            const timeDifference = Math.abs(audio.duration - audio.currentTime);
            if (audio.duration > 0 && timeDifference > 2) {
                console.error("!!! 框架BUG警告: onended 事件在歌曲结束前被过早触发 !!!");
            }

            // 如果是单曲循环模式，则重新播放当前歌曲
            if (this.playMode === 1) {
                this.playCurrent();
            } else {
                // 否则，切换到下一首
                this.change(1);
            }
        };


        // 2. 系统全局媒体控制事件 (从网易云代码中发现)
        // ----------------------------------------------------
        // 这些事件允许应用响应来自系统UI、蓝牙设备等的控制命令

        // 响应“播放上一首”命令
        audio.onctrlplayprev = () => {
            prompt.showToast({ message: '上一首' });
            this.change(-1);
        };

        // 响应“播放下一首”命令
        audio.onctrlplaynext = () => {
            prompt.showToast({ message: '下一首' });
            this.change(1);
        };

        // 响应“音量增加”命令
        audio.onctrlvolumeup = () => {
            // 获取当前音量并增加 0.1，最大为 1
            audio.getPlayState({
                success: function (state) {
                    const newVolume = state.volume > 0.9 ? 1 : state.volume + 0.1;
                    audio.volume = newVolume;
                    prompt.showToast({ message: `音量: ${Math.round(newVolume * 100)}%` });
                },
                fail: function (data, code) {
                    console.error(`[全局控制] 获取播放状态失败: code=${code}`);
                }
            });
        };

        // 响应“音量减少”命令
        audio.onctrlvolumedown = () => {
            // 获取当前音量并减少 0.1，最小为 0
            audio.getPlayState({
                success: function (state) {
                    const newVolume = state.volume < 0.1 ? 0 : state.volume - 0.1;
                    audio.volume = newVolume;
                    prompt.showToast({ message: `音量: ${Math.round(newVolume * 100)}%` });
                },
                fail: function (data, code) {
                    console.error(`[全局控制] 获取播放状态失败: code=${code}`);
                }
            });
        };
    },


    // --- 数据加载与重置 ---
    async loadSettings() {
        try {
            const data = await fileService.readJson(CONSTANTS.SETTINGS_FILE_URI);
            if (data) {
                // 【【【修改】】】确保 lyricAdvanceTime 能被正确合并
                this.settings = { 
                    ...this.settings, 
                    ...data, 
                    lyrics: { ...this.settings.lyrics, ...(data.lyrics || {}) }, 
                    audioQuality: { ...this.settings.audioQuality, ...(data.audioQuality || {}) } 
                };
                console.log("播放器设置加载成功，歌词提前量:", this.settings.lyricAdvanceTime);
            }
        } catch (e) { console.log("无法加载播放器设置，使用默认值。"); }
    },
    async loadCookie() {
        try {
            let rawText;
            try { rawText = (await fileService._promisify(file.readText, { uri: CONSTANTS.COOKIE_FILE_URI })).text; }
            catch(e) { rawText = null; }
            this.cookie = rawText || null;
            if (this.cookie) console.log("Cookie 加载成功。");
        } catch (e) { this.cookie = null; }
    },
    async loadListFromFile() { this.playList = await fileService.readJson(CONSTANTS.FILE_PLAY_LIST, []); },
    async loadDownloadedSongs() { this.downloadedSongs = await fileService.readJson(CONSTANTS.FILE_DOWNLOADED_SONGS, {}); },
    resetPlayer() {
        audio.stop();
        this.currSong = null;
        this.playerState.isPlaying = false;
        this.playerState.playDuration = 0;
        this.isChangingSong = false;
        this.retryCount = 0;
        this.resetLyrics();
    },
    resetLyrics() {
        this.lyrics = [];
        this.playerState.currentLyricIndex = 0;
    },

    // --- 错误处理 ---
    handlePlaybackError(message) {
        if (this.playTimeoutId) { clearTimeout(this.playTimeoutId); this.playTimeoutId = null; }
        this.pendingSongId = null;
        this.retryCount++;
        prompt.showToast({ message: `${message} (尝试第 ${this.retryCount} 次)` });
        if (this.retryCount >= CONSTANTS.MAX_PLAYBACK_RETRIES) {
            prompt.showToast({ message: `多次尝试失败，已停止播放`, duration: 5000 });
            this.resetPlayer();
            return;
        }
        setTimeout(() => { this.change(1); }, 1500 + (this.retryCount * 1000));
    },

    // --- 工具函数 ---
    second2time(second) {
        if (isNaN(second) || second < 0) return "00:00";
        const sec = Math.floor(second % 60).toString().padStart(2, "0");
        const min = Math.floor(second / 60).toString().padStart(2, "0");
        return `${min}:${sec}`;
    },
};
</script>
