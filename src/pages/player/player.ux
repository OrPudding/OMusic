<template>
	<div class="demo-page">
		<!-- 1. 歌曲信息 (保持在顶部) -->
		<div class="song" onswipe="handleHeaderSwipe">
			<marquee class="song-name" scrollamount="36">{{ songName }}</marquee>
			<marquee class="singer-name" scrollamount="36">{{ songArtists }}</marquee>
		</div>
		<!-- 2. 核心内容区域: 使用 show 属性切换视图，避免销毁和重建 -->
		<!-- 视图 0: 播放器主界面 (swiperCurrentIndex === 0 时渲染) -->
		<div
			if="{{ swiperCurrentIndex === 0 }}"
			class="swiper-item player-view"
			onswipe="handleSwipe"
		>
			<!-- a. 播放控制按钮 -->
			<div class="controls">
				<!-- Prev -->
				<image
					class="icon pressable {{ prevBtnClass }} {{ prevBtnAnim }}"
					src="/common/icon/prev.png"
					ontouchstart="pressDown('prevBtn')"
					ontouchend="pressRelease('prevBtn')"
					ontouchcancel="pressCancel('prevBtn')"
					onclick="change(-1)"
				/>
				<!-- Play/Pause -->
				<image
					class="pressable {{ playBtnClass }} {{ playBtnAnim }}"
					src="{{ playButtonIcon }}"
					ontouchstart="pressDown('playBtn')"
					ontouchend="pressRelease('playBtn')"
					ontouchcancel="pressCancel('playBtn')"
					onclick="onPlayBtnClick"
				/>

				<!-- Next -->
				<image
					class="icon pressable {{ nextBtnClass }} {{ nextBtnAnim }}"
					src="/common/icon/next.png"
					ontouchstart="pressDown('nextBtn')"
					ontouchend="pressRelease('nextBtn')"
					ontouchcancel="pressCancel('nextBtn')"
					onclick="change(1)"
				/>
			</div>

			<!-- b. 播放进度条 -->
			<div class="progress">
				<div class="progress-text">
					<text class="play-time">{{ progressCurrentTime }}</text>
					<text class="play-time">{{ progressTotalTime }}</text>
				</div>
				<slider
					class="play-progress"
					min="0"
					max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}"
					step="1"
					value="{{ playerState.playDuration }}"
					onchange="onSliderChange"
				></slider>
			</div>
			<!-- c. 底部操作栏 -->
			<div class="footer">
				<div class="footer-content">
					<image
						class="footer-icon pressable"
						src="/common/icon/volume.png"
						onclick="goToSongActions"
					></image>
					<image
						class="footer-icon footer-icon-down"
						src="/common/icon/download.png"
						onclick="initiateDownload"
					></image>
					<image
						class="footer-icon"
						src="/common/icon/play-list.png"
						onclick="goToMenu"
					></image>
				</div>
			</div>
		</div>

		<image
			class="little-icon"
			src="{{ downloadIcon }}"
			if="{{ downloadIcon && swiperCurrentIndex === 0 }}"
		></image>
<!-- 视图 1: 歌词页 -->
 <!-- fullscreen：固定容器，不可手动滚动 -->
 <div
 if="{{ swiperCurrentIndex === 1 && settings.lyricRenderMode === 'fullscreen' }}"
 class="fullscreen-lyrics"
 onswipe="handleSwipe"
>
 <div
   for="{{(i, line) in fullscreenLines}}"
   class="fs-line lyric-line-wrapper
		  {{ line.isCurrent ? 'is-current-wrapper' : '' }}
		  {{ line.isSelected ? 'is-selected-wrapper' : '' }}"
 >
   <text class="lyric-line {{ line.isCurrent ? 'current-lyric' : 'secondary-lyric' }}">
	 {{ line.original }}
   </text>

   <text
	 if="{{ line.extra }}"
	 class="lyric-line extra-lyric {{ line.isCurrent ? 'extra-current' : 'extra-secondary' }}"
   >
	 {{ line.extra }}
   </text>
 </div>
</div>



<!-- all：保留你原来的 scroll + 64 管道 -->
<scroll
    show="{{ swiperCurrentIndex === 1 && settings.lyricRenderMode === 'all' }}"
    id="lyricsScrollView"
    class="lyrics-scroll-view"
    scroll-y="true"
    onswipe="handleSwipe"
>
    <div class="lyrics-list-padding-top"></div>

<div for="{{(index, line) in lyricGroup0}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup1}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup2}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup3}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup4}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup5}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup6}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup7}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup8}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup9}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup10}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup11}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup12}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup13}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup14}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup15}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup16}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup17}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup18}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup19}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup20}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup21}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup22}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup23}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup24}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup25}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup26}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup27}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup28}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup29}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup30}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup31}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup32}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup33}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup34}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup35}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup36}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup37}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup38}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup39}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup40}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup41}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup42}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup43}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup44}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup45}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup46}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup47}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup48}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup49}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup50}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup51}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup52}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup53}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup54}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup55}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup56}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup57}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup58}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup59}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup60}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup61}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup62}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
<div for="{{(index, line) in lyricGroup63}}" tid="line.id" id="lyric-line-{{line.originalIndex}}" class="lyric-line-wrapper {{line.isCurrent ? 'is-current-wrapper' : ''}} {{line.isSelected ? 'is-selected-wrapper' : ''}}" onclick="onLyricLineClick(line, line.originalIndex)">
    <text class="lyric-line {{line.isCurrent ? 'current-lyric' : 'secondary-lyric'}}">{{ line.original }}</text>
    <text if="{{line.isCurrent && line.extra}}" class="lyric-line extra-lyric">{{ line.extra }}</text>
</div>
    <div class="lyrics-list-padding-bottom"></div>
</scroll>

		<!-- 3. 手动添加的页面指示器 (放置在最外层，不影响 if/else 结构) 
                <div if="swiperCurrentIndex === 1" class="manual-indicator">
                    <div class="indicator-dot {{ swiperCurrentIndex === 0 ? 'indicator-dot-active' : '' }}"></div>
                    <div class="indicator-dot {{ swiperCurrentIndex === 1 ? 'indicator-dot-active' : '' }}"></div>
                </div>
-->
	</div>
</template>

<style>
@import '../../common/font/MiSans-Demibold.css';
/* --- 基础布局 --- */
.demo-page {
	width: 100%;
	height: 100%;
	flex-direction: column;
	justify-content: flex-start; /* 从顶部开始布局 */
	align-items: center;
	background-color: #000;
}
.song {
	width: 100%;
	height: 90px; /* 歌曲信息区域高度 */
	flex-direction: column;
	justify-content: center;
	align-items: center;
	flex-shrink: 0; /* 防止被压缩 */
	padding-top: 30px;
}
.song-name {
	width: 360px;
	font-size: 32px;
	color: #ffffff;
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
	font-weight: bold;
}
.singer-name {
	width: 300px;
	font-size: 24px;
	/* 【修改】使用固定颜色代替透明度 */
	color: #cccccc;
	lines: 1;
	text-overflow: ellipsis;
	text-align: center;
	font-weight: bold;
}

/* --- Swiper 容器与子项 --- */
.content-swiper {
	width: 100%;
	/* 让 swiper 占据剩余的所有空间 */
	flex-grow: 1;
	indicator-size: 10px;
	/* 【修改】使用固定颜色代替透明度 */
	indicator-color: #555555;
	indicator-selected-color: #bac3ff;
	indicator-bottom: 10px; /* 指示器位置微调 */
}
/* --- Swiper 容器与子项 --- */
/* 将 .content-swiper 修改为 .swiper-item 并添加 flex-grow */
.swiper-item {
	width: 100%;
	flex-grow: 1; /* 让视图占据剩余的所有空间 */
	flex-direction: column;
	align-items: center;
}

/* --- 手动指示器样式 --- */
.manual-indicator {
	position: absolute;
	bottom: 10px;
	left: 0;
	width: 100%;
	height: 20px;
	flex-direction: row;
	justify-content: center;
	align-items: center;
}
.indicator-dot {
	width: 10px;
	height: 10px;
	border-radius: 5px;
	background-color: #555555; /* 对应原 indicator-color */
	margin: 0 5px;
}
.indicator-dot-active {
	background-color: #bac3ff; /* 对应原 indicator-selected-color */
}

/* 播放器视图内部布局 */
.player-view {
	justify-content: space-around; /* 让三个部分均匀分布 */
	padding: 20px 0;
}
.controls {
	width: 92%;
	justify-content: space-around; /* 按钮间距更均匀 */
	align-items: center;
}
.icon {
	width: 85px;
	height: 107px;
	margin-top: 16px;
}
.icon-play-pause {
	width: 132px;
	height: 132px;
	margin-bottom: 6px;
}
.progress {
	height: 80px;
	width: 90%;
	flex-direction: column;
	align-items: center;
}
.progress-text {
	width: 80%;
	justify-content: space-between;
}
.play-time {
	text-align: left;
	color: #ffffff;
	font-size: 24px;
	margin: 5px;
	font-weight: bold;
}
.play-progress {
	width: 80%;
	selected-color: #bac3ff;
	block-color: #ffffff;
	padding-left: 0px;
	padding-right: 0px;
	margin: 0 20px;
	transform-origin: 50% 50%;
}

.footer {
	width: 100%;
	justify-content: center;
	align-items: center;
}

.footer-content {
	width: 360px;
	justify-content: space-around;
}
.footer-icon {
	width: 91px;
	height: 66px;
}
.little-icon {
	position: absolute;
	top: 353px;
	left: 244px;
	width: 41px;
	height: 41px;
}
.footer-icon-down {
	margin-top: 40px;
}
/* --- 歌词视图样式 (已优化 - 无透明度版) --- */
.lyrics-scroll-view {
	width: 100%;
	height: 376px;
	padding: 0 10px;
	flex-direction: column;
	align-items: center;
}
.fullscreen-lyrics {
	width: 100%;
	height: 376px;      /* 同原 lyrics-scroll-view */
	padding: 0 3px;
	flex-direction: column;
	justify-content: center;
	align-items: center;
}

/* 每行占一个固定槽位：保证 5/7 行一定会超过 376px，从而上下被裁掉 */
.fs-line {
	width: 100%;
	align-items: center;
	justify-content: center;
}
.lyrics-list-padding-top,
.lyrics-list-padding-bottom {
	height: 150px;
}
.lyric-line-wrapper {
	width: 100%;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	padding: 3px 0;
}
.is-current-wrapper {
	/* 【修改】使用固定颜色代替透明度 */
	background-color: #1a1a1a;
	border-radius: 50%;
}
/* 【【【新增】】】 点击选中时的蓝色边框样式 */
.is-selected-wrapper {
	border: 3px solid #1a1a1a; /* 使用主题蓝色作为边框颜色 */
	border-radius: 50%; /* 使用一个固定的圆角值 */
}
.lyric-line {
	width: 90%;
	text-align: center;
	lines: -1;
	/* 【核心修改】默认状态：非当前行，使用灰色代替白色+透明度 */
	color: #999999;
	font-size: 26px;
}
/* 【核心修改】当前行的激活状态 */
.current-lyric {
	/* 【移除】opacity: 1; (已是默认) */
	color: #bac3ff;
	font-weight: bold;
	font-size: 28px;
	padding: 3px 0;
}
/* 非当前行 */
.secondary-lyric {
  font-size: 24px;        /* 明显小一档 */
  font-weight: 500;
  font-weight: bold;
  color: #888888;
}
.extra-lyric {
	font-size: 22px;
	font-weight: bold;
	lines: -1;
	/* 【修改】使用固定颜色代替白色+透明度 */
	color: #bbbbbb;
}
/* --- 评论区占位符 --- */
.comments-view {
	justify-content: center;
	/* 【修改】使用固定颜色代替透明度 */
	color: #666666;
}
.placeholder-icon {
	width: 60px;
	height: 60px;
	/* 【修改】使用固定颜色代替透明度 */
	color: #4d4d4d;
}
.placeholder-text {
	font-size: 24px;
	margin-top: 8px;
}
.pressable {
	/* 尺寸由具体按钮决定 */
	padding: 6px; /* 动画安全区 */
	margin-bottom: 6px;

	align-items: center;
	justify-content: center;

	/* 关键：原点下移，避免向上被裁 */
	transform-origin: 50% 62%;

	opacity: 1;
	transform: scale(1);
}

/* 静态暗压态（按住时） */
.is-down {
	opacity: 0.75;
}

/* 按下瞬间动画：保留你最初的 ease-out */
.press-down {
	animation-name: PressDown;
	animation-duration: 80ms;
	animation-timing-function: ease-out;
	animation-iteration-count: 1;
	animation-fill-mode: forwards; /* ✅ 改这里：保持最终态 */
}

/* 抬起回弹：保留你最初觉得“最好”的曲线 */
.press-up {
	animation-name: PressUp;
	animation-duration: 140ms;
	animation-timing-function: cubic-bezier(0.2, 0.8, 0.2, 1);
	animation-iteration-count: 1;
	animation-fill-mode: forwards;
}

@keyframes PressDown {
	0% {
		transform: scale(1);
		opacity: 1;
	}
	100% {
		transform: scale(0.92);
		opacity: 0.75;
	}
}

/* 132px 资源：峰值控制在 1.04，避免遮挡 */
@keyframes PressUp {
	0% {
		transform: scale(0.92);
		opacity: 0.75;
	}
	100% {
		transform: scale(1);
		opacity: 1;
	}
}

/* --- 媒体查询 --- */
@media screen and (shape: rect) {
	.controls {
		height: 208px;
		width: 380px;
	}
	.icon {
		margin-top: 0px;
	}
	.progress {
		width: 432px;
		height: 80px;
	}
	.footer-content {
		width: 90%;
		justify-content: space-around;
		align-items: center;
	}
	.footer-icon-down {
		margin-top: 0px;
	}
	.little-icon {
		position: absolute;
		top: 384px;
		left: 228px;
	}
	.lyrics-scroll-view {
		height: 424px;
	}
	.fullscreen-lyrics { height: 424px; }
	.is-current-wrapper {
		/* 【修改】使用固定颜色代替透明度 */
		background-color: #1a1a1a;
		border-radius: 24px;
	}
	/* 【【【新增】】】 确保方形屏幕下选中样式也生效 */
	.is-selected-wrapper {
		border-radius: 24px;
	}
	.lyrics-list-padding-top,
	.lyrics-list-padding-bottom {
		height: 190px;
	}
	/* 方形屏幕下字体也相应缩小 */
	.secondary-lyric {
		font-size: 24px;
	}
	.current-lyric {
		font-size: 26px;
	}
	.extra-lyric {
		font-size: 19px;
	}
}
@media screen and (shape: circle) {
	.song-name {
		width: 260px;
	}
}
</style>

<script>
import router from "@system.router";
import audio from "@system.audio";
import file from "@system.file";
import prompt from "@system.prompt";
import device from "@system.device";
import app from "@system.app";
import brightness from "@system.brightness";

import apiService from "../../services/api.js";
import {
  isCookedLyricFormat,
  cookLyricsFromRaw,
  makeFallbackCooked,
} from "../../utils/lyric_cook.js";

import throttle from "../../utils/throttle.js";

const CONSTANTS = {
	DIR_MUSIC: "internal://files/music/",
	DIR_LYRICS: "internal://files/lyrics/",
	FILE_PLAY_LIST: "internal://files/play_list.json",
	FILE_DOWNLOADED_SONGS: "internal://files/downloaded_songs.json",
	SETTINGS_FILE_URI: "internal://files/settings.json",
	COOKIE_FILE_URI: "internal://files/cookie.txt",
	FILE_PLAYER_STATE: "internal://files/player_state.json",
	MAX_PLAYBACK_RETRIES: 3,
	PLAY_TIMEOUT: 25000,
};

const REVERSE_DIRECTIONS = {
	left: "right",
	right: "left",
	up: "down",
	down: "up",
};

const fileService = {
	_promisify(fn, options) {
		return new Promise((resolve, reject) => {
			fn({
				...options,
				success: resolve,
				fail: (data, code) => reject({ data, code }),
			});
		});
	},
	async readJson(uri, defaultValue = null) {
		try {
			const data = await this._promisify(file.readText, { uri });
			return JSON.parse(data.text);
		} catch (e) {
			return defaultValue;
		}
	},
	async writeJson(uri, data) {
  try {
    await this._promisify(file.writeText, { uri, text: JSON.stringify(data) });
    return true;
  } catch (e) {
    throw e; // ✅ 让 .catch 生效
  }
}

};

export default {
	private: {
		playerState: {
			isPlaying: false,
			playDuration: 0,
			currentLyricIndex: -1, // 当前高亮行在原始lyrics数组中的索引
			lyricType: "chinese",
		},

		currSong: null,
		lyrics: [], // 原始歌词数据 (带time, original, translation等)

		// --- 核心优化数据结构 ---
		lyricLines: [],

		fullscreenLines: [],

		// 声明64个渲染管道
		lyricGroup0: [],
		lyricGroup1: [],
		lyricGroup2: [],
		lyricGroup3: [],
		lyricGroup4: [],
		lyricGroup5: [],
		lyricGroup6: [],
		lyricGroup7: [],
		lyricGroup8: [],
		lyricGroup9: [],
		lyricGroup10: [],
		lyricGroup11: [],
		lyricGroup12: [],
		lyricGroup13: [],
		lyricGroup14: [],
		lyricGroup15: [],
		lyricGroup16: [],
		lyricGroup17: [],
		lyricGroup18: [],
		lyricGroup19: [],
		lyricGroup20: [],
		lyricGroup21: [],
		lyricGroup22: [],
		lyricGroup23: [],
		lyricGroup24: [],
		lyricGroup25: [],
		lyricGroup26: [],
		lyricGroup27: [],
		lyricGroup28: [],
		lyricGroup29: [],
		lyricGroup30: [],
		lyricGroup31: [],
		lyricGroup32: [],
		lyricGroup33: [],
		lyricGroup34: [],
		lyricGroup35: [],
		lyricGroup36: [],
		lyricGroup37: [],
		lyricGroup38: [],
		lyricGroup39: [],
		lyricGroup40: [],
		lyricGroup41: [],
		lyricGroup42: [],
		lyricGroup43: [],
		lyricGroup44: [],
		lyricGroup45: [],
		lyricGroup46: [],
		lyricGroup47: [],
		lyricGroup48: [],
		lyricGroup49: [],
		lyricGroup50: [],
		lyricGroup51: [],
		lyricGroup52: [],
		lyricGroup53: [],
		lyricGroup54: [],
		lyricGroup55: [],
		lyricGroup56: [],
		lyricGroup57: [],
		lyricGroup58: [],
		lyricGroup59: [],
		lyricGroup60: [],
		lyricGroup61: [],
		lyricGroup62: [],
		lyricGroup63: [],

		_lyricReqId: 0,

		swiperCurrentIndex: 0, // DOM if 开关

		downloadedSongs: {},

		settings: {
			lyrics: {
				japaneseMode: "translation",
				cantoneseMode: "romaji",
				englishMode: "translation",
			},
			lyricRenderMode: "fullscreen", // "fullscreen" | "all"

			lyricAdvanceTime: 1.5,
			gestures: { left: "lyrics", right: "playlist", up: "none", down: "none" },
			audioQuality: { online: 64, download: 128 },
		},

		cookie: null,
		isDownloadingLocked: false,
		retryCount: 0,
		screenShape: "circle",
		playMode: 0,
		songBeingDownloaded: null,

		isFmMode: false,
		fmQueue: [],
		isFetchingFm: false,

		pendingSongId: null,
		playTimeoutId: null,
		needsRefresh: false,

		_lyricsScrollView: null,
		selectedLyricIndex: -1,
		selectionTimeoutId: null,
		_gestureToLyrics: null,
		isSliderDragging: false,

		prevBtnClass: "",
		prevBtnAnim: "",
		playBtnClass: "",
		playBtnAnim: "",
		nextBtnClass: "",
		nextBtnAnim: "",

		volumeBtnClass: "",
		volumeBtnAnim: "",
		downloadBtnClass: "",
		downloadBtnAnim: "",
		menuBtnClass: "",
		menuBtnAnim: "",
		_playBtnDown: false,

		// =========================
		// 【新增】最小增量：恢复进度用
		// -1 表示不需要恢复；>=0 表示下次播放需要seek到这里
		// =========================
		resumeTime: -1,

		// 封面异步回写防串歌
		_coverFetchToken: 0,
	},

	protected: {
		playList: [],
		currentIndex: 0,
		currentLyricIndex: -1,

		songId: null,
		songInfo: null,

		triggerDownload: false,
		triggerPlayModeToggle: false,
		startFmMode: false,
	},

	computed: {
		songName() {
			return this.currSong ? this.currSong.name : "未知歌曲";
		},
		songArtists() {
			return this.currSong ? this.currSong.artists : "未知艺术家";
		},
		playButtonIcon() {
			if (this.pendingSongId && !this.playerState.isPlaying)
				return "/common/icon/loading.png";
			return this.playerState.isPlaying
				? "/common/icon/pause.png"
				: "/common/icon/play.png";
		},
		progressCurrentTime() {
			return this.second2time(this.playerState.playDuration);
		},
		progressTotalTime() {
			const duration = this.currSong?.duration || 0;
			return this.second2time(duration);
		},
		downloadIcon() {
			const icons = {
				downloading: "/common/icon/waiting_icon.png",
				downloaded: "/common/icon/done_icon.png",
				not_downloaded: null,
			};
			if (!this.currSong) return icons.not_downloaded;
			if (
				this.songBeingDownloaded &&
				this.currSong.id === this.songBeingDownloaded.id
			)
				return icons.downloading;
			if (this.downloadedSongs[this.currSong.id]) return icons.downloaded;
			return icons.not_downloaded;
		},
		playModeIcon() {
			if (this.isFmMode) return "/common/icon/fm.png";
			const icons = [
				"/common/icon/loop.png",
				"/common/icon/single-loop.png",
				"/common/icon/random.png",
			];
			return icons[this.playMode] || icons[0];
		},
	},
	async onInit() {
		if (this.$app.$def.isActivated !== true) {
			prompt.showToast({
				message: "非法绕过，IP及设备信息已上传！",
				duration: 3000,
			});
			app.terminate();
			return;
		}

		this.$app.$def.runActivationFlow().then(async (ok) => {
			if (ok !== true || this.$app.$def.isActivated !== true) {
				prompt.showToast({
					message: "非法绕过，IP及设备信息已上传！",
					duration: 3000,
				});
				app.terminate();
				return;
			}

			console.log("Player onInit: 准备基础环境。");
			this.throttledSliderChange = throttle(this.applySliderChange, 50);

			this.bindAudioEvents();
			await this.loadSettings();
			await this.loadCookie();
			await this.loadDownloadedSongs();
			this.getDeviceInfo();
			await this.onRestoreState();
		});
	},

	onShow() {
		console.log("Player onShow: 页面显示，标记需要刷新。");
		this.needsRefresh = true;

		// 【优化】如果当前在歌词页，保持屏幕常亮
		if (this.swiperCurrentIndex === 1) {
			brightness.setKeepScreenOn({ keepScreenOn: true });
		}
	},

	async onRefresh(query) {
		const params = query || {};
		console.log("Player onRefresh with params:", JSON.stringify(params));

		if (this.needsRefresh) {
			console.log("onRefresh: 加载核心数据。");
			await this.loadDownloadedSongs();
			await this.loadListFromFile();
			this.needsRefresh = false;
		}

		if (params.triggerDownload) {
			this.initiateDownload();
			return;
		}
		if (params.startFmMode) {
			this.dostartFmMode(params.songId, params.songInfo);
			return;
		}
		if (params.triggerPlayModeToggle) {
			this.togglePlayMode();
		}

		if (params.songId) {
			if (!this.currSong || this.currSong.id != params.songId) {
				console.log(`onRefresh: 收到新歌指令 [${params.songId}]`);
				this.songId = params.songId;
				this.songInfo = params.songInfo ? JSON.parse(params.songInfo) : null;
				await this.startLogic();
			}
			return;
		}

		if (this.currSong) {
			const stillInPlaylist = this.playList.some(
				(song) => song.id === this.currSong.id
			);
			if (!stillInPlaylist) {
				prompt.showToast({ message: "当前歌曲已从列表中移除" });
				await this.change(1);
			}
		}
	},

	onDestroy() {
		console.log("Player onDestroy: 页面被销毁。");
		audio.stop();
		// 【优化】确保即使在下载中退出，也能尝试保存状态
		this.onSaveState();
		// 清理所有定时器
		if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
		// 如果有其他定时器也在这里清理
		brightness.setKeepScreenOn({ keepScreenOn: false }); // 关闭屏幕常亮
		console.log("播放器已销毁，状态已保存，资源已释放。");
	},

	onBackPress() {
		if (this.isDownloadingLocked) {
			prompt.showToast({ message: "正在下载，请勿退出" });
			return true;
		}
		this.onSaveState();
		// 优化提示，让用户知道如何真正退出
		prompt.showToast({ message: "顶栏右滑退出应用" });
		return true; // 返回 true 表示消费该事件，应用不会退出
	},

	pressDown(key) {
		// 清动画，保证可重复触发
		this[key + "Anim"] = "";
		// 进入静态暗压态
		this[key + "Class"] = "is-down";
		// 按下瞬间动画（可选，但手感更好）
		setTimeout(() => {
			this[key + "Anim"] = "press-down";
		}, 0);
	},

	pressRelease(key) {
		// 移除暗压态
		this[key + "Class"] = "";
		// 回弹动画一发
		this[key + "Anim"] = "";
		setTimeout(() => {
			this[key + "Anim"] = "press-up";
		}, 0);
	},

	pressCancel(key) {
		// 兜底复位（滑出 / touchcancel / 业务 return）
		this[key + "Class"] = "";
		this[key + "Anim"] = "";
	},
	onPlayBtnUp() {
		// 抬起：移除暗压态 + 跑回弹
		this._releasePlayBtnWithPop();
	},

	onPlayBtnClick() {
		// 点击：无论业务是否 return，都保证按钮恢复
		this._releasePlayBtnWithPop();
		// 再执行业务逻辑
		this.playOrPause();
	},
	_releasePlayBtnWithPop() {
		// 1) 先去掉暗压
		this.playBtnClass = "";

		// 2) 让回弹动画每次都能重播：先清空再 set
		this.playBtnAnim = "";
		setTimeout(() => {
			this.playBtnAnim = "press-up";
		}, 0);
	},

	async onRestoreState() {
		if (this.songId) return false;

		const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
		const isStateExpired = savedState?.timestamp
			? new Date().getTime() - savedState.timestamp > 12 * 3600 * 1000
			: true;

		if (
			savedState &&
			savedState.lastSongId &&
			savedState.duration &&
			!isStateExpired
		) {
			await this.loadListFromFile();
			const lastIndex = this.playList.findIndex(
				(song) => song && song.id === savedState.lastSongId
			);

			if (lastIndex > -1) {
				console.log(
					`onRestoreState: 恢复歌曲: ${this.playList[lastIndex].name}`
				);
				this.songId = savedState.lastSongId;
				this.currentIndex = lastIndex;
				this.playMode = savedState.playMode || 0;

				const id = String(savedState.lastSongId);
				const cachedCover = this.downloadedSongs?.[id]?.coverUrl || "";
				const stateCover = savedState.coverUrl
					? String(savedState.coverUrl)
					: "";
				const coverUrl = cachedCover || stateCover || "";

				this.currSong = {
					...this.playList[this.currentIndex],
					duration: savedState.duration,
					coverUrl,
				};

				const t = Number(savedState.lastPlayDuration) || 0;
				this.resumeTime = t > 0 ? t : -1;
				this.playerState.playDuration =
					this.resumeTime > 0 ? this.resumeTime : 0;
				this._pendingRestoreTime = this.resumeTime;

				this.fetchLyric(this.songId);

				// ✅ 同步给全局
				this.syncToGlobalPlayer();

				prompt.showToast({ message: "播放状态已恢复" });
				return true;
			}
		}
		return false;
	},

	// --- 交互与UI方法 ---
	handleHeaderSwipe(e) {
		const direction = e.direction; // 'left', 'right', 'up', 'down'
		if (direction === "right") {
			this.onSaveState();
			this.exit();
		}
	},
	handleSwipe(e) {
		const direction = e.direction; // 'left', 'right', 'up', 'down'

		// 【新增】如果正在拖动进度条，忽略滑动手势
		if (this.isSliderDragging) {
			console.log("进度条拖动中，忽略滑动手势");
			return;
		}

		// 场景一：当前在播放器主页 (封面页)
		if (this.swiperCurrentIndex === 0) {
			const action = this.settings.gestures[direction];

			if (action && action !== "none") {
				// 如果动作是切换到歌词页
				if (action === "lyrics") {
					// 记录下是哪个手势进入了歌词页
					this._gestureToLyrics = direction;
					this.switchToLyricsView();
				} else {
					// 执行其他通用操作
					this.executeGestureAction(action);
				}
			}
		}
		// 场景二：当前在歌词页
		else if (this.swiperCurrentIndex === 1) {
			// 检查当前滑动方向是否是进入歌词页手势的"相反方向"
			if (
				this._gestureToLyrics &&
				direction === REVERSE_DIRECTIONS[this._gestureToLyrics]
			) {
				this.switchToPlayerView();
			}
			//右滑也返回播放器主页
			else if (direction === "right") {
				this.switchToPlayerView();
			}
		}
	},

	// 辅助方法：执行通用手势操作 (不包括视图切换)
	executeGestureAction(action) {
		console.log(`执行手势操作: ${action}`);
		switch (action) {
			case "playlist":
				router.push({
					uri: "/pages/list",
					params: { listType: "playlist", targetSongId: this.currSong.id },
				});
				break;
			case "search":
				router.push({ uri: "/pages/search" });
				break;
			case "user":
				router.push({ uri: "/pages/user" });
				break;
			case "settings":
				router.push({ uri: "/pages/settings" });
				break;
			case "prev":
				this.change(-1);
				break;
			case "next":
				this.change(1);
				break;
			// 注意：'lyrics' 的处理已移至 handleSwipe 中
			default:
				console.log(`未知的自定义手势操作: ${action}`);
				break;
		}
	},
	getFullscreenLineCount() {
	// 先给一个稳定默认：方屏 7，圆屏 5
	// 你要 3 行的话，后面再把规则补进来（比如极小屏/某个开关）
	return this.screenShape === "rect" ? 7 : 5;
},

buildFullscreenLines() {
  const lines = this.lyricLines || [];
  const total = lines.length;

  if (!total) {
    this.fullscreenLines = [];
    this._fsKey = null;
    return;
  }

  const ps = this.playerState || {};
  const st = this.settings || {};
  const rawLyrics = this.lyrics || [];

  // 1) 当前索引
  let cur = typeof ps.currentLyricIndex === "number" ? ps.currentLyricIndex : -1;

  // 兜底：用播放时间算一个
  if (!(cur >= 0 && cur < total)) {
    const lookaheadTime = (ps.playDuration || 0) + (st.lyricAdvanceTime || 1.5);

    let newIndex = 0;
    let low = 0;
    let high = rawLyrics.length - 1;
    while (low <= high) {
      const mid = (low + high) >> 1;
      if (rawLyrics[mid].time > lookaheadTime) high = mid - 1;
      else {
        newIndex = mid;
        low = mid + 1;
      }
    }
    cur = newIndex;
  }

  // 2) hasExtra：只看当前行
  const extraText = this.getExtraLyricText(rawLyrics[cur]);
  const hasExtra = !!(extraText && String(extraText).trim());

  // 3) 行数：有 extra 5 行；无 extra 7 行（无 extra 不隐藏）
  const N = hasExtra ? 5 : 7;
  const half = N >> 1;

  // 4) 长度：只看 original（ASCII=1，非ASCII=2）
  const MID_MAX_LEN = 18;

  const textLen = (s) => {
    if (!s) return 0;
    let n = 0;
    for (let k = 0; k < s.length; k++) n += s.charCodeAt(k) <= 0x007f ? 1 : 2;
    return n;
  };

  const isLongOriginal = (o) => {
    if (!o) return false;
    const s = String(o).trim();
    if (!s) return false;
    // 快速剪枝
    if (s.length <= MID_MAX_LEN) return false;
    return textLen(s) > MID_MAX_LEN;
  };

  // fullscreen 行对象：最小集合
  const toFsLine = (src) => ({
    id: src && src.id ? String(src.id) : "",
    original: (src && src.original != null ? String(src.original) : "") || " ",
    extra: src && src.extra ? String(src.extra) : null,
    isCurrent: !!(src && src.isCurrent),
  });

  const makePad = (i) => ({
    id: `pad-${cur}-${i}`,
    original: " ", // 占位必须是空格，不要空字符串
    extra: null,
    isCurrent: false,
  });

  // 5) 隐藏规则（只在 hasExtra 时启用）
  let hideTop = false;
  let hideBottom = false;

  if (hasExtra) {
    let longCount = 0;
    let checked = 0;

    for (let i = -1; i <= 1; i++) {
      const idx = cur + i;
      if (idx < 0 || idx >= total) continue;

      const src = lines[idx];
      const o = src && src.original != null ? String(src.original) : "";
      const t = o.trim();
      if (!t) continue; // 空行不计入

      checked++;
      if (isLongOriginal(t)) longCount++;
    }

    if (checked === 0 || longCount === 0) {
      hideTop = false;
      hideBottom = false;
    } else if (checked === 3 && longCount === 3) {
      hideTop = true;
      hideBottom = true;
    } else {
      // 1~2 行过长（或 checked<3 但存在过长）→ 只隐藏上
      hideTop = true;
      hideBottom = false;
    }
  }

  // 6) 缓存 key：不变就不重建
  const fsKey = `${total}|${cur}|${hasExtra ? 1 : 0}|${hideTop ? 1 : 0}|${hideBottom ? 1 : 0}`;
  if (
    this._fsKey === fsKey &&
    Array.isArray(this.fullscreenLines) &&
    this.fullscreenLines.length === N
  ) {
    return;
  }
  this._fsKey = fsKey;

  // 7) 生成结果（无交互字段）
  const result = [];
  for (let i = -half; i <= half; i++) {
    if (hasExtra && i === -2 && hideTop) {
      result.push(makePad(i));
      continue;
    }
    if (hasExtra && i === 2 && hideBottom) {
      result.push(makePad(i));
      continue;
    }

    const idx = cur + i;
    if (idx >= 0 && idx < total) result.push(toFsLine(lines[idx]));
    else result.push(makePad(i));
  }

  this.fullscreenLines = result;
},


	distributeLyricsToGroups() {
		const NUM_GROUPS = 64;

		for (let i = 0; i < NUM_GROUPS; i++) this[`lyricGroup${i}`] = [];

		const lines = this.lyricLines; // 原始数组只读使用
		const total = lines ? lines.length : 0;
		if (!total) {
			this._lyricGroupMeta = [];
			return;
		}

		const base = Math.floor(total / NUM_GROUPS);
		const remainder = total % NUM_GROUPS;

		this._lyricGroupMeta = new Array(NUM_GROUPS);

		let cursor = 0;
		for (let g = 0; g < NUM_GROUPS; g++) {
			const count = base + (g < remainder ? 1 : 0);
			const start = cursor;
			const end = cursor + count - 1;

			// slice：不修改 lyricLines；只创建 group 的数组“壳”
			this[`lyricGroup${g}`] =
				count > 0 ? lines.slice(cursor, cursor + count) : [];
			cursor += count;

			this._lyricGroupMeta[g] = { start, end, count };
		}
	},

	getLyricGroupIndex(lyricIndex) {
		const meta = this._lyricGroupMeta;
		if (!meta || meta.length !== 64 || lyricIndex < 0) return -1;

		let lo = 0,
			hi = meta.length - 1;
		while (lo <= hi) {
			const mid = (lo + hi) >> 1;
			const m = meta[mid];
			if (!m || m.count <= 0) return -1;

			if (lyricIndex < m.start) hi = mid - 1;
			else if (lyricIndex > m.end) lo = mid + 1;
			else return mid;
		}
		return -1;
	},

	refreshLyricGroupsByIndex(indices) {
		if (!indices || !indices.length) return;

		const touched = new Set();
		for (let i = 0; i < indices.length; i++) {
			const g = this.getLyricGroupIndex(indices[i]);
			if (g >= 0) touched.add(g);
		}

		touched.forEach((g) => {
			const key = `lyricGroup${g}`;
			const arr = this[key];
			// 只重建该组数组引用，触发该组 DOM 刷新；不动 lyricLines
			this[key] = arr ? arr.slice() : [];
		});
	},

	/**
	 * [规范化] 3. 状态重置：切歌或重置播放器时调用
	 * - 职责：清空所有与歌词相关的数据状态。
	 */
resetLyrics() {
	this.lyrics = [];
	this.lyricLines = [];
	this.fullscreenLines = [];
	this.playerState.currentLyricIndex = -1;
	this.selectedLyricIndex = -1;

	for (let i = 0; i < 64; i++) {
		this[`lyricGroup${i}`] = [];
	}
	this._lyricGroupMeta = [];

	if (this.selectionTimeoutId) {
		clearTimeout(this.selectionTimeoutId);
		this.selectionTimeoutId = null;
	}
},


// updateLyric：加 fullscreen 分流（保留你原来的二分和状态更新逻辑）
updateLyric() {
	if (this.swiperCurrentIndex !== 1) return;
	if (!this.lyrics || this.lyrics.length === 0) return;
	if (!this.lyricLines || this.lyricLines.length !== this.lyrics.length) return;

	const mode = (this.settings && this.settings.lyricRenderMode) || "fullscreen";

	const lookaheadTime =
		this.playerState.playDuration + (this.settings.lyricAdvanceTime || 1.5);
	const oldIndex = this.playerState.currentLyricIndex;

	let newIndex = 0;
	let low = 0;
	let high = this.lyrics.length - 1;
	while (low <= high) {
		const mid = Math.floor((low + high) / 2);
		if (this.lyrics[mid].time > lookaheadTime) {
			high = mid - 1;
		} else {
			newIndex = mid;
			low = mid + 1;
		}
	}

	if (newIndex === oldIndex) return;

	if (oldIndex >= 0) {
	this.lyricLines[oldIndex].isCurrent = false;
}
if (newIndex >= 0) {
	this.lyricLines[newIndex].isCurrent = true;
	// 可选：如果你担心设置项变化导致 extra 需要刷新，就保留这一句
	this.lyricLines[newIndex].extra =
		this.getExtraLyricText(this.lyrics[newIndex]) || null;
}


	this.playerState.currentLyricIndex = newIndex;

	if (mode === "fullscreen") {
		this.buildFullscreenLines();
		return;
	}

	this.refreshLyricGroupsByIndex([oldIndex, newIndex]);
	this.$nextTick(() => {
		this.scrollToCurrentLyric();
	});
},


	/**
	 * [最终修正] 歌词行点击事件
	 * - 修正双击跳转逻辑，避免刷新冲突。
	 */
	onLyricLineClick(line, originalIndex) {
		const index = originalIndex;

		if (this.selectedLyricIndex !== index) {
			// 首次点击
			if (this.playerState.isPlaying) {
				audio.pause();
			}

			this.clearSelectionTimeout();
			this.updateLyricSelection(this.selectedLyricIndex, false);
			this.selectedLyricIndex = index;
			this.updateLyricSelection(index, true);

			this.startSelectionTimeout();
			prompt.showToast({ message: `已暂停，再次点击跳转`, duration: 200 });
		} else {
			// 第二次点击 (确认跳转)
			this.clearSelectionTimeout();

			// 二次点击确认跳转：清选中 + 只刷新该行所在 group（防止选中框残留）
			if (this.selectedLyricIndex !== -1) {
				const prevSel = this.selectedLyricIndex;
				this.lyricLines[prevSel].isSelected = false;
				this.selectedLyricIndex = -1;

				// 只刷受影响 group：保证选中态立即从 UI 消失
				this.refreshLyricGroupsByIndex([prevSel]);
			}

			// 跳转并播放
			const targetTime = this.lyrics[index].time;
			audio.currentTime = targetTime;
			audio.play();
			prompt.showToast({
				message: `已跳转到 ${this.second2time(targetTime)}`,
				duration: 200,
			});

			// updateLyric() 会计算新的高亮行，并触发一次完整的、正确的UI刷新。
			this.updateLyric();
			this.$nextTick(() => this.scrollToCurrentLyric(true));
		}
	},

	/**
	 * [最终修正] 重置选中状态 (例如在2秒超时后调用)
	 * - 这个函数现在只负责在需要明确取消选中框时，才触发UI刷新。
	 */
	resetLyricSelection() {
		if (this.selectedLyricIndex !== -1) {
			// 调用 updateLyricSelection 来确保UI上的选中框被移除
			this.updateLyricSelection(this.selectedLyricIndex, false);
			this.selectedLyricIndex = -1;
		}
	},

	updateLyricSelection(index, isSelected) {
		if (index < 0 || index >= this.lyricLines.length) return;

		const line = this.lyricLines[index];
		if (line && line.isSelected !== isSelected) {
			line.isSelected = isSelected;
			// 只刷新该行所在 group
			this.refreshLyricGroupsByIndex([index]);
		}
	},

	// 视图切换函数保持不变，但调用时机已由 handleSwipe 控制
	switchToLyricsView() {
		if (this.swiperCurrentIndex === 1) return;
		console.log("显示歌词视图");

		// 1) 强制复位所有按钮暗压 / 动画
		this.resetAllPressStates();

		// 2) 退出沉浸（理论上在播放器页不该有，但兜底）
		this.exitImmersiveIfNeeded();

		// 3) 切换视图
		this.swiperCurrentIndex = 1;

		// 4) 开启常亮（防御式）
		try {
			if (brightness && typeof brightness.setKeepScreenOn === "function") {
				brightness.setKeepScreenOn({ keepScreenOn: true });
			}
		} catch (e) {
			console.log("setKeepScreenOn(true) fail:", e);
		}

		// 5) 歌词滚动对齐
		this.$nextTick(() => {
			if (!this._lyricsScrollView) {
				this._lyricsScrollView = this.$element("lyricsScrollView");
			}
			this.scrollToCurrentLyric(true);
		});
	},
	/**
	 * 【【【逻辑修正】】】
	 * 滑回播放器页面时的处理
	 */
	switchToPlayerView() {
		if (this.swiperCurrentIndex === 0) return;
		console.log("显示播放器视图");

		// 1) 复位所有按钮暗压 / 动画
		this.resetAllPressStates();

		// 2) 退出沉浸模式（如果在歌词页点了当前行）
		this.exitImmersiveIfNeeded();

		// 3) 切换视图
		this.swiperCurrentIndex = 0;

		// 4) 关闭常亮（防御式）
		try {
			if (brightness && typeof brightness.setKeepScreenOn === "function") {
				brightness.setKeepScreenOn({ keepScreenOn: false });
			}
		} catch (e) {
			console.log("setKeepScreenOn(false) fail:", e);
		}

		// 5) 如果存在一个待处理的选中操作：无条件恢复播放 + 清选中
		if (this.selectedLyricIndex !== -1) {
			this.clearSelectionTimeout();
			audio.play(); // 【关键】无条件继续播放
			this.resetLyricSelection();
		}
	},

	resetAllPressStates() {
		const keys = ["prevBtn", "playBtn", "nextBtn"];
		for (const key of keys) {
			const cls = key + "Class";
			const anim = key + "Anim";
			if (this.hasOwnProperty(cls)) this[cls] = "";
			if (this.hasOwnProperty(anim)) this[anim] = "";
		}
	},

	exitImmersiveIfNeeded() {
		if (!this.isImmersive) return;
		this.isImmersive = false;
		if (this._stopImmersiveTick) this._stopImmersiveTick();
	},

	/**
	 * 启动2秒后自动取消选中的定时器
	 */
	startSelectionTimeout() {
		this.selectionTimeoutId = setTimeout(() => {
			prompt.showToast({ message: "选中已取消", duration: 200 });

			// 【关键】无条件继续播放
			audio.play();

			this.resetLyricSelection();
		}, 2000);
	},

	/**
	 * 【【【逻辑修正】】】
	 * 清除定时器，但不改变播放状态
	 */
	clearSelectionTimeout() {
		if (this.selectionTimeoutId) {
			clearTimeout(this.selectionTimeoutId);
			this.selectionTimeoutId = null;
		}
	},

	getDeviceInfo() {
		device.getInfo({
			success: (data) => {
				if (data.screenShape) this.screenShape = data.screenShape;
			},
			fail: (data, code) => console.error(`获取设备信息失败, code = ${code}`),
		});
	},
	async onSaveState() {
		if (!this.currSong || !this.currSong.duration) return;

		const stateToSave = {
			lastSongId: this.currSong.id,
			lastPlayDuration: this.playerState.playDuration,
			playMode: this.playMode,
			duration: this.currSong.duration,

			// ✅ 新增：封面缓存后的本地/远程URL（你现在用的是 currSong.coverUrl）
			coverUrl: this.currSong.coverUrl ? String(this.currSong.coverUrl) : "",

			timestamp: new Date().getTime(),
		};

		await fileService.writeJson(CONSTANTS.FILE_PLAYER_STATE, stateToSave);
	},

	playOrPause() {
		if (!this.currSong) {
			// 如果还没选中歌，先加载第一首（不播），再由用户再次点击播放
			if (this.playList && this.playList.length > 0) {
				this.currentIndex = 0;
				this.loadCurrentOnly();
			}
			prompt.showToast({ message: "没有可播放的歌曲" });
			return;
		}

		// 用户主动播放：如果没有 src，直接走 playCurrent（会 startPlayback）
		if (!audio.src) {
			this.playCurrent();
			return;
		}

		if (!this.isChangingSong) {
			this.playerState.isPlaying ? audio.pause() : audio.play();
		}
	},

	applySliderChange(progress) {
		if (this._restoreSeeking) return;

		const now = Date.now();
		if (this._ignoreSliderUntilTs && now < this._ignoreSliderUntilTs) return;

		const p = Number(progress);
		if (!isFinite(p) || p < 0) return;

		const dur =
			this.currSong && typeof this.currSong.duration === "number"
				? this.currSong.duration
				: 0;
		if (!(dur > 0)) return;

		const target = Math.max(0, Math.min(p, dur - 0.2));
		const cur = Number(audio.currentTime) || 0;
		if (Math.abs(cur - target) < 0.25) return;

		audio.currentTime = target;
		this.playerState.playDuration = target;
		this.updateLyric();
	},

	onSliderChange(e) {
		if (!e || e.isFromUser !== true) return;
		this.throttledSliderChange(e.progress);
	},

	goToSongActions() {
		if (!this.currSong) {
			prompt.showToast({ message: "当前无播放歌曲" });
			return;
		}

		// 等待按钮 press-up 动画完成再跳转（克制延迟）
		clearTimeout(this._navDelayTimer);
		this._navDelayTimer = setTimeout(() => {
			router.push({
				uri: "/pages/volume",
				params: {
					currentSong: JSON.stringify(this.currSong),
					screenShape: this.screenShape,
					playMode: this.playMode,
					isFmMode: this.isFmMode,
				},
			});
		}, 140); // 和 press-up 动画时长对齐
	},

	togglePlayMode() {
		if (this.isFmMode) {
			prompt.showDialog({
				title: "退出私人FM",
				message: "您确定要退出私人FM吗？将会停止当前播放并返回常规列表模式。",
				buttons: [{ text: "取消" }, { text: "确定退出", color: "#FF453A" }],
				success: async () => {
					prompt.showToast({ message: "正在退出私人FM..." });
					this.isFmMode = false;
					this.fmQueue = [];
					this.resetPlayer();
					try {
						await this.startLogic();
						prompt.showToast({ message: "已返回列表播放模式" });
					} catch (error) {
						prompt.showToast({ message: "播放列表为空" });
					}
				},
				cancel: () => prompt.showToast({ message: "操作已取消" }),
			});
			return;
		}
		this.playMode = (this.playMode + 1) % 3;
		const modeText = ["列表循环", "单曲循环", "随机播放"];
		prompt.showToast({ message: modeText[this.playMode] });
		if (this.playMode === 2 && this.playList.length > 0)
			this.generateShuffledList(true);
	},
	goToMenu() {
		if (this.isDownloadingLocked) {
			prompt.showToast({ message: "正在下载，请稍后" });
			return;
		}

		if (this.isFmMode) {
			prompt.showToast({ message: "当前处于FM模式！打开过多页面将导致中断！" });
			// 不 return，和你原逻辑一致
		}
		router.push({ uri: "/pages/menu" });
	},

	exit() {
		app.terminate();
	},

	// --- 下载逻辑 (已重构并使用闭包管理周期性提示) ---
	initiateDownload() {
		// 1. 前置检查 (保持不变)
		if (
			typeof this.downloadedSongs !== "object" ||
			this.downloadedSongs === null
		) {
			prompt.showToast({ message: "下载列表未准备好，请稍后重试" });
			this.loadDownloadedSongs();
			return;
		}
		if (!this.currSong) {
			prompt.showToast({ message: "歌曲信息无效，无法下载" });
			return;
		}
		if (this.downloadedSongs[this.currSong.id]) {
			prompt.showToast({ message: "歌曲已下载" });
			return;
		}
		if (this.isDownloadingLocked) {
			prompt.showToast({ message: "已有任务在下载中" });
			return;
		}

		// 2. 【【【核心】】】在方法作用域顶部声明一个变量，用于存储定时器ID
		let downloadToastTimer = null;

		// 3. 初始提示
		prompt.showToast({ message: `开始准备下载: ${this.currSong.name}` });

		// 4. 调用下载服务
		this.$app.$def.downloadService.start(
			this.currSong,
			{
				cookie: this.cookie,
				downloadBitrate: this.settings.audioQuality.download,
			},

			{
				onStart: (song) => {
					this.isDownloadingLocked = true;
					this.songBeingDownloaded = { ...song };

					// 【【【核心】】】创建定时器，并将其ID赋值给外部作用域的变量
					downloadToastTimer = setInterval(() => {
						if (this.songBeingDownloaded) {
							prompt.showToast({ message: `下载中`, duration: 500 });
						}
					}, 3000);
				},

				onSuccess: async (downloadedInfo) => {
					// ... (成功逻辑保持不变)
					try {
						const updatedSongs = {
							...this.downloadedSongs,
							[downloadedInfo.id]: downloadedInfo,
						};
						await fileService.writeJson(
							CONSTANTS.FILE_DOWNLOADED_SONGS,
							updatedSongs
						);
						this.downloadedSongs = updatedSongs;
						prompt.showToast({
							message: `${downloadedInfo.name} 下载并记录成功`,
							duration: 5000,
						});
					} catch (error) {
						console.error("写入下载记录失败:", error);
						prompt.showToast({
							message: `歌曲已下载，但保存记录失败: ${error.message}`,
						});
					}
				},

				onError: (errorMessage) => {
					// ... (失败逻辑保持不变)
					prompt.showToast({ message: `下载失败: ${errorMessage}` });
				},

				onFinish: () => {
					// 【【【核心】】】
					// onFinish 回调作为闭包，可以访问并清除在外部作用域中声明的 downloadToastTimer
					if (downloadToastTimer) {
						clearInterval(downloadToastTimer);
						console.log("下载提示定时器已清除。");
					}

					this.isDownloadingLocked = false;
					this.songBeingDownloaded = null;
				},
			}
		);
	},

	/**
	 * 【核心修正】: startLogic 不再处理恢复逻辑，职责更单一
	 */
	async startLogic() {
		// 【移除】所有与 wasRestored 相关的逻辑

		if (!this.songId) {
			await this.loadListFromFile();
			if (this.playList && this.playList.length > 0) {
				this.currentIndex = 0;

				// 没有正在播放歌曲：只加载第一首，不播放
				// 判定依据：没有 src 或者当前未处于播放态
				const noActivePlayback = !audio.src || !this.playerState.isPlaying;
				if (noActivePlayback) {
					this.loadCurrentOnly();
				} else {
					this.playCurrent();
				}
			} else {
				prompt.showToast({ message: "播放列表为空" });
			}
			return;
		}

		await this.loadListFromFile();
		const index = this.playList.findIndex(
			(item) => item && String(item.id) === String(this.songId)
		);

		if (index !== -1) {
			this.currentIndex = index;
		} else {
			if (this.songInfo && this.songInfo.id) {
				this.playList.unshift(this.songInfo);
				this.currentIndex = 0;
				await fileService.writeJson(CONSTANTS.FILE_PLAY_LIST, this.playList);
			} else {
				this.currentIndex = 0;
			}
		}

		if (this.playList.length > 0) {
			this.playCurrent();
		}
	},
	async playCurrent() {
		let songToPlay;
		if (this.isFmMode) {
			if (this.fmQueue.length === 0) {
				await this.fetchNextFmSongs();
				if (this.fmQueue.length === 0) {
					this.resetPlayer();
					return;
				}
			}
			songToPlay = this.fmQueue[0];
		} else {
			if (!this.playList || this.playList.length === 0) {
				this.resetPlayer();
				return;
			}
			songToPlay = this.playList[this.currentIndex];
		}

		if (!songToPlay) {
			this.handlePlaybackError("无效的歌曲数据");
			return;
		}
		if (this.pendingSongId === songToPlay.id) return;
		this.pendingSongId = songToPlay.id;

		// ✅ 只有“切到新歌”才更新 UI / 重建歌词
		const shouldRefreshUi =
			!this.currSong || this.currSong.id !== songToPlay.id;
		if (shouldRefreshUi) {
			this.updateUiForNewSong(songToPlay);
		}

		this.onSaveState();
		this.startPlaybackTimeout();

		try {
			const downloadedInfo = this.downloadedSongs[songToPlay.id];
			if (downloadedInfo?.localUri)
				await this.playLocal(songToPlay, downloadedInfo);
			else await this.playOnline(songToPlay);

			// ✅ 只有成功后才消费 FM 队列
			if (this.isFmMode) this.fmQueue.shift();
		} catch (error) {
			this.handlePlaybackError(error.message || "播放准备失败");
		}
	},

	loadCurrentOnly() {
		// 仅设置当前歌曲与UI，不触发播放
		let songToLoad = null;

		if (this.isFmMode) {
			// FM 模式没有“列表第一首不播放”的意义；这里按你需求做保护
			if (!this.fmQueue || this.fmQueue.length === 0) return;
			songToLoad = this.fmQueue[0];
		} else {
			if (!this.playList || this.playList.length === 0) return;
			songToLoad = this.playList[this.currentIndex] || this.playList[0];
			if (!songToLoad) return;
			// 兜底：如果 currentIndex 越界
			this.currentIndex = this.playList.findIndex(
				(s) => s && s.id === songToLoad.id
			);
			if (this.currentIndex < 0) this.currentIndex = 0;
		}

		// 清理播放相关状态，但保留 UI
		audio.stop();
		this.pendingSongId = null;
		if (this.playTimeoutId) {
			clearTimeout(this.playTimeoutId);
			this.playTimeoutId = null;
		}

		// 关键：只更新 UI，不 startPlayback
		this.updateUiForNewSong(songToLoad);

		// 明确状态为未播放
		this.playerState.isPlaying = false;
		this.playerState.playDuration = 0;

		// 注意：updateUiForNewSong 里已经 fetchLyric 了
	},

	updateUiForNewSong(song) {
	audio.stop();

	// 1) 先写基础信息
	if (!this.currSong) this.currSong = { ...song, duration: 0 };
	else {
		this.currSong.id = song.id;
		this.currSong.name = song.name;
		this.currSong.artists = song.artists;
		this.currSong.duration = 0;
	}

	// 2) 关键：新歌封面先清空（绝不沿用上一首）
	this.currSong.coverUrl = "";

	// 3) 立刻同步一次：全局先拿到“当前歌已切换”
	this.syncToGlobalPlayer();

	// 4) 恢复进度逻辑（保留你的行为）
	if (this.resumeTime < 0) {
		this.playerState.playDuration = 0;
	} else {
		this.playerState.playDuration = this.resumeTime;
		this._pendingRestoreTime = this.resumeTime;
	}

	// 5) 歌词：只调用 fetchLyric（它内部会 reset + gate）
	this.fetchLyric(song.id);

	// 6) 拿封面：回来后再同步一次（防止切歌快导致串台）
	const requestSongId = String(song.id);

	apiService
		.getSongCoverUrl(song.id, 96, this.cookie)
		.then((coverUrl) => {
			if (!this.currSong || String(this.currSong.id) !== requestSongId) return;

			if (coverUrl) this.currSong.coverUrl = coverUrl;
			this.syncToGlobalPlayer();
		})
		.catch(() => {});
},


	startPlaybackTimeout() {
		if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
		this.playTimeoutId = setTimeout(() => {
			console.error("!!! PLAYBACK TIMEOUT !!!");
			prompt.showToast({ message: "播放超时，请重试" });
			this.pendingSongId = null;
			this.playTimeoutId = null;
			this.resetPlayer();
		}, CONSTANTS.PLAY_TIMEOUT);
	},
	async playLocal(song, downloadedInfo) {
		return new Promise((resolve, reject) => {
			file.access({
				uri: downloadedInfo.localUri,
				success: () => {
					this.startPlayback(
						{ ...song, ...downloadedInfo },
						downloadedInfo.localUri
					);
					this.fetchLyric(song.id);
					resolve();
				},
				fail: () => {
					prompt.showToast({ message: "本地文件失效，转为在线播放" });
					this.playOnline(song).then(resolve).catch(reject);
				},
			});
		});
	},
	async playOnline(song) {
		this.isEnding = false;
		try {
			const songInfo = await apiService.getSongPlaybackInfo(
				song.id,
				this.settings.audioQuality.online,
				this.cookie
			);
			const fullSongInfo = {
				...song,
				playUrl: songInfo.url,
				duration: songInfo.duration,
			};
			this.startPlayback(fullSongInfo, songInfo.url);
		} catch (error) {
			console.error("playOnline 失败:", error);
			throw error;
		}
	},
	startPlayback(songWithDuration, src) {
		if (!src || typeof src !== "string") {
			this.handlePlaybackError("无效的播放源");
			return;
		}

		if (this.currSong && songWithDuration && songWithDuration.duration) {
			this.currSong.duration = songWithDuration.duration;
		}

		this.retryCount = 0;

		// 启动前 stop 没问题
		audio.stop();
		audio.src = src;

		// 如果存在待恢复时间：进入恢复期（屏蔽 timeupdate/slider 的抢写）
		if (
			typeof this._pendingRestoreTime === "number" &&
			this._pendingRestoreTime > 0
		) {
			this._restoreSeeking = true;
			const now = Date.now();
			this._ignoreTimeupdateUntilTs = now + 2500; // 覆盖启动阶段的 timeupdate=0
			this._ignoreSliderUntilTs = now + 2500; // 覆盖启动阶段 slider 回写
		}

		audio.play();
	},

	seekOnce(t) {
		const target0 = Number(t) || 0;
		if (target0 <= 0) {
			this._restoreSeeking = false;
			return;
		}

		// 恢复期：先锁住
		this._restoreSeeking = true;

		const armIgnoreWindows = (ms) => {
			const now = Date.now();
			this._ignoreTimeupdateUntilTs = Math.max(
				this._ignoreTimeupdateUntilTs || 0,
				now + ms
			);
			this._ignoreSliderUntilTs = Math.max(
				this._ignoreSliderUntilTs || 0,
				now + ms
			);
		};

		armIgnoreWindows(1800);

		let tries = 0;
		const maxTries = 10;

		const finish = () => {
			// 延迟释放：避免 seek 后立刻 timeupdate=0 或 slider 回写造成闪动
			setTimeout(() => {
				this._restoreSeeking = false;
				armIgnoreWindows(400);
			}, 600);
		};

		const attempt = () => {
			tries++;
			audio.getPlayState({
				success: (st) => {
					const dur = st && typeof st.duration === "number" ? st.duration : 0;
					const ok = st && (st.state === "play" || st.state === "pause");

					if (ok && dur > 0) {
						const target = Math.max(0, Math.min(target0, dur - 0.2));

						// 如果已经非常接近，就不重复 seek
						const cur = Number(audio.currentTime) || 0;
						if (Math.abs(cur - target) > 0.25) {
							audio.currentTime = target;
						}

						// UI 固定到目标值（不等 timeupdate）
						this.playerState.playDuration = target;
						this.updateLyric();

						finish();
						return;
					}

					if (tries < maxTries) setTimeout(attempt, 120);
					else finish();
				},
				fail: () => {
					if (tries < maxTries) setTimeout(attempt, 120);
					else finish();
				},
			});
		};

		attempt();
	},

	change(dir) {
		if (this.pendingSongId) {
			prompt.showToast({ message: "正在切歌..." });
			return;
		}
		if (this.isFmMode) {
			if (dir < 0) {
				prompt.showToast({ message: "私人FM不支持上一首哦" });
				return;
			}
			this.playCurrent();
			return;
		}
		if (!this.playList || this.playList.length === 0) return;
		switch (this.playMode) {
			case 0:
			case 1:
				this.currentIndex =
					(this.currentIndex + dir + this.playList.length) %
					this.playList.length;
				break;
			case 2:
				if (
					!this.shuffledPlayList ||
					this.shuffledPlayList.length !== this.playList.length
				)
					this.generateShuffledList(false);
				this.shuffledIndex =
					(this.shuffledIndex + dir + this.shuffledPlayList.length) %
					this.shuffledPlayList.length;
				this.currentIndex = this.shuffledPlayList[this.shuffledIndex];
				break;
		}
		this.playCurrent();
	},

	generateShuffledList(locateCurrent = true) {
		console.log("生成新的随机播放列表...");
		this.shuffledPlayList = Array.from(this.playList.keys());

		for (let i = this.shuffledPlayList.length - 1; i > 0; i--) {
			const j = Math.floor(Math.random() * (i + 1));
			[this.shuffledPlayList[i], this.shuffledPlayList[j]] = [
				this.shuffledPlayList[j],
				this.shuffledPlayList[i],
			];
		}

		if (locateCurrent) {
			const currentShuffledIndex = this.shuffledPlayList.indexOf(
				this.currentIndex
			);
			this.shuffledIndex =
				currentShuffledIndex !== -1 ? currentShuffledIndex : 0;
		}
		console.log("随机列表已生成, 当前随机索引:", this.shuffledIndex);
	},

	// --- FM 模式逻辑 (已重构) ---
	async dostartFmMode(initialSongId = null, initialSongInfo = null) {
		if (this.isFetchingFm) return;

		this.isFmMode = true;
		this.isFetchingFm = true;
		this.playList = [];
		this.fmQueue = [];
		audio.stop();
		prompt.showToast({ message: "正在开启私人FM..." });

		if (initialSongId && initialSongInfo) {
			try {
				this.fmQueue.push(JSON.parse(initialSongInfo));
			} catch (e) {
				console.error("解析FM初始歌曲信息失败");
			}
		}

		try {
			await this.fetchNextFmSongs();
			if (this.fmQueue.length > 0) this.playCurrent();
			else {
				prompt.showToast({ message: "无法获取FM歌曲，请检查网络" });
				this.isFmMode = false;
			}
		} catch (error) {
			prompt.showToast({ message: "启动FM失败" });
			this.isFmMode = false;
		} finally {
			this.isFetchingFm = false;
		}
	},
	async fetchNextFmSongs() {
		if (this.isFetchingFm) return;
		this.isFetchingFm = true;
		console.log("正在获取新的FM歌曲...");
		try {
			const newSongs = await apiService.getPersonalFmSongs(this.cookie);
			if (newSongs.length > 0) {
				this.fmQueue.push(...newSongs);
				console.log(
					`成功获取 ${newSongs.length} 首FM歌曲，当前队列长度: ${this.fmQueue.length}`
				);
			} else {
				prompt.showToast({ message: "没有更多FM推荐了" });
			}
		} catch (error) {
			console.error("获取FM歌曲失败:", error);
			prompt.showToast({ message: "获取新歌失败" });
		} finally {
			this.isFetchingFm = false;
		}
	},
// 【【【进阶优化：更可靠的缓存检查 + cooked格式迁移】】】
fetchLyric(songId) {
	// ✅ 每次请求生成 token；任何旧回调只要 token 不一致，直接作废
	const reqId = (this._lyricReqId = (this._lyricReqId || 0) + 1);
	const songIdStr = String(songId);

	// ✅ 只在这里 reset，别在 updateUiForNewSong 再 reset 一遍
	this.resetLyrics();

	const lyricFilePath = `${CONSTANTS.DIR_LYRICS}${songId}.json`;
	const downloadedInfo = this.downloadedSongs && this.downloadedSongs[songId];
	const finalLyricPath = downloadedInfo?.localLyricUri || lyricFilePath;

	file.access({
		uri: finalLyricPath,
		success: () => {
			// ✅ gate：只允许最新请求 + 当前歌
			if (reqId !== this._lyricReqId) return;
			if (!this._isCurrentSong(songIdStr)) return;

			console.log(`发现本地歌词缓存: ${finalLyricPath}`);
			this.loadLyricFromFile(finalLyricPath, songId, reqId);
		},
		fail: () => {
			if (reqId !== this._lyricReqId) return;
			if (!this._isCurrentSong(songIdStr)) return;

			console.log(`本地无歌词缓存，从网络获取: ${songId}`);
			this.fetchLyricOnline(songId, reqId);
		},
	});
},

loadLyricFromFile(uri, songId, reqId = this._lyricReqId) {
	const songIdStr = String(songId);

	file.readText({
		uri,
		success: (data) => {
			// ✅ gate：只允许最新请求 + 当前歌
			if (reqId !== this._lyricReqId) return;
			if (!this._isCurrentSong(songIdStr)) return;

			try {
				const obj = JSON.parse(data.text);

				// ✅ 1) cooked 直接用
				if (isCookedLyricFormat(obj)) {
					this.applyCookedLyrics(obj);
					return;
				}

				// ✅ 2) raw → cooked
				const cooked = cookLyricsFromRaw(obj, songId);

				// 覆写升级（不阻塞；写失败不影响本次使用）
				fileService
					.writeJson(uri, cooked)
					.then(() => console.log(`歌词缓存已升级为 cooked: ${songId}.json`))
					.catch((err) =>
						console.error(`歌词升级写入失败: ${err?.message || err}`)
					);

				this.applyCookedLyrics(cooked);
			} catch (e) {
				// 文件损坏/格式异常：走在线获取
				console.error("本地歌词解析失败，转在线获取:", e);

				if (reqId !== this._lyricReqId) return;
				if (!this._isCurrentSong(songIdStr)) return;

				this.fetchLyricOnline(songId, reqId);
			}
		},
		fail: () => {
			if (reqId !== this._lyricReqId) return;
			if (!this._isCurrentSong(songIdStr)) return;

			this.fetchLyricOnline(songId, reqId);
		},
	});
},

// 【【【核心修改：网络获取后只缓存 cooked】】】
async fetchLyricOnline(songId, reqId = this._lyricReqId) {
	const songIdStr = String(songId);
	const lyricFilePath = `${CONSTANTS.DIR_LYRICS}${songId}.json`;

	try {
		const raw = await apiService.getLyricData(songId, this.cookie);

		// ✅ gate：网络回来后再判断是否还是当前歌 + 最新请求
		if (reqId !== this._lyricReqId) return;
		if (!this._isCurrentSong(songIdStr)) return;

		// ✅ raw 校验：失败明确显示“加载失败”，不要混成“暂无歌词”
		if (!raw || typeof raw !== "object" || (raw.code != null && raw.code !== 200)) {
			const cookedFail = makeFallbackCooked(songId, "歌词加载失败");
			this.applyCookedLyrics(cookedFail);
			return;
		}

		// raw → cooked
		const cooked = cookLyricsFromRaw(raw, songId);

		// ✅ 异步写入 cooked（失败不影响本次渲染）
		fileService
			.writeJson(lyricFilePath, cooked)
			.then(() => console.log(`歌词 cooked 缓存成功: ${songId}.json`))
			.catch((err) => console.error(`歌词 cooked 写入失败: ${err?.message || err}`));

		// 立即应用
		this.applyCookedLyrics(cooked);
	} catch (error) {
		// gate：catch 也要防串歌
		if (reqId !== this._lyricReqId) return;
		if (!this._isCurrentSong(songIdStr)) return;

		console.error("在线获取歌词失败:", error);
		this.applyCookedLyrics(makeFallbackCooked(songId, "歌词加载失败"));
	}
},


// ✅ cooked → 内存运行态（仍走现有的 this.lyrics 结构以保持后续逻辑不变）
applyCookedLyrics(cooked) {
	// 1) 设置 type（给 getExtraLyricText 使用）
	if (cooked && cooked.type) {
		this.playerState.lyricType = cooked.type;
	}

	// 2) cooked.lines → this.lyrics
	const lines = cooked && Array.isArray(cooked.lines) ? cooked.lines : [];

	this.lyrics = lines.map((it) => ({
		time: typeof it.t === "number" ? it.t : 0,
		original: it.o || "",
		translation: it.tr || null,
		romaji: it.ro || null,
	}));

	// ✅ fallback：统一结构，永远用 original 字段
	if (!this.lyrics.length) {
		this.lyrics = [{ time: 0, original: "暂无歌词", translation: null, romaji: null }];
	}

	// 3) 构建渲染状态中心
	this.lyricLines = this.lyrics.map((line, index) => ({
		id: `lyric-${line.time}-${index}`,
		originalIndex: index,
		original: line.original || "",
		extra: this.getExtraLyricText(this.lyrics[index]) || null,
		isCurrent: false,
		isSelected: false,
	}));

	// 4) 分流：fullscreen 不初始化 64 管道
	const mode = (this.settings && this.settings.lyricRenderMode) || "fullscreen";
	if (mode === "fullscreen") {
		if (typeof this.buildFullscreenLines === "function") {
			this.buildFullscreenLines();
		}
		this.updateLyric();
		return;
	}

	// 5) all：走 64 分片
	this.distributeLyricsToGroups();

	// 6) 立即根据当前播放时间更新一次高亮状态
	this.updateLyric();
},


parseLyric(lrcString) {
	const lines = (lrcString || "").split("\n");
	const result = [];
	const timeRe = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/g;

	for (const raw of lines) {
		if (!raw) continue;

		// 1) 抓取该行所有时间戳
		timeRe.lastIndex = 0;
		const times = [];
		let m;
		while ((m = timeRe.exec(raw)) !== null) {
			const t =
				parseInt(m[1], 10) * 60 +
				parseInt(m[2], 10) +
				parseInt(m[3].padEnd(3, "0"), 10) / 1000;
			times.push(t);
		}

		if (!times.length) continue;

		// 2) 去掉该行所有时间戳后的“正文”
		const text = raw.replace(timeRe, "").trim();

		// ✅ 关键：如果正文为空，说明这行只是时间点标记，直接跳过
		if (!text) continue;

		// 3) 一行多个时间戳：同一句在多个时间点出现，都入结果
		for (const t of times) result.push({ time: t, text });
	}

	// 4) 保险：排序（有些源不按时间顺序）
	result.sort((a, b) => a.time - b.time);

	return result.length ? result : [{ time: 0, text: "暂无歌词" }];
},

mergeLyrics(original, translation, romaji) {
	const createMap = (arr) =>
		new Map(arr.map((item) => [item.time.toFixed(3), item.text]));
	if (romaji && translation) {
		this.playerState.lyricType = "japanese";
		const transMap = createMap(translation),
			romaMap = createMap(romaji);
		this.lyrics = original.map((line) => ({
			time: line.time,
			original: line.text,
			translation: transMap.get(line.time.toFixed(3)),
			romaji: romaMap.get(line.time.toFixed(3)),
		}));
	} else if (romaji && !translation) {
		this.playerState.lyricType = "cantonese";
		const romaMap = createMap(romaji);
		this.lyrics = original.map((line) => ({
			time: line.time,
			original: line.text,
			romaji: romaMap.get(line.time.toFixed(3)),
		}));
	} else if (translation) {
		this.playerState.lyricType = "english";
		const transMap = createMap(translation);
		this.lyrics = original.map((line) => ({
			time: line.time,
			original: line.text,
			translation: transMap.get(line.time.toFixed(3)),
		}));
	} else {
		this.playerState.lyricType = "chinese";
		this.lyrics = original.map((line) => ({
			time: line.time,
			original: line.text,
		}));
	}
	if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: "暂无歌词" }];
},


getExtraLyricText(lineData) {
	if (!lineData) return "";
	let extraText = "";
	const lyricSettings = this.settings.lyrics || {};
	switch (this.playerState.lyricType) {
		case "japanese":
			if (lyricSettings.japaneseMode === "translation")
				extraText = lineData.translation || "";
			else if (lyricSettings.japaneseMode === "romaji")
				extraText = lineData.romaji || "";
			break;
		case "cantonese":
			if (lyricSettings.cantoneseMode === "romaji")
				extraText = lineData.romaji || "";
			break;
		case "english":
			if (lyricSettings.englishMode === "translation")
				extraText = lineData.translation || "";
			break;
	}
	return extraText;
},


	/**
	 * 【【【核心重构】】】
	 * 滚动到当前歌词，优化DOM查询
	 * @param {boolean} isInitial - 是否是初次进入页面
	 */
	scrollToCurrentLyric(isInitial = false) {
		if (
			this.swiperCurrentIndex !== 1 ||
			!this._lyricsScrollView ||
			this.playerState.currentLyricIndex < 0
		) {
			return;
		}

		const lineElement = this.$element(
			`lyric-line-${this.playerState.currentLyricIndex}`
		);
		if (!lineElement) return;

		// 使用回调链避免竞态
		this._lyricsScrollView.getBoundingClientRect({
			success: (scrollRect) => {
				lineElement.getBoundingClientRect({
					success: (lineRect) => {
						const targetCenterY = scrollRect.height * 0.4;
						const lineTopInContainer = lineRect.top - scrollRect.top;
						const scrollOffset =
							lineTopInContainer + lineRect.height / 2 - targetCenterY;

						this._lyricsScrollView.scrollBy({
							top: scrollOffset,
							// 初次进入时无动画，后续切换有动画
							behavior: isInitial ? "instant" : "smooth",
						});
					},
				});
			},
		});
	},

	bindAudioEvents() {
		// onplay：同步状态 + 如有 pending restore time，则在此处触发一次 seekOnce
		audio.onplay = () => {
			// 同步播放态
			if (!this.playerState.isPlaying) {
				this.playerState.isPlaying = true;
			}

			// 清超时等待
			if (this.playTimeoutId) {
				clearTimeout(this.playTimeoutId);
				this.playTimeoutId = null;
			}
			this.pendingSongId = null;

			// 如果需要恢复进度：只在这里做一次
			if (
				typeof this._pendingRestoreTime === "number" &&
				this._pendingRestoreTime > 0
			) {
				const t = this._pendingRestoreTime;
				this._pendingRestoreTime = null; // 确保只做一次
				this.seekOnce(t);
				// 恢复进度已消费
				this.resumeTime = -1;
			}
			console.log("Event: onplay (synced).");
		};

		// ontimeupdate：恢复期禁止写入 0，避免 UI 00:00 闪一下
		audio.ontimeupdate = () => {
			// 等待切歌阶段不更新（你原逻辑保留）
			if (this.pendingSongId) return;

			// 恢复期 / 屏蔽窗口：不更新 UI，不跑歌词（关键）
			const now = Date.now();
			if (this._restoreSeeking) return;
			if (this._ignoreTimeupdateUntilTs && now < this._ignoreTimeupdateUntilTs)
				return;

			this.playerState.playDuration = audio.currentTime;
			this.updateLyric();

			this.syncToGlobalPlayer();
		};

		// 暂停事件：只做状态同步，不要再 audio.pause()
		audio.onpause = () => {
			this.playerState.isPlaying = false;
			this.onSaveState();
			console.log("Event: onpause (synced).");
		};

		audio.onstop = () => {
			this.playerState.isPlaying = false;
			this.onSaveState();
			if (this.playTimeoutId) {
				clearTimeout(this.playTimeoutId);
				this.playTimeoutId = null;
			}
			this.pendingSongId = null;

			this.syncToGlobalPlayer();
			console.log("Event: onstop.");
		};

		audio.onended = () => {
			console.log(
				`Event: onended. t=${audio.currentTime}, dur=${audio.duration}`
			);
			const diff = Math.abs((audio.duration || 0) - (audio.currentTime || 0));
			if ((audio.duration || 0) > 0 && diff > 2) {
				console.error("Warning: onended early trigger suspected.");
			}

			if (this.playMode === 1) this.playCurrent();
			else this.change(1);
		};

		// 系统/耳机控制：这些是“外部请求”，由我们执行动作
		audio.onctrlplayprev = () => {
			prompt.showToast({ message: "上一首" });
			this.change(-1);
		};

		audio.onctrlplaynext = () => {
			prompt.showToast({ message: "下一首" });
			this.change(1);
		};

		audio.onctrlvolumeup = () => {
			audio.getPlayState({
				success: (state) => {
					const v = typeof state.volume === "number" ? state.volume : 0.5;
					const newV = v > 0.9 ? 1 : v + 0.1;
					audio.volume = newV;
					prompt.showToast({ message: `音量: ${Math.round(newV * 100)}%` });
				},
				fail: (data, code) =>
					console.error(`[ctrl] getPlayState failed: code=${code}`),
			});
		};

		audio.onctrlvolumedown = () => {
			audio.getPlayState({
				success: (state) => {
					const v = typeof state.volume === "number" ? state.volume : 0.5;
					const newV = v < 0.1 ? 0 : v - 0.1;
					audio.volume = newV;
					prompt.showToast({ message: `音量: ${Math.round(newV * 100)}%` });
				},
				fail: (data, code) =>
					console.error(`[ctrl] getPlayState failed: code=${code}`),
			});
		};
	},

	syncToGlobalPlayer() {
		const def = this.$app.$def;
		if (!def) return;

		if (!def.player) {
			def.player = {
				playerState: {
					isPlaying: false,
					playDuration: 0,
					currentLyricIndex: -1,
					lyricType: "default",
				},
				currSong: null,
				playList: [],
			};
		}

		// 播放状态直接同步引用
		def.player.playerState = this.playerState;

		// 当前歌曲：拷贝一份，保证 coverUrl 字段始终存在
		def.player.currSong = this.currSong
			? {
					...this.currSong,
					coverUrl: this.currSong.coverUrl || null,
			  }
			: null;

		// 播放列表：按需选择是否拷贝
		def.player.playList = this.playList;
	},

	// --- 数据加载与重置 ---
	async loadSettings() {
		try {
			const data = await fileService.readJson(CONSTANTS.SETTINGS_FILE_URI);
			if (data) {
				// 【【【修改】】】确保 gestures 能被正确合并
				this.settings = {
					...this.settings,
					...data,
					lyrics: { ...this.settings.lyrics, ...(data.lyrics || {}) },
					audioQuality: {
						...this.settings.audioQuality,
						...(data.audioQuality || {}),
					},
					gestures: { ...this.settings.gestures, ...(data.gestures || {}) }, // 新增合并
				};
				console.log("播放器设置加载成功，手势配置:", this.settings.gestures);
			}
		} catch (e) {
			console.log("无法加载播放器设置，使用默认值。");
		}
	},
	async loadCookie() {
		try {
			let rawText;
			try {
				rawText = (
					await fileService._promisify(file.readText, {
						uri: CONSTANTS.COOKIE_FILE_URI,
					})
				).text;
			} catch (e) {
				rawText = null;
			}
			this.cookie = rawText || null;
			if (this.cookie) console.log("Cookie 加载成功。");
		} catch (e) {
			this.cookie = null;
		}
	},
	async loadListFromFile() {
		this.playList = await fileService.readJson(CONSTANTS.FILE_PLAY_LIST, []);
	},
	async loadDownloadedSongs() {
		this.downloadedSongs = await fileService.readJson(
			CONSTANTS.FILE_DOWNLOADED_SONGS,
			{}
		);
	},
	resetPlayer() {
	audio.stop();
	this.currSong = null;
	this.playerState.isPlaying = false;
	this.playerState.playDuration = 0;
	this.isChangingSong = false;
	this.retryCount = 0;

	// ✅ 让所有旧歌词回调失效
	this._lyricReqId = (this._lyricReqId || 0) + 1;

	this.resetLyrics();
},


	handlePlaybackError(message) {
		if (this.playTimeoutId) {
			clearTimeout(this.playTimeoutId);
			this.playTimeoutId = null;
		}
		this.pendingSongId = null;
		this.retryCount++;

		prompt.showToast({ message: `${message} (重试第 ${this.retryCount} 次)` });

		if (this.retryCount >= CONSTANTS.MAX_PLAYBACK_RETRIES) {
			prompt.showToast({
				message: `多次尝试失败，已暂停在当前歌曲`,
				duration: 5000,
			});

			if (typeof this.loadCurrentOnly === "function") {
				this.loadCurrentOnly();
			} else {
				try {
					audio.stop();
				} catch (e) {}
				this.playerState.isPlaying = false;
			}
			return;
		}

		setTimeout(() => {
			this.playCurrent();
		}, 1500 + this.retryCount * 1000);
	},

	_isCurrentSong(songId) {
	return !!(this.currSong && String(this.currSong.id) === String(songId));
},


	// --- 工具函数 ---
	second2time(second) {
		if (isNaN(second) || second < 0) return "00:00";
		const sec = Math.floor(second % 60)
			.toString()
			.padStart(2, "0");
		const min = Math.floor(second / 60)
			.toString()
			.padStart(2, "0");
		return `${min}:${sec}`;
	},
};
</script>
