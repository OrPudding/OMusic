<template>
	<div class="demo-page">
		<!-- 1. 歌曲信息 (保持在顶部) -->
		<div class="song">
			<marquee class="song-name" scrollamount="36" onclick="exit">{{ songName }}</marquee>
			<marquee class="singer-name" scrollamount="36">{{ songArtists }}</marquee>
		</div>
		<!-- 2. 核心内容区域: 使用 show 属性切换视图，避免销毁和重建 -->

        <!-- 视图 0: 播放器主界面 (swiperCurrentIndex === 0 时渲染) -->
        <div if="{{ swiperCurrentIndex === 0 }}" class="swiper-item player-view" onswipe="handleSwipe">
            <!-- a. 播放控制按钮 -->
            <div class="controls">
                <image class="icon" src="/common/icon/prev.png" onclick="change(-1)" />
                <image class="icon" src="{{ playButtonIcon }}" onclick="playOrPause" />
                <image class="icon" src="/common/icon/next.png" onclick="change(1)" />
            </div>
            <!-- b. 播放进度条 -->
            <div class="progress">
                <text class="play-time">{{ progressText }}</text>
                <slider class="play-progress" min="0" max="{{ (currSong && currSong.duration) ? currSong.duration : 100 }}" step="1" value="{{ playerState.playDuration }}" onchange="onSliderChange"></slider>
            </div>
            <!-- c. 底部操作栏 -->
            <div class="footer">
                <div class="footer-content-rect" if="{{ screenShape === 'rect' }}">
                    <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                    <image class="footer-icon" src="{{ downloadIcon }}" onclick="initiateDownload"></image>
                    <image class="footer-icon" src="{{ playModeIcon }}" onclick="togglePlayMode"></image>
                    <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
                </div>
                <div class="footer-content-circle" else>
                    <image class="footer-icon" src="/common/icon/volume.png" onclick="goToSongActions"></image>
                    <image class="footer-icon" src="/common/icon/play-list.png" onclick="goToMenu"></image>
                </div>
            </div>
        </div>

        <!-- 视图 1: 歌词页 -->
        <scroll
            show="{{ swiperCurrentIndex === 1 }}"
            id="lyricsScrollView"
            class="lyrics-scroll-view"
            scroll-y="true"
            onswipe="handleSwipe"
        >
            <div class="lyrics-list-padding-top"></div>
            <div
                for="{{(index, line) in fullVisibleLyrics}}"
                tid="line.id"
                id="lyric-line-{{ index }}"
                class="lyric-line-wrapper {{ line.isCurrent ? 'is-current-wrapper' : '' }} {{ line.isSelected ? 'is-selected-wrapper' : '' }}"
                onclick="onLyricLineClick(line, index)"
            >
                <text class="lyric-line {{ line.isCurrent ? 'current-lyric' : 'secondary-lyric' }}">
                    {{ line.original }}
                </text>
                <text if="{{ line.isCurrent && line.extra }}" class="lyric-line extra-lyric">
                    {{ line.extra }}
                </text>
            </div>
            <div class="lyrics-list-padding-bottom"></div>
        </scroll>
                <!-- 3. 手动添加的页面指示器 (放置在最外层，不影响 if/else 结构) -->
                <div class="manual-indicator">
                    <div class="indicator-dot {{ swiperCurrentIndex === 0 ? 'indicator-dot-active' : '' }}"></div>
                    <div class="indicator-dot {{ swiperCurrentIndex === 1 ? 'indicator-dot-active' : '' }}"></div>
                </div>

	</div>
</template>

<style>
/* --- 基础布局 --- */
.demo-page {
    width: 100%;
    height: 100%;
    flex-direction: column;
    justify-content: flex-start; /* 从顶部开始布局 */
    align-items: center;
    background-color: #000;
}
.song { 
    width: 100%; 
    height: 90px; /* 歌曲信息区域高度 */
    flex-direction: column; 
    justify-content: center; 
    align-items: center; 
    flex-shrink: 0; /* 防止被压缩 */
    padding-top: 30px;
}
.song-name { 
    width: 320px; 
    font-size: 32px; 
    color: #ffffff; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
}
.singer-name { 
    width: 300px; 
    font-size: 24px; 
    /* 【修改】使用固定颜色代替透明度 */
    color: #CCCCCC; 
    lines: 1; 
    text-overflow: ellipsis; 
    text-align: center; 
}

/* --- Swiper 容器与子项 --- */
.content-swiper {
    width: 100%;
    /* 让 swiper 占据剩余的所有空间 */
    flex-grow: 1; 
    indicator-size: 10px;
    /* 【修改】使用固定颜色代替透明度 */
    indicator-color: #555555;
    indicator-selected-color: #3ae1ff;
    indicator-bottom: 10px; /* 指示器位置微调 */
}
/* --- Swiper 容器与子项 --- */
/* 将 .content-swiper 修改为 .swiper-item 并添加 flex-grow */
.swiper-item {
    width: 100%;
    flex-grow: 1; /* 让视图占据剩余的所有空间 */
    flex-direction: column;
    align-items: center;
}

/* --- 手动指示器样式 --- */
.manual-indicator {
    position: absolute;
    bottom: 10px;
    left: 0;
    width: 100%;
    height: 20px;
    flex-direction: row;
    justify-content: center;
    align-items: center;
}
.indicator-dot {
    width: 10px;
    height: 10px;
    border-radius: 5px;
    background-color: #555555; /* 对应原 indicator-color */
    margin: 0 5px;
}
.indicator-dot-active {
    background-color: #3ae1ff; /* 对应原 indicator-selected-color */
}


/* 播放器视图内部布局 */
.player-view {
    justify-content: space-around; /* 让三个部分均匀分布 */
    padding: 20px 0;
}
.controls {
	width: 380px;
    height: 144px;
	justify-content: space-around; /* 按钮间距更均匀 */
	align-items: center;
}
.icon {
	width: 90px;
	height: 90px;
}
.progress { 
    height: 80px; 
    width: 90%; 
    flex-direction: column; 
    align-items: center; 
}
.play-time { 
    text-align: left; 
    color: #ffffff; 
    font-size: 24px; 
    margin: 5px; 
}
.play-progress { 
    width: 80%; 
    selected-color: #3ae1ff; 
    block-color: #ffffff; 
    padding-left: 0px; 
    padding-right: 0px; 
    margin: 0 20px; 
}
.footer { 
    height: 75px; 
    width: 100%; 
    justify-content: center; 
    align-items: center; 
}
.footer-content-rect { 
    width: 90%; 
    justify-content: space-around; 
    align-items: center; 
}
.footer-content-circle { 
    width: 320px; 
    justify-content: space-around; 
    align-items: center; 
}
.footer-icon { 
    width: 64px; 
    height: 64px; 
}

/* --- 歌词视图样式 (已优化 - 无透明度版) --- */
.lyrics-scroll-view {
    width: 100%;
    height: 100%;
    padding:0 10px;
    flex-direction: column;
    align-items: center;
}
.lyrics-list-padding-top, .lyrics-list-padding-bottom {
    height: 150px; 
}
.lyric-line-wrapper {
    width: 100%;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 3px 0;
}
.is-current-wrapper {
    /* 【修改】使用固定颜色代替透明度 */
    background-color: #1A1A1A; 
    border-radius: 50%;
}
/* 【【【新增】】】 点击选中时的蓝色边框样式 */
.is-selected-wrapper {
    border: 2px solid #3ae1ff; /* 使用主题蓝色作为边框颜色 */
    border-radius: 50%;       /* 使用一个固定的圆角值 */
}
.lyric-line {
    width: 90%;
    text-align: center;
    lines: -1;
    
    /* 【核心修改】默认状态：非当前行，使用灰色代替白色+透明度 */
    color: #999999; 
    font-size: 24px;
}

/* 【核心修改】当前行的激活状态 */
.current-lyric {
    /* 【移除】opacity: 1; (已是默认) */
    color: #3ae1ff;
    font-weight: bold;
    font-size: 26px;
    padding: 6px 0;
}

.extra-lyric {
    font-size: 20px;
    /* 【修改】使用固定颜色代替白色+透明度 */
    color: #BBBBBB;
    padding-bottom: 6px;
}


/* --- 评论区占位符 --- */
.comments-view {
    justify-content: center;
    /* 【修改】使用固定颜色代替透明度 */
    color: #666666;
}
.placeholder-icon {
    width: 60px;
    height: 60px;
    /* 【修改】使用固定颜色代替透明度 */
    color: #4D4D4D;
}
.placeholder-text {
    font-size: 24px;
    margin-top: 8px;
}

/* --- 媒体查询 --- */
@media screen and (shape: rect) {
    .controls {
        height: 180px;
    }
    .progress {
        width: 400px;
        height: 100px;
    }
    .is-current-wrapper {
        /* 【修改】使用固定颜色代替透明度 */
        background-color: #1A1A1A;
        border-radius: 24px;
    }
        /* 【【【新增】】】 确保方形屏幕下选中样式也生效 */
        .is-selected-wrapper {
        border-radius: 24px;
    }
    .lyrics-list-padding-top, .lyrics-list-padding-bottom {
        height: 190px;
    }
    /* 方形屏幕下字体也相应缩小 */
    .secondary-lyric { font-size: 24px; }
    .current-lyric { font-size: 26px; }
    .extra-lyric { font-size: 19px; }
}
</style>


<script>
import router from "@system.router";
import audio from "@system.audio";
import file from "@system.file";
import prompt from '@system.prompt';
import device from '@system.device';
import app from "@system.app";
import brightness from "@system.brightness";

import apiService from '../../services/api.js';
import throttle from '../../utils/throttle.js';

const CONSTANTS = {
    DIR_MUSIC: 'internal://files/music/',
    DIR_LYRICS: 'internal://files/lyrics/',
    FILE_PLAY_LIST: 'internal://files/play_list.json',
    FILE_DOWNLOADED_SONGS: 'internal://files/downloaded_songs.json',
    SETTINGS_FILE_URI: 'internal://files/settings.json',
    COOKIE_FILE_URI: 'internal://files/cookie.txt',
    FILE_PLAYER_STATE: 'internal://files/player_state.json',
    MAX_PLAYBACK_RETRIES: 3,
    PLAY_TIMEOUT: 8000,
};

const REVERSE_DIRECTIONS = {
    left: 'right',
    right: 'left',
    up: 'down',
    down: 'up'
};

const fileService = {
    _promisify(fn, options) { return new Promise((resolve, reject) => { fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) }); }); },
    async readJson(uri, defaultValue = null) { try { const data = await this._promisify(file.readText, { uri }); return JSON.parse(data.text); } catch (e) { return defaultValue; } },
    async writeJson(uri, data) { try { await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) }); return true; } catch (e) { return false; } },
};

export default {
    private: {
        playerState: { isPlaying: false, playDuration: 0, currentLyricIndex: -1, lyricType: 'chinese' }, // 【优化】currentLyricIndex 初始为 -1
        currSong: null,
        lyrics: [],
        swiperCurrentIndex: 0,
        downloadedSongs: {},
        settings: { lyrics: { japaneseMode: 'translation', cantoneseMode: 'romaji', englishMode: 'translation' },
                    lyricAdvanceTime:1.8,
                    gestures: {
                        left: 'lyrics',
                right: 'playlist',
                up: 'search',
                down: 'none'
            },
                    audioQuality: { online: 64, download: 128 } },
        // isPlaying: false, // 【移除】冗余状态，统一由 playerState.isPlaying 管理
        cookie: null,
        isDownloadingLocked: false,
        // wasRestored: false, // 【移除】
        retryCount: 0,
        screenShape: 'circle',
        playMode: 0,
        songBeingDownloaded: null,
        isFmMode: false,
        fmQueue: [],
        isFetchingFm: false,
        pendingSongId: null,
        playTimeoutId: null,
        needsRefresh: false,
        _lyricsScrollView: null, // 缓存滚动视图元素

                // 【【【新增】】】 用于歌词点击跳转的状态
                selectedLyricIndex: -1,     // 当前被选中的歌词行索引，-1表示没有选中
        selectionTimeoutId: null,   // 用于3秒后自动取消选中的定时器ID
        // 【【【核心优化】】】
        // 将 fullVisibleLyrics 从 computed 移到 private data 中
        // 我们将手动控制它的更新，而不是让框架自动计算
        fullVisibleLyrics: [],
                // 【新增】记录进入歌词页的手势方向
                _gestureToLyrics: null, 
    },

    protected: {
        playList: [],
        currentIndex: 0,
        songId: null,
        songInfo: null,
        triggerDownload: false,
        triggerPlayModeToggle: false,
        startFmMode: false,
    },
    
    computed: {
        // 【移除】 fullVisibleLyrics 从这里移除
        
        // 其他 computed 属性保持不变
        songName() { return this.currSong ? this.currSong.name : "未知歌曲"; },
        songArtists() { return this.currSong ? this.currSong.artists : "未知艺术家"; },
        playButtonIcon() {
            if (this.pendingSongId && !this.playerState.isPlaying) return '/common/icon/loading.png';
            return this.playerState.isPlaying ? '/common/icon/pause.png' : '/common/icon/play.png';
        },
        progressText() {
            const duration = this.currSong?.duration || 0;
            return `${this.second2time(this.playerState.playDuration)}/${this.second2time(duration)}`;
        },
        downloadIcon() {
            const icons = { downloading: '/common/icon/downloading.png', downloaded: '/common/icon/downloaded.png', not_downloaded: '/common/icon/download.png' };
            if (!this.currSong) return icons.not_downloaded;
            if (this.songBeingDownloaded && this.currSong.id === this.songBeingDownloaded.id) return icons.downloading;
            if (this.downloadedSongs[this.currSong.id]) return icons.downloaded;
            return icons.not_downloaded;
        },
        playModeIcon() {
            if (this.isFmMode) return '/common/icon/fm.png';
            const icons = ['/common/icon/loop.png', '/common/icon/single-loop.png', '/common/icon/random.png'];
            return icons[this.playMode] || icons[0];
        },
    },

    async onInit() {
        if (this.$app.$def.isActivated !== true) { router.replace({ uri: '/pages/splash' }); return; }
        console.log("Player onInit: 准备基础环境。");
        this.throttledSliderChange = throttle(this.applySliderChange, 200);
        
        this.bindAudioEvents();
        await this.loadSettings();
        await this.loadCookie();
        await this.loadDownloadedSongs();
        this.getDeviceInfo();
        await this.onRestoreState();
    },

    onShow() {
        console.log("Player onShow: 页面显示，标记需要刷新。");
        this.needsRefresh = true;
        
        // 【优化】如果当前在歌词页，保持屏幕常亮
        if (this.swiperCurrentIndex === 1) {
            brightness.setKeepScreenOn({ keepScreenOn: true });
        }
    },

    async onRefresh(query) {
        const params = query || {};
        console.log('Player onRefresh with params:', JSON.stringify(params));

        if (this.needsRefresh) {
            console.log("onRefresh: 加载核心数据。");
            await this.loadDownloadedSongs();
            await this.loadListFromFile();
            this.needsRefresh = false;
        }

        if (params.triggerDownload) { this.initiateDownload(); return; }
        if (params.startFmMode) { this.dostartFmMode(params.songId, params.songInfo); return; }
        if (params.triggerPlayModeToggle) { this.togglePlayMode(); }

        if (params.songId) {
            if (!this.currSong || this.currSong.id != params.songId) {
                console.log(`onRefresh: 收到新歌指令 [${params.songId}]`);
                this.songId = params.songId;
                this.songInfo = params.songInfo ? JSON.parse(params.songInfo) : null;
                await this.startLogic();
            }
            return; 
        }

        if (this.currSong) {
            const stillInPlaylist = this.playList.some(song => song.id === this.currSong.id);
            if (!stillInPlaylist) {
                prompt.showToast({ message: "当前歌曲已从列表中移除" });
                await this.change(1); 
            }
        }
    },

    onDestroy() {
        console.log("Player onDestroy: 页面被销毁。");
        audio.stop();
        // 【优化】确保即使在下载中退出，也能尝试保存状态
        this.onSaveState();
        // 清理所有定时器
        if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
        // 如果有其他定时器也在这里清理
        brightness.setKeepScreenOn({ keepScreenOn: false }); // 关闭屏幕常亮
        console.log("播放器已销毁，状态已保存，资源已释放。");
    },

    onBackPress() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请勿退出' }); return true; }
        this.onSaveState();
        // 优化提示，让用户知道如何真正退出
        prompt.showToast({ message: '防误退出，点顶部歌名退出应用' });
        return true; // 返回 true 表示消费该事件，应用不会退出
    },

    async onRestoreState() {
        if (this.songId) return false;

        const savedState = await fileService.readJson(CONSTANTS.FILE_PLAYER_STATE);
        const isStateExpired = savedState?.timestamp ? (new Date().getTime() - savedState.timestamp > 12 * 3600 * 1000) : true;

        if (savedState && savedState.lastSongId && savedState.duration && !isStateExpired) {
            await this.loadListFromFile();
            const lastIndex = this.playList.findIndex(song => song && song.id === savedState.lastSongId);

            if (lastIndex > -1) {
                console.log(`onRestoreState: 成功恢复状态，歌曲: ${this.playList[lastIndex].name}`);
                
                this.songId = savedState.lastSongId;
                this.currentIndex = lastIndex;
                this.playMode = savedState.playMode || 0;
                this.currSong = { ...this.playList[this.currentIndex], duration: savedState.duration };
                this.playerState.playDuration = savedState.lastPlayDuration || 0;
                
                // 只获取歌词数据，但不立即渲染
                this.fetchLyric(this.songId);
                
                prompt.showToast({ message: "播放状态已恢复" });
                return true;
            }
        }
        return false;
    },

    // --- 交互与UI方法 ---
    // 【【【核心重构】】】
    handleSwipe(e) {
        const direction = e.direction; // 'left', 'right', 'up', 'down'

        // 场景一：当前在播放器主页 (封面页)
        if (this.swiperCurrentIndex === 0) {
            const action = this.settings.gestures[direction];
            
            if (action && action !== 'none') {
                // 如果动作是切换到歌词页
                if (action === 'lyrics') {
                    // 记录下是哪个手势进入了歌词页
                    this._gestureToLyrics = direction; 
                    this.switchToLyricsView();
                } else {
                    // 执行其他通用操作
                    this.executeGestureAction(action);
                }
            }
        } 
        // 场景二：当前在歌词页
        else if (this.swiperCurrentIndex === 1) {
            // 检查当前滑动方向是否是进入歌词页手势的“相反方向”
            if (this._gestureToLyrics && direction === REVERSE_DIRECTIONS[this._gestureToLyrics]) {
                this.switchToPlayerView();
            }
            //右滑也返回播放器主页
            else if (direction === 'right') {
                this.switchToPlayerView();
            }
        }
    },

    // 辅助方法：执行通用手势操作 (不包括视图切换)
    executeGestureAction(action) {
        console.log(`执行手势操作: ${action}`);
        switch (action) {
            case 'playlist':
                router.push({ uri: "/pages/list", params: { listType: "playlist" } });
                break;
            case 'search':
                router.push({ uri: "/pages/search" });
                break;
            case 'user':
                router.push({ uri: "/pages/user" });
                break;
            case 'settings':
                router.push({ uri: "/pages/settings" });
                break;
            case 'prev':
                this.change(-1);
                break;
            case 'next':
                this.change(1);
                break;
            // 注意：'lyrics' 的处理已移至 handleSwipe 中
            default:
                console.log(`未知的自定义手势操作: ${action}`);
                break;
        }
    },

    // 视图切换函数保持不变，但调用时机已由 handleSwipe 控制
    switchToLyricsView() {
        if (this.swiperCurrentIndex === 1) return;
        console.log("显示歌词视图");
        this.swiperCurrentIndex = 1;
        brightness.setKeepScreenOn({ keepScreenOn: true });
        this.$nextTick(() => {
            if (!this._lyricsScrollView) {
                this._lyricsScrollView = this.$element('lyricsScrollView');
            }
            this.scrollToCurrentLyric(true);
        });
    },
    /**
     * 【【【逻辑修正】】】
     * 滑回播放器页面时的处理
     */
     switchToPlayerView() {
        if (this.swiperCurrentIndex === 0) return;
        console.log("显示播放器视图");
        this.swiperCurrentIndex = 0;
        brightness.setKeepScreenOn({ keepScreenOn: false });

        // 如果存在一个待处理的选中操作
        if (this.selectedLyricIndex !== -1) {
            this.clearSelectionTimeout();
            // 【关键】无条件继续播放
            audio.play();
            this.resetLyricSelection();
        }
    },

    /**
     * 更新歌词行的选中状态 (此函数无需修改，保持原样)
     */
    updateLyricSelection(index, isSelected) {
        if (index < 0 || index >= this.fullVisibleLyrics.length) {
            return;
        }
        const line = this.fullVisibleLyrics[index];
        if (line.isSelected !== isSelected) {
            this.fullVisibleLyrics.splice(index, 1, {
                ...line,
                isSelected: isSelected,
            });
        }
    },


    /**
     * 【【【逻辑修正】】】
     * 歌词行点击事件处理函数
     * 简化逻辑：首次点击暂停，二次点击跳转并继续播放。
     */
     onLyricLineClick(line, index) {
        // 1. 如果是第一次点击 (包括从一个选中项切换到另一个)
        if (this.selectedLyricIndex !== index) {
            // a. 如果当前正在播放，则暂停
            if (this.playerState.isPlaying) {
                audio.pause();
            }
            
            // b. 清理旧状态并设置新状态
            this.clearSelectionTimeout();
            this.updateLyricSelection(this.selectedLyricIndex, false); // 取消旧的
            this.selectedLyricIndex = index;
            this.updateLyricSelection(index, true); // 设置新的

            // c. 启动自动取消定时器
            this.startSelectionTimeout();
            prompt.showToast({ message: `已暂停，再次点击跳转` });
        } 
        // 2. 如果是第二次点击 (确认跳转)
        else {
            // a. 清理定时器
            this.clearSelectionTimeout();

            // b. 获取时间并跳转
            const targetTime = this.lyrics[index].time;
            audio.currentTime = targetTime;
            
            // c. 【关键】无条件继续播放
            audio.play();
            prompt.showToast({ message: `已跳转到 ${this.second2time(targetTime)}` });

            // d. 更新UI
            this.updateLyric(); 
            this.$nextTick(() => this.scrollToCurrentLyric(true));

            // e. 清理选中状态
            this.resetLyricSelection();
        }
    },
    /**
     * 【【【逻辑修正】】】
     * 启动3秒后自动取消选中的定时器
     */
     startSelectionTimeout() {
        this.selectionTimeoutId = setTimeout(() => {
            prompt.showToast({ message: '选中已取消' });
            
            // 【关键】无条件继续播放
            audio.play();
            
            this.resetLyricSelection();
        }, 3000);
    },

    /**
     * 【【【逻辑修正】】】
     * 清除定时器，但不改变播放状态
     */
    clearSelectionTimeout() {
        if (this.selectionTimeoutId) {
            clearTimeout(this.selectionTimeoutId);
            this.selectionTimeoutId = null;
        }
    },

    /**
     * 【【【逻辑修正】】】
     * 重置所有与歌词选择相关的状态
     */
     resetLyricSelection() {
        if (this.selectedLyricIndex !== -1) {
            this.updateLyricSelection(this.selectedLyricIndex, false);
        }
        this.selectedLyricIndex = -1;
        // 不再需要管理 wasPlayingBeforeSelection
    },
    /**
     * 【【【新增】】】
     * 更新歌词行的选中状态 (使用不可变性原则)
     * @param {number} index - 要更新的行索引
     * @param {boolean} isSelected - 是否设置为选中
     */
    updateLyricSelection(index, isSelected) {
        if (index < 0 || index >= this.fullVisibleLyrics.length) {
            return;
        }
        
        const line = this.fullVisibleLyrics[index];
        // 只有在状态确实需要改变时才操作，避免不必要的渲染
        if (line.isSelected !== isSelected) {
            this.fullVisibleLyrics.splice(index, 1, {
                ...line,
                isSelected: isSelected,
            });
        }
    },
    getDeviceInfo() { device.getInfo({ success: (data) => { if (data.screenShape) this.screenShape = data.screenShape; }, fail: (data, code) => console.error(`获取设备信息失败, code = ${code}`) }); },
    async onSaveState() {
        if (!this.currSong || !this.currSong.duration) return;
        const stateToSave = { lastSongId: this.currSong.id, lastPlayDuration: this.playerState.playDuration, playMode: this.playMode, duration: this.currSong.duration, timestamp: new Date().getTime() };
        await fileService.writeJson(CONSTANTS.FILE_PLAYER_STATE, stateToSave);
    },
    playOrPause() {
        if (!this.currSong) { prompt.showToast({ message: '没有可播放的歌曲' }); return; }
        if (!audio.src) { this.startLogic(); return; }
        if (!this.isChangingSong) this.playerState.isPlaying ? audio.pause() : audio.play();
    },
        // 真正执行 seek 的方法
        applySliderChange(progress) {
        console.log(`[Throttled] Applying seek to: ${progress}`);
        if (this.playerState.isPlaying || audio.duration > 0) {
            audio.currentTime = progress;
            this.updateLyric(); // 手动更新歌词以保证UI响应
        }
    },

    // 进度条的 onchange 事件处理函数
    onSliderChange(e) {
        // 3. 调用节流后的函数，而不是直接操作 audio
        //    注意：这里需要通过 this 来调用
        this.throttledSliderChange(e.progress);
    },
    goToSongActions() {
        if (!this.currSong) { prompt.showToast({ message: '当前无播放歌曲' }); return; }
        router.push({ uri: "/pages/volume", params: { currentSong: JSON.stringify(this.currSong), screenShape: this.screenShape, playMode: this.playMode, isFmMode: this.isFmMode } });
    },
    togglePlayMode() {
        if (this.isFmMode) {
            prompt.showDialog({
                title: '退出私人FM', message: '您确定要退出私人FM吗？将会停止当前播放并返回常规列表模式。', buttons: [{ text: '取消' }, { text: '确定退出', color: '#FF453A' }],
                success: async () => {
                    prompt.showToast({ message: '正在退出私人FM...' });
                    this.isFmMode = false; this.fmQueue = []; this.resetPlayer();
                    try { await this.startLogic(); prompt.showToast({ message: '已返回列表播放模式' }); } catch (error) { prompt.showToast({ message: '播放列表为空' }); }
                },
                cancel: () => prompt.showToast({ message: '操作已取消' })
            });
            return;
        }
        this.playMode = (this.playMode + 1) % 3;
        const modeText = ['列表循环', '单曲循环', '随机播放'];
        prompt.showToast({ message: modeText[this.playMode] });
        if (this.playMode === 2 && this.playList.length > 0) this.generateShuffledList(true);
    },
    goToMenu() {
        if (this.isDownloadingLocked) { prompt.showToast({ message: '正在下载，请稍后' }); return; }
        if (this.isFmMode) { prompt.showToast({ message: '当前处于FM模式！打开过多页面将导致中断！' }); }
        router.push({ uri: "/pages/menu" });
    },
    exit() { app.terminate(); },
    // --- 下载逻辑 (已重构并使用闭包管理周期性提示) ---
    initiateDownload() {
        // 1. 前置检查 (保持不变)
        if (typeof this.downloadedSongs !== 'object' || this.downloadedSongs === null) {
            prompt.showToast({ message: '下载列表未准备好，请稍后重试' });
            this.loadDownloadedSongs();
            return;
        }
        if (!this.currSong) { prompt.showToast({ message: '歌曲信息无效，无法下载' }); return; }
        if (this.downloadedSongs[this.currSong.id]) { prompt.showToast({ message: '歌曲已下载' }); return; }
        if (this.isDownloadingLocked) { prompt.showToast({ message: '已有任务在下载中' }); return; }

        // 2. 【【【核心】】】在方法作用域顶部声明一个变量，用于存储定时器ID
        let downloadToastTimer = null;

        // 3. 初始提示
        prompt.showToast({ message: `开始准备下载: ${this.currSong.name}` });

        // 4. 调用下载服务
        this.$app.$def.downloadService.start(
            this.currSong,
            { cookie: this.cookie, downloadBitrate: this.settings.audioQuality.download },
            {
                onStart: (song) => {
                    this.isDownloadingLocked = true;
                    this.songBeingDownloaded = { ...song };

                    // 【【【核心】】】创建定时器，并将其ID赋值给外部作用域的变量
                    downloadToastTimer = setInterval(() => {
                        if (this.songBeingDownloaded) {
                            prompt.showToast({ message: `下载中` ,duration: 500});
                        }
                    }, 3000);
                },
                
                onSuccess: async (downloadedInfo) => {
                    // ... (成功逻辑保持不变)
                    try {
                        const updatedSongs = { ...this.downloadedSongs, [downloadedInfo.id]: downloadedInfo };
                        await fileService.writeJson(CONSTANTS.FILE_DOWNLOADED_SONGS, updatedSongs);
                        this.downloadedSongs = updatedSongs;
                        prompt.showToast({ message: `${downloadedInfo.name} 下载并记录成功`, duration: 5000 });
                    } catch (error) {
                        console.error("写入下载记录失败:", error);
                        prompt.showToast({ message: `歌曲已下载，但保存记录失败: ${error.message}` });
                    }
                },
                
                onError: (errorMessage) => {
                    // ... (失败逻辑保持不变)
                    prompt.showToast({ message: `下载失败: ${errorMessage}` });
                },
                
                onFinish: () => {
                    // 【【【核心】】】
                    // onFinish 回调作为闭包，可以访问并清除在外部作用域中声明的 downloadToastTimer
                    if (downloadToastTimer) {
                        clearInterval(downloadToastTimer);
                        console.log("下载提示定时器已清除。");
                    }

                    this.isDownloadingLocked = false;
                    this.songBeingDownloaded = null;
                }
            }
        );
    },


    /**
     * 【核心修正】: startLogic 不再处理恢复逻辑，职责更单一
     */
     async startLogic() {
        // 【移除】所有与 wasRestored 相关的逻辑
        
        if (!this.songId) {
            await this.loadListFromFile();
            if (this.playList && this.playList.length > 0) {
                this.currentIndex = 0;
                this.playCurrent();
            } else {
                prompt.showToast({ message: "播放列表为空" });
            }
            return;
        }

        await this.loadListFromFile();
        const index = this.playList.findIndex(item => item && String(item.id) === String(this.songId));
        
        if (index !== -1) {
            this.currentIndex = index;
        } else {
            if (this.songInfo && this.songInfo.id) {
                this.playList.unshift(this.songInfo);
                this.currentIndex = 0;
                await fileService.writeJson(CONSTANTS.FILE_PLAY_LIST, this.playList);
            } else {
                this.currentIndex = 0;
            }
        }

        if (this.playList.length > 0) {
            this.playCurrent();
        }
    },
    async playCurrent() {
        let songToPlay;
        if (this.isFmMode) {
            if (this.fmQueue.length === 0) {
                await this.fetchNextFmSongs();
                if (this.fmQueue.length === 0) { this.resetPlayer(); return; }
            }
            songToPlay = this.fmQueue[0];
        } else {
            if (!this.playList || this.playList.length === 0) { this.resetPlayer(); return; }
            songToPlay = this.playList[this.currentIndex];
        }
        if (!songToPlay) { this.handlePlaybackError("无效的歌曲数据"); return; }
        if (this.pendingSongId === songToPlay.id) return;
        this.pendingSongId = songToPlay.id;
        this.updateUiForNewSong(songToPlay);
        this.startPlaybackTimeout();
        if (this.isFmMode) this.fmQueue.shift();
        try {
            const downloadedInfo = this.downloadedSongs[songToPlay.id];
            if (downloadedInfo?.localUri) await this.playLocal(songToPlay, downloadedInfo);
            else await this.playOnline(songToPlay);
        } catch (error) { this.handlePlaybackError(error.message || "播放准备失败"); }
    },
    updateUiForNewSong(song) {
        audio.stop();
        if (!this.currSong) this.currSong = { ...song, duration: 0 };
        else { this.currSong.id = song.id; this.currSong.name = song.name; this.currSong.artists = song.artists; this.currSong.duration = 0; }
        this.playerState.playDuration = 0;
        this.resetLyrics();
        this.fetchLyric(song.id);
    },
    startPlaybackTimeout() {
        if (this.playTimeoutId) clearTimeout(this.playTimeoutId);
        this.playTimeoutId = setTimeout(() => {
            console.error("!!! PLAYBACK TIMEOUT !!!");
            prompt.showToast({ message: '播放超时，请重试' });
            this.pendingSongId = null; this.playTimeoutId = null; this.resetPlayer();
        }, CONSTANTS.PLAY_TIMEOUT);
    },
    async playLocal(song, downloadedInfo) {
        return new Promise((resolve, reject) => {
            file.access({
                uri: downloadedInfo.localUri,
                success: () => { this.startPlayback({ ...song, ...downloadedInfo }, downloadedInfo.localUri); this.fetchLyric(song.id); resolve(); },
                fail: () => { prompt.showToast({ message: '本地文件失效，转为在线播放' }); this.playOnline(song).then(resolve).catch(reject); }
            });
        });
    },
    async playOnline(song) {
        this.isEnding = false;
        try {
            const songInfo = await apiService.getSongPlaybackInfo(song.id, this.settings.audioQuality.online, this.cookie);
            const fullSongInfo = { ...song, playUrl: songInfo.url, duration: songInfo.duration };
            this.startPlayback(fullSongInfo, songInfo.url);
            this.fetchLyricOnline(song.id);
        } catch (error) { console.error("playOnline 失败:", error); throw error; }
    },
    startPlayback(songWithDuration, src) {
        if (!src || typeof src !== 'string') { this.handlePlaybackError("无效的播放源"); return; }
        if (this.currSong && songWithDuration && songWithDuration.duration) this.currSong.duration = songWithDuration.duration;
        this.retryCount = 0; audio.stop(); audio.src = src; audio.play();
    },
    change(dir) {
        if (this.pendingSongId) { prompt.showToast({ message: '正在切歌...' }); return; }
        if (this.isFmMode) { if (dir < 0) { prompt.showToast({ message: '私人FM不支持上一首哦' }); return; } this.playCurrent(); return; }
        if (!this.playList || this.playList.length === 0) return;
        switch (this.playMode) {
            case 0: case 1: this.currentIndex = (this.currentIndex + dir + this.playList.length) % this.playList.length; break;
            case 2:
                if (!this.shuffledPlayList || this.shuffledPlayList.length !== this.playList.length) this.generateShuffledList(false);
                this.shuffledIndex = (this.shuffledIndex + dir + this.shuffledPlayList.length) % this.shuffledPlayList.length;
                this.currentIndex = this.shuffledPlayList[this.shuffledIndex];
                break;
        }
        this.playCurrent();
    },

    generateShuffledList(locateCurrent = true) {
        console.log("生成新的随机播放列表...");
        this.shuffledPlayList = Array.from(this.playList.keys());
        
        for (let i = this.shuffledPlayList.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [this.shuffledPlayList[i], this.shuffledPlayList[j]] = [this.shuffledPlayList[j], this.shuffledPlayList[i]];
        }

        if (locateCurrent) {
            const currentShuffledIndex = this.shuffledPlayList.indexOf(this.currentIndex);
            this.shuffledIndex = (currentShuffledIndex !== -1) ? currentShuffledIndex : 0;
        }
        console.log("随机列表已生成, 当前随机索引:", this.shuffledIndex);
    },

    // --- FM 模式逻辑 (已重构) ---
    async dostartFmMode(initialSongId = null, initialSongInfo = null) {
        if (this.isFetchingFm) return;

        this.isFmMode = true;
        this.isFetchingFm = true;
        this.playList = [];
        this.fmQueue = [];
        audio.stop();
        prompt.showToast({ message: '正在开启私人FM...' });

        if (initialSongId && initialSongInfo) {
            try { this.fmQueue.push(JSON.parse(initialSongInfo)); }
            catch(e) { console.error("解析FM初始歌曲信息失败"); }
        }

        try {
            await this.fetchNextFmSongs();
            if (this.fmQueue.length > 0) this.playCurrent();
            else { prompt.showToast({ message: '无法获取FM歌曲，请检查网络' }); this.isFmMode = false; }
        } catch (error) {
            prompt.showToast({ message: '启动FM失败' });
            this.isFmMode = false;
        } finally {
            this.isFetchingFm = false;
        }
    },
    async fetchNextFmSongs() {
        if (this.isFetchingFm) return;
        this.isFetchingFm = true;
        console.log("正在获取新的FM歌曲...");
        try {
            const newSongs = await apiService.getPersonalFmSongs(this.cookie);
            if (newSongs.length > 0) {
                this.fmQueue.push(...newSongs);
                console.log(`成功获取 ${newSongs.length} 首FM歌曲，当前队列长度: ${this.fmQueue.length}`);
            } else {
                prompt.showToast({ message: '没有更多FM推荐了' });
            }
        } catch (error) {
            console.error("获取FM歌曲失败:", error);
            prompt.showToast({ message: '获取新歌失败' });
        } finally {
            this.isFetchingFm = false;
        }
    },

    // --- 歌词处理逻辑 (保持不变) ---
    fetchLyric(songId) {
        this.resetLyrics();
        const downloadedInfo = this.downloadedSongs[songId];
        if (downloadedInfo?.localLyricUri) this.loadLyricFromFile(downloadedInfo.localLyricUri, songId);
        else this.fetchLyricOnline(songId);
    },
    loadLyricFromFile(uri, songId) {
        file.readText({
            uri: uri,
            success: (data) => { try { this.processAndMergeLyrics(JSON.parse(data.text)); } catch (e) { this.fetchLyricOnline(songId); } },
            fail: () => this.fetchLyricOnline(songId)
        });
    },
    async fetchLyricOnline(songId) {
        try {
            const lyricData = await apiService.getLyricData(songId, this.cookie);
            this.processAndMergeLyrics(lyricData);
        } catch (error) { 
            this.lyrics = [{ time: 0, text: '歌词加载失败' }]; 
        }
    },
    parseLyric(lrcString) {
        const lines = lrcString.split('\n'), result = [], timeRegex = /\[(\d{2}):(\d{2})\.(\d{2,3})\]/;
        for (const line of lines) {
            const match = timeRegex.exec(line);
            if (match) {
                const time = parseInt(match[1]) * 60 + parseInt(match[2]) + parseInt(match[3].padEnd(3, '0')) / 1000;
                const text = line.replace(timeRegex, '').trim();
                if (text) result.push({ time, text });
            }
        }
        return result;
    },
    mergeLyrics(original, translation, romaji) {
        const createMap = (arr) => new Map(arr.map(item => [item.time.toFixed(3), item.text]));
        if (romaji && translation) {
            this.playerState.lyricType = 'japanese';
            const transMap = createMap(translation), romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)), romaji: romaMap.get(line.time.toFixed(3)) }));
        } 
        else if (romaji && !translation) {
            this.playerState.lyricType = 'cantonese';
            const romaMap = createMap(romaji);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, romaji: romaMap.get(line.time.toFixed(3)) }));
        }
        else if (translation) {
            this.playerState.lyricType = 'english';
            const transMap = createMap(translation);
            this.lyrics = original.map(line => ({ time: line.time, original: line.text, translation: transMap.get(line.time.toFixed(3)) }));
        } else {
            this.playerState.lyricType = 'chinese';
            this.lyrics = original.map(line => ({ time: line.time, original: line.text }));
        }
        if (this.lyrics.length === 0) this.lyrics = [{ time: 0, text: '暂无歌词' }];
    },
    getExtraLyricText(lineData) {
        if (!lineData) return '';
        let extraText = '';
        const lyricSettings = this.settings.lyrics || {};
        switch (this.playerState.lyricType) {
            case 'japanese':
                if (lyricSettings.japaneseMode === 'translation') extraText = lineData.translation || '';
                else if (lyricSettings.japaneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'cantonese':
                if (lyricSettings.cantoneseMode === 'romaji') extraText = lineData.romaji || '';
                break;
            case 'english':
                if (lyricSettings.englishMode === 'translation') extraText = lineData.translation || '';
                break;
        }
        return extraText;
    },


    // --- 歌词处理逻辑 (核心重构) ---

    /**
     * 【【【UI Bug 修复】】】
     * 修正 map 方法的参数顺序 (element, index)
     */
     buildVisibleLyrics() {
        if (!this.lyrics || this.lyrics.length === 0) {
            this.fullVisibleLyrics = [];
            return;
        }
        console.log("手动构建渲染歌词列表...");
        // 【【【核心修正】】】 将 (index, line) 改为 (line, index)
        this.fullVisibleLyrics = this.lyrics.map((line, index) => {
            const uniqueId = `lyric-${line.time}-${index}`;
            return {
                id: uniqueId,
                original: line.original || line.text || '',
                // 现在这里的判断是正确的：对象.属性 === 数字
                isCurrent: index === this.playerState.currentLyricIndex,
                extra: index === this.playerState.currentLyricIndex ? this.getExtraLyricText(line) : null,
                isSelected: false,
            };
        });
    },


    /**
     * 【【【UI Bug 修复】】】
     * 更新当前高亮行，使用不可变性原则确保UI刷新
     * @param {number} newIndex - 新的高亮行索引
     */
     updateCurrentLyricLine(newIndex) {
        const oldIndex = this.playerState.currentLyricIndex;
        if (oldIndex === newIndex) return; // 索引未变，无需操作

        // 【【【核心修复】】】
        // 遵循不可变性原则，通过创建新对象来触发UI更新

        // 1. 更新旧行：创建一个新的、不含 isCurrent 的对象来替换旧对象
        if (oldIndex >= 0 && oldIndex < this.fullVisibleLyrics.length) {
            const oldLine = this.fullVisibleLyrics[oldIndex];
            this.fullVisibleLyrics.splice(oldIndex, 1, {
                ...oldLine,
                isCurrent: false,
                extra: null,
            });
        }

        // 2. 更新新行：同样，创建一个新的、包含 isCurrent 的对象来替换
        if (newIndex >= 0 && newIndex < this.fullVisibleLyrics.length) {
            const newLineDataFromOriginal = this.lyrics[newIndex]; // 从原始数据获取
            const newLine = this.fullVisibleLyrics[newIndex];
            this.fullVisibleLyrics.splice(newIndex, 1, {
                ...newLine,
                isCurrent: true,
                extra: this.getExtraLyricText(newLineDataFromOriginal),
            });
        }
        
        // 3. 更新状态
        this.playerState.currentLyricIndex = newIndex;

        // 4. 在DOM更新后滚动
        this.$nextTick(() => {
            this.scrollToCurrentLyric();
        });
    },


    /**
     * 【【【核心重构】】】
     * 歌词时间更新逻辑
     */
    updateLyric() {
        // 1. 只有在歌词页面才执行计算
        if (this.swiperCurrentIndex !== 1 || !this.lyrics || this.lyrics.length === 0) {
            return;
        }

        // 2. 幽灵时间
        const lookaheadTime = this.playerState.playDuration + (this.settings.lyricAdvanceTime || 1.8);

        // 3. 快速路径检查
        const currentIndex = this.playerState.currentLyricIndex;
        if (currentIndex > -1) {
            const currentLine = this.lyrics[currentIndex];
            const nextLine = this.lyrics[currentIndex + 1];
            if (nextLine && lookaheadTime >= currentLine.time && lookaheadTime < nextLine.time) {
                return; // 时间在当前行范围内，不计算
            }
        }

        // 4. 二分查找优化，比 findIndex 更高效
        let low = 0, high = this.lyrics.length - 1, newIndex = 0;
        while(low <= high) {
            let mid = Math.floor((low + high) / 2);
            if (this.lyrics[mid].time > lookaheadTime) {
                high = mid - 1;
            } else {
                newIndex = mid;
                low = mid + 1;
            }
        }
        
        // 5. 【关键】调用新的更新函数，只修改数据，不重建数组
        this.updateCurrentLyricLine(newIndex);
    },

    /**
     * 【【【核心重构】】】
     * 滚动到当前歌词，优化DOM查询
     * @param {boolean} isInitial - 是否是初次进入页面
     */
    scrollToCurrentLyric(isInitial = false) {
        if (this.swiperCurrentIndex !== 1 || !this._lyricsScrollView || this.playerState.currentLyricIndex < 0) {
            return;
        }

        const lineElement = this.$element(`lyric-line-${this.playerState.currentLyricIndex}`);
        if (!lineElement) return;

        // 使用回调链避免竞态
        this._lyricsScrollView.getBoundingClientRect({
            success: (scrollRect) => {
                lineElement.getBoundingClientRect({
                    success: (lineRect) => {
                        const targetCenterY = scrollRect.height * 0.4;
                        const lineTopInContainer = lineRect.top - scrollRect.top;
                        const scrollOffset = (lineTopInContainer + lineRect.height / 2) - targetCenterY;
                        
                        this._lyricsScrollView.scrollBy({ 
                            top: scrollOffset, 
                            // 初次进入时无动画，后续切换有动画
                            behavior: isInitial ? 'instant' : 'smooth' 
                        });
                    }
                });
            }
        });
    },
    
    /**
     * 【【【核心重构】】】
     * 重置歌词时，不仅要清空原始数据，也要清空视图数据
     * 这个函数在切歌开始时 (updateUiForNewSong) 被调用
     */
     resetLyrics() {
        this.lyrics = [];
        this.fullVisibleLyrics = []; // 【重要】确保清空，为新歌词腾出空间
        this.playerState.currentLyricIndex = -1;
        
        // 同时重置选中状态
        this.selectedLyricIndex = -1;
        if (this.selectionTimeoutId) {
            clearTimeout(this.selectionTimeoutId);
            this.selectionTimeoutId = null;
        }
    },

    /**
     * 【【【核心重构】】】
     * 此函数现在只在获取到新歌词数据时被调用一次。
     */
     processAndMergeLyrics(data) {
        // 1. 解析歌词 (这部分逻辑不变)
        if (!data?.lrc?.lyric) { this.lyrics = [{ time: 0, text: '暂无歌词' }]; }
        else {
            const original = this.parseLyric(data.lrc.lyric);
            const translation = data.tlyric?.lyric ? this.parseLyric(data.tlyric.lyric) : null;
            const romaji = data.romalrc?.lyric ? this.parseLyric(data.romalrc.lyric) : null;
            this.mergeLyrics(original, translation, romaji);
        }
        
        // 2. 【【【关键】】】解析完成后，立即构建一次用于渲染的歌词列表
        this.buildVisibleLyrics();
        
        // 3. 立即定位到当前播放时间的歌词行
        //    这可以确保即使用户在歌曲加载完成前已经滑到歌词页，也能看到正确的高亮
        this.updateLyric();
    },
    // --- 播放器事件绑定 (已补全系统全局控制事件) ---
    bindAudioEvents() {
        // 同步播放/暂停状态
        audio.onplay = () => {
            if (!this.playerState.isPlaying) {
                this.playerState.isPlaying = true;
                if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
                audio.play();
                this.pendingSongId = null;
                console.log("Global Control: PLAY state synced.");
            }
        };
        
        audio.onpause = () => {
            if (this.playerState.isPlaying) {
                this.playerState.isPlaying = false;
                audio.pause();
                console.log("Global Control: PAUSE state synced.");
            }
        };

        // 停止时触发 (通常由 audio.stop() 或切歌引起)
        audio.onstop = () => {
            this.playerState.isPlaying = false;
            // 如果是因切换歌曲等原因停止，也应清除超时和等待状态
            if (this.playTimeoutId) {
                clearTimeout(this.playTimeoutId);
                this.playTimeoutId = null;
            }
            this.pendingSongId = null;
            console.log("Event: onstop. 播放已停止。");
        };

        // 发生错误时触发
        audio.onerror = () => {
            this.handlePlaybackError("播放器发生错误");
        };

        // 播放进度更新时触发
        audio.ontimeupdate = () => {
            // 只有在非“等待播放”状态下才更新进度，防止新歌加载时进度条乱跳
            if (!this.pendingSongId) {
                this.playerState.playDuration = audio.currentTime;
                this.updateLyric(); // 同步更新歌词
            }
        };

        // 当前歌曲播放自然结束时触发
        audio.onended = () => {
            console.log(`Event: onended. 播放结束。当前时间: ${audio.currentTime}, 总时长: ${audio.duration}.`);
            
            // 【关键】防御性检查，防止框架提前触发 onended 的 BUG
            const timeDifference = Math.abs(audio.duration - audio.currentTime);
            if (audio.duration > 0 && timeDifference > 2) {
                console.error("!!! 框架BUG警告: onended 事件在歌曲结束前被过早触发 !!!");
            }

            // 如果是单曲循环模式，则重新播放当前歌曲
            if (this.playMode === 1) {
                this.playCurrent();
            } else {
                // 否则，切换到下一首
                this.change(1);
            }
        };


        // 2. 系统全局媒体控制事件 (从网易云代码中发现)
        // ----------------------------------------------------
        // 这些事件允许应用响应来自系统UI、蓝牙设备等的控制命令

        // 响应“播放上一首”命令
        audio.onctrlplayprev = () => {
            prompt.showToast({ message: '上一首' });
            this.change(-1);
        };

        // 响应“播放下一首”命令
        audio.onctrlplaynext = () => {
            prompt.showToast({ message: '下一首' });
            this.change(1);
        };

        // 响应“音量增加”命令
        audio.onctrlvolumeup = () => {
            // 获取当前音量并增加 0.1，最大为 1
            audio.getPlayState({
                success: function (state) {
                    const newVolume = state.volume > 0.9 ? 1 : state.volume + 0.1;
                    audio.volume = newVolume;
                    prompt.showToast({ message: `音量: ${Math.round(newVolume * 100)}%` });
                },
                fail: function (data, code) {
                    console.error(`[全局控制] 获取播放状态失败: code=${code}`);
                }
            });
        };

        // 响应“音量减少”命令
        audio.onctrlvolumedown = () => {
            // 获取当前音量并减少 0.1，最小为 0
            audio.getPlayState({
                success: function (state) {
                    const newVolume = state.volume < 0.1 ? 0 : state.volume - 0.1;
                    audio.volume = newVolume;
                    prompt.showToast({ message: `音量: ${Math.round(newVolume * 100)}%` });
                },
                fail: function (data, code) {
                    console.error(`[全局控制] 获取播放状态失败: code=${code}`);
                }
            });
        };
    },


    // --- 数据加载与重置 ---
    async loadSettings() {
        try {
            const data = await fileService.readJson(CONSTANTS.SETTINGS_FILE_URI);
            if (data) {
                // 【【【修改】】】确保 gestures 能被正确合并
                this.settings = { 
                    ...this.settings, 
                    ...data, 
                    lyrics: { ...this.settings.lyrics, ...(data.lyrics || {}) }, 
                    audioQuality: { ...this.settings.audioQuality, ...(data.audioQuality || {}) },
                    gestures: { ...this.settings.gestures, ...(data.gestures || {}) } // 新增合并
                };
                console.log("播放器设置加载成功，手势配置:", this.settings.gestures);
            }
        } catch (e) { console.log("无法加载播放器设置，使用默认值。"); }
    },
    async loadCookie() {
        try {
            let rawText;
            try { rawText = (await fileService._promisify(file.readText, { uri: CONSTANTS.COOKIE_FILE_URI })).text; }
            catch(e) { rawText = null; }
            this.cookie = rawText || null;
            if (this.cookie) console.log("Cookie 加载成功。");
        } catch (e) { this.cookie = null; }
    },
    async loadListFromFile() { this.playList = await fileService.readJson(CONSTANTS.FILE_PLAY_LIST, []); },
    async loadDownloadedSongs() { this.downloadedSongs = await fileService.readJson(CONSTANTS.FILE_DOWNLOADED_SONGS, {}); },
    resetPlayer() {
        audio.stop();
        this.currSong = null;
        this.playerState.isPlaying = false;
        this.playerState.playDuration = 0;
        this.isChangingSong = false;
        this.retryCount = 0;
        this.resetLyrics();
    },

    // --- 错误处理 ---
    handlePlaybackError(message) {
        if (this.playTimeoutId) { clearTimeout(this.playTimeoutId); this.playTimeoutId = null; }
        this.pendingSongId = null;
        this.retryCount++;
        prompt.showToast({ message: `${message} (尝试第 ${this.retryCount} 次)` });
        if (this.retryCount >= CONSTANTS.MAX_PLAYBACK_RETRIES) {
            prompt.showToast({ message: `多次尝试失败，已停止播放`, duration: 5000 });
            this.resetPlayer();
            return;
        }
        setTimeout(() => { this.change(1); }, 1500 + (this.retryCount * 1000));
    },

    // --- 工具函数 ---
    second2time(second) {
        if (isNaN(second) || second < 0) return "00:00";
        const sec = Math.floor(second % 60).toString().padStart(2, "0");
        const min = Math.floor(second / 60).toString().padStart(2, "0");
        return `${min}:${sec}`;
    },
};
</script>
