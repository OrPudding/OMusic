<template>
    <div class="list-container">
        <!-- 1. 标题根据 listType 动态变化 -->
        <text class="title" onclick="goBack">{{ pageTitle }}</text>
        <div class="list">
            <!-- 2. 循环 songList，并将整个 $item 对象传递给事件处理器 -->
            <div for="{{ songList }}" class="song-item">
                <text class="item-index">{{$idx + 1}}</text>
                <div class="song-info" onclick="play($item.id)">
                    <text class="song-title">{{ $item.name }}</text>
                    <text class="song-artist">{{ $item.artists }}</text>
                </div>
                <text class="delete-btn" onclick="deleteSong($item)">×</text>
            </div>
        </div>
        <text if="{{ listType === 'downloadlist' }}" class="clear-btn" onclick="clearDownloadQueue">清空队列</text>
    </div>
</template>


<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";

export default {
    protected: {
        // 1. 列表类型总开关，可由外部传入。默认为 'playlist'
        listType: 'playlist', // 'playlist', 'downloadlist', 'songlist'
        songlistId: null, // 为 'songlist' 类型预留的歌单ID
    },

    private: {
        songList: [],
        pageTitle: "播放列表", // 页面标题
        // 文件路径
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
    },

    onInit() {
        this.updatePageTitle();
        this.loadData();
    },

    onShow() {
        // 每次返回页面时都重新加载数据，确保同步
        this.loadData();
    },

    // 2. 根据 listType 更新页面标题
    updatePageTitle() {
        switch (this.listType) {
            case 'downloadlist':
                this.pageTitle = "已下载";
                break;
            case 'songlist':
                this.pageTitle = "歌单详情"; // 未来可以动态显示歌单名
                break;
            case 'playlist':
            default:
                this.pageTitle = "播放列表";
                break;
        }
    },

    // 3. 根据 listType 加载不同的数据源
    loadData() {
        switch (this.listType) {
            case 'downloadlist':
                this.loadDownloadedList();
                break;
            case 'songlist':
                // 预留歌单加载逻辑
                console.log("加载歌单功能待实现，ID:", this.songlistId);
                this.songList = []; // 暂时清空
                break;
            case 'playlist':
            default:
                this.loadPlayList();
                break;
        }
    },

    loadPlayList() {
        file.readText({
            uri: this.listFileUri,
            success: (data) => {
                try {
                    this.songList = JSON.parse(data.text || "[]").filter(item => !!item);
                } catch (e) { this.songList = []; }
            },
            fail: () => { this.songList = []; }
        });
    },

    loadDownloadedList() {
        file.readText({
            uri: this.downloadedFileUri,
            success: (data) => {
                try {
                    const downloadedSongs = JSON.parse(data.text || "{}");
                    // 将对象转换为数组并赋值给 songList
                    this.songList = Object.values(downloadedSongs).filter(item => !!item);
                } catch (e) { this.songList = []; }
            },
            fail: () => { this.songList = []; }
        });
    },

    // 4. 根据 listType 执行不同的删除操作
    deleteSong(songToDelete) {
        switch (this.listType) {
            case 'downloadlist':
                // "彻底删除"：删除本地文件和所有记录
                this.deleteFromDownloaded(songToDelete);
                break;
            case 'songlist':
                // 预留：未来可能是从歌单中移除（需要API调用）
                prompt.showToast({ message: '此功能待实现' });
                break;
            case 'playlist':
            default:
                // "仅移除"：只从播放列表中移除
                this.deleteFromPlayList(songToDelete.id);
                break;
        }
    },

    // 删除逻辑：仅从播放列表移除
    deleteFromPlayList(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            this.savePlayList(); // 保存更新后的播放列表
            prompt.showToast({ message: '已从播放列表移除' });
        }
    },

    // 删除逻辑：彻底删除已下载的歌曲
    deleteFromDownloaded(songToDelete) {
        // a. 从UI上立即移除
        const index = this.songList.findIndex(item => item.id === songToDelete.id);
        if (index > -1) {
            this.songList.splice(index, 1);
        }
        
        // b. 通知播放器页面执行物理文件删除和记录清理
        prompt.showToast({ message: '正在清理本地文件...', duration: 1500 });
        router.replace({
            uri: "/pages/player",
            params: {
                action: 'delete',
                songToDelete: JSON.stringify(songToDelete)
            }
        });
    },

    // 辅助函数：保存播放列表
    savePlayList() {
        file.writeText({
            uri: this.listFileUri,
            text: JSON.stringify(this.songList, null, 2),
        });
    },

    // 5. 播放逻辑保持不变，但需要确保播放列表是最新的
    play(songId) {
        // 如果当前是下载列表，点击播放时，需要将整个下载列表设置为播放列表
        if (this.listType === 'downloadlist') {
            // 将当前的下载列表（this.songList）覆盖到 play_list.json
            this.savePlayList();
        }
        
        // 然后跳转到播放器，并传递要播放的 songId
        router.replace({
            uri: "/pages/player",
            params: {
                songId: songId,
                // 将当前列表序列化为 JSON 字符串进行传递
                playList: JSON.stringify(this.songList) 
            },
        });
    },

        /**
     * @description 清空整个下载队列。
     * - 停止当前正在进行的下载任务。
     * - 清空内存中的 downloadQueue 数组。
     * - 清空 download_queue.json 文件。
     * - 将所有处于 'waiting' 或 'downloading' 状态的歌曲重置为 'none' 或 'failed'。
     */
     async clearDownloadQueue() {
        console.log("[下载管理器] 开始清空下载队列...");
        prompt.showToast({ message: '正在清空下载队列...', duration: 1500 });

        // 1. 停止当前的下载进程
        this.isDownloading = false; 
        // 注意：request.download 没有提供直接的 cancel 方法。
        // isDownloading = false 会阻止 processDownloadQueue 启动新的下载。
        // 当前正在下载的文件可能会完成，但不会被正确处理，这在多数情况下可以接受。

        // 2. 清空内存中的队列
        const songsToReset = [...this.downloadQueue]; // 复制一份需要重置状态的歌曲列表
        this.downloadQueue = [];

        try {
            // 3. 清空持久化的队列文件
            await this.saveDownloadQueue(); // saveDownloadQueue 内部会写入一个空的 "[]"

            // 4. 更新播放列表中相关歌曲的下载状态
            let stateChanged = false;
            this.playList = this.playList.map(song => {
                // 检查这首歌是否在被清空的队列中
                if (songsToReset.some(queuedSong => queuedSong.id === song.id)) {
                    // 如果歌曲下载状态是等待或下载中，则重置
                    if (song.downloadState === 'waiting' || song.downloadState === 'downloading') {
                        stateChanged = true;
                        // 可以设置为 'none' 或 'failed'，'failed' 更能表明它曾尝试下载但被中断
                        return { ...song, downloadState: 'failed' }; 
                    }
                }
                return song;
            });

            // 如果播放列表的状态有变，则保存
            if (stateChanged) {
                this.saveListFile();
            }

            console.log("[下载管理器] 下载队列已成功清空。");
            prompt.showToast({ message: '下载队列已清空', duration: 2000 });

        } catch (error) {
            console.error("[下载管理器] 清空下载队列时发生错误:", error);
            prompt.showToast({ message: '清空失败，请重试', duration: 2000 });
            // 失败时可以考虑恢复 this.downloadQueue = songsToReset; 但通常让它保持清空状态更简单
        }
    },

    goBack() {
        router.back();
    },
};
</script>

<style>
/* 样式部分无需修改，保持原样即可 */
.list-container {
	width: 100%;
	height: 100%;
	flex-direction: column;
	align-items: center;
	background-color: black;
}

.title {
	font-size: 32px;
	padding: 10px;
	text-align: center;
  font-weight: bold;
	color: #fff;
}

.delete-btn {
	width: 63px;
	height: 63px;
	color: #ff4444;
	background-color: rgba(255, 255, 255, 0.08);
	border-radius: 36px;
	font-size: 50px;
	text-align: center;
}

.list {
	flex-direction: column;
	padding-bottom: 60px;
}

.song-item {
	padding: 25px;
	width: 300px;
	margin: 5px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	justify-content: space-between;
}

.item-index {
	width: 60px;
	height: 100%;
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
}

.song-info {
	flex-direction: column;
}

.song-title {
	font-size: 26px;
	color: #fff;
}

.song-artist {
	font-size: 22px;
	color: #888;
}

.clear-btn {
    width: 200px;
    height: 60px;
    font-size: 26px;
    color: #fff;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 36px;
    text-align: center;
}
</style>
