<template>
    <div class="list-container">
        <!-- 1. 标题根据 listType 动态变化 -->
        <text class="title" onclick="goBack">{{ pageTitle }}</text>
        <div class="list">
            <!-- 2. 循环 songList，并将整个 $item 对象传递给事件处理器 -->
            <div for="{{ songList }}" class="song-item">
                <text class="item-index">{{$idx + 1}}</text>
                <div class="song-info" onclick="play($item.id)">
                    <text class="song-title">{{ $item.name }}</text>
                    <text class="song-artist">{{ $item.artists }}</text>
                </div>
                <text class="delete-btn" onclick="deleteSong($item)">×</text>
            </div>
        </div>
    </div>
</template>


<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";

export default {
    protected: {
        // 1. 列表类型总开关，可由外部传入。默认为 'playlist'
        listType: 'playlist', // 'playlist', 'downloadlist', 'songlist'
        songlistId: null, // 为 'songlist' 类型预留的歌单ID
    },

    private: {
        songList: [],
        pageTitle: "播放列表", // 页面标题
        // 文件路径
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
    },

    onInit() {
        this.updatePageTitle();
        this.loadData();
    },

    onShow() {
        // 每次返回页面时都重新加载数据，确保同步
        this.loadData();
    },

    // 2. 根据 listType 更新页面标题
    updatePageTitle() {
        switch (this.listType) {
            case 'downloadlist':
                this.pageTitle = "已下载";
                break;
            case 'songlist':
                this.pageTitle = "歌单详情"; // 未来可以动态显示歌单名
                break;
            case 'playlist':
            default:
                this.pageTitle = "播放列表";
                break;
        }
    },

    // 3. 根据 listType 加载不同的数据源
    loadData() {
        switch (this.listType) {
            case 'downloadlist':
                this.loadDownloadedList();
                break;
            case 'songlist':
                // 预留歌单加载逻辑
                console.log("加载歌单功能待实现，ID:", this.songlistId);
                this.songList = []; // 暂时清空
                break;
            case 'playlist':
            default:
                this.loadPlayList();
                break;
        }
    },

    loadPlayList() {
        file.readText({
            uri: this.listFileUri,
            success: (data) => {
                try {
                    this.songList = JSON.parse(data.text || "[]").filter(item => !!item);
                } catch (e) { this.songList = []; }
            },
            fail: () => { this.songList = []; }
        });
    },

    loadDownloadedList() {
        file.readText({
            uri: this.downloadedFileUri,
            success: (data) => {
                try {
                    const downloadedSongs = JSON.parse(data.text || "{}");
                    // 将对象转换为数组并赋值给 songList
                    this.songList = Object.values(downloadedSongs).filter(item => !!item);
                } catch (e) { this.songList = []; }
            },
            fail: () => { this.songList = []; }
        });
    },

    // 4. 根据 listType 执行不同的删除操作
    deleteSong(songToDelete) {
        switch (this.listType) {
            case 'downloadlist':
                // "彻底删除"：删除本地文件和所有记录
                this.deleteFromDownloaded(songToDelete);
                break;
            case 'songlist':
                // 预留：未来可能是从歌单中移除（需要API调用）
                prompt.showToast({ message: '此功能待实现' });
                break;
            case 'playlist':
            default:
                // "仅移除"：只从播放列表中移除
                this.deleteFromPlayList(songToDelete.id);
                break;
        }
    },

    // 删除逻辑：仅从播放列表移除
    deleteFromPlayList(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            this.savePlayList(); // 保存更新后的播放列表
            prompt.showToast({ message: '已从播放列表移除' });
        }
    },

    // 删除逻辑：彻底删除已下载的歌曲
    deleteFromDownloaded(songToDelete) {
        // a. 从UI上立即移除
        const index = this.songList.findIndex(item => item.id === songToDelete.id);
        if (index > -1) {
            this.songList.splice(index, 1);
        }
        
        // b. 通知播放器页面执行物理文件删除和记录清理
        prompt.showToast({ message: '正在清理本地文件...', duration: 1500 });
        router.replace({
            uri: "/pages/player",
            params: {
                action: 'delete',
                songToDelete: JSON.stringify(songToDelete)
            }
        });
    },

    // 辅助函数：保存播放列表
    savePlayList() {
        file.writeText({
            uri: this.listFileUri,
            text: JSON.stringify(this.songList, null, 2),
        });
    },

    // 5. 播放逻辑保持不变，但需要确保播放列表是最新的
    play(songId) {
        // 如果当前是下载列表，点击播放时，需要将整个下载列表设置为播放列表
        if (this.listType === 'downloadlist') {
            // 将当前的下载列表（this.songList）覆盖到 play_list.json
            this.savePlayList();
        }
        
        // 然后跳转到播放器，并传递要播放的 songId
        router.replace({
            uri: "/pages/player",
            params: {
                songId: songId,
                // 将当前列表序列化为 JSON 字符串进行传递
                playList: JSON.stringify(this.songList) 
            },
        });
    },

    goBack() {
        router.back();
    },
};
</script>

<style>
/* 样式部分无需修改，保持原样即可 */
.list-container {
	width: 100%;
	height: 100%;
	flex-direction: column;
	align-items: center;
	background-color: black;
}

.title {
	font-size: 32px;
	padding: 10px;
	text-align: center;
  font-weight: bold;
	color: #fff;
}

.delete-btn {
	width: 63px;
	height: 63px;
	color: #ff4444;
	background-color: rgba(255, 255, 255, 0.08);
	border-radius: 36px;
	font-size: 50px;
	text-align: center;
}

.list {
	flex-direction: column;
	padding-bottom: 60px;
}

.song-item {
	padding: 25px;
	width: 300px;
	margin: 5px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	justify-content: space-between;
}

.item-index {
	width: 60px;
	height: 100%;
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
}

.song-info {
	flex-direction: column;
}

.song-title {
	font-size: 26px;
	color: #fff;
}

.song-artist {
	font-size: 22px;
	color: #888;
}
@media (shape: pill-shaped) or (max-width: 106) {
	.list-container {
		padding: 10px;
	}
	.list {
		width: 100%;
		margin-top: 10px;
	}
	.title {
		font-size: 28px;
	}

	.item {
		display: flex;
		width: 100%;
		height: 100px;
		padding-bottom: 8px;
	}

	.item-index {
		width: 40px;
		height: 100%;
		text-align: center;
	}
	.item-title {
		font-size: 22px;
	}
	.item-subtitle {
		font-size: 20px;
	}
}
</style>
