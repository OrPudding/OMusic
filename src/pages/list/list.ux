<template>
    <scroll scroll-y="true" class="list-container" bounces="true">
        <!-- 1. 标题根据 listType 动态变化 -->
        <text class="time-display">{{currentTime}}</text>
        <text class="title" onclick="goBack">‹{{ pageTitle }}</text>
        <div class="list">
            <!-- 2. 循环 songList，并将整个 $item 对象传递给事件处理器 -->
            <div for="{{ songList }}" class="song-item">
                <text class="item-index">{{$idx + 1}}</text>
                <div class="song-info" onclick="play($item.id)">
                    <text class="song-title">{{ $item.name }}</text>
                    <text class="song-artist">{{ $item.artists }}</text>
                </div>
                <image class="delete-btn" src="/common/icon/cancel.png" onclick="deleteSong($item)"></image>
            </div>
        </div>
        <!-- <text if="{{ listType === 'downloadlist' }}" class="clear-btn" onclick="clearDownloadQueue">清空队列</text> -->
    </scroll>
</template>
<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import fetch from "@system.fetch";

// 健壮的文件服务封装，用于所有文件操作
const fileService = {
    _promisify(fn, options) {
        return new Promise((resolve, reject) => {
            fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) });
        });
    },
    async readJson(uri, defaultValue = null) {
        try {
            const data = await this._promisify(file.readText, { uri });
            return JSON.parse(data.text);
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] readJson 失败: ${uri}`, error);
            return defaultValue;
        }
    },
    async writeJson(uri, data) {
        try {
            await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) });
            return true;
        } catch (error) {
            console.error(`[FileService] writeJson 失败: ${uri}`, error);
            return false;
        }
    },
    async delete(uri) {
        try {
            await this._promisify(file.delete, { uri });
            return true;
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] delete 失败: ${uri}`, error);
            return false;
        }
    },
    // 新增：确保目录存在
    async ensureDirExists(uri) {
        try {
            await this._promisify(file.mkdir, { uri });
        } catch (error) {
            // 忽略目录已存在的错误
        }
    }
};


export default {
    protected: {
        listType: 'playlist',
        songlistId: null,
    },

    private: {
        songList: [],
        pageTitle: "播放列表",
        currentTime: "00:00",
        isLoading: false,
        // --- **核心修正 1: 新增歌单缓存目录** ---
        songlistsDir: 'internal://files/songlists/',
        // ---
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
        favoritesFileUri: 'internal://files/favorites.json',
        musicDir: 'internal://files/music/',
        lyricDir: 'internal://files/lyrics/',
    },

    async onInit() {
        // --- **核心修正 2: 确保歌单缓存目录存在** ---
        await fileService.ensureDirExists(this.songlistsDir);
        // ---
        this.updatePageTitle();
        this.loadData();
        this.updateTime();
        setInterval(() => {
            this.updateTime();
        }, 1000);
    },

    onShow() {
        if (!this.isLoading) {
            this.loadData();
        }
    },

    updateTime() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        this.currentTime = `${hours}:${minutes}`;
    },

    updatePageTitle() {
        const titles = {
            'downloadlist': "已下载",
            'songlist': "歌单详情",
            'favorites': "我的收藏",
            'playlist': "播放列表",
        };
        this.pageTitle = titles[this.listType] || "播放列表";
    },

    loadData() {
        switch (this.listType) {
            case 'downloadlist':
                this.loadDownloadedList();
                break;
            case 'favorites':
                this.loadFavoritesList();
                break;
            case 'songlist':
                this.loadSonglistWithCache(); // 调用新的带缓存的方法
                break;
            case 'playlist':
            default:
                this.loadPlayList();
                break;
        }
    },

    async loadPlayList() {
        this.songList = await fileService.readJson(this.listFileUri, []);
    },

    async loadDownloadedList() {
        const downloadedSongs = await fileService.readJson(this.downloadedFileUri, {});
        this.songList = Object.values(downloadedSongs);
    },

    async loadFavoritesList() {
        const favoriteSongs = await fileService.readJson(this.favoritesFileUri, {});
        this.songList = Object.values(favoriteSongs);
    },

    // --- **核心修正 3: 实现带缓存的歌单加载逻辑** ---
    async loadSonglistWithCache() {
        if (!this.songlistId) {
            prompt.showToast({ message: '未提供歌单ID' });
            return;
        }
        if (this.isLoading) return;
        this.isLoading = true;

        const cacheFileUri = `${this.songlistsDir}${this.songlistId}.json`;

        // 1. 尝试从缓存加载并立即显示
        const cachedList = await fileService.readJson(cacheFileUri, null);
        if (cachedList && cachedList.length > 0) {
            console.log("从缓存加载歌单:", this.songlistId);
            this.songList = cachedList;
        } else {
            // 如果没有缓存，则显示加载提示
            prompt.showToast({ message: '正在加载歌单...' });
        }

        // 2. 异步从网络获取最新数据
        try {
            const newList = await this.fetchSonglistFromNetwork();
            
            // 3. 对比并更新
            // 使用JSON.stringify进行简单的深比较，如果不同则更新UI和缓存
            if (JSON.stringify(this.songList) !== JSON.stringify(newList)) {
                console.log("歌单有更新，正在刷新UI并写入缓存。");
                this.songList = newList;
                await fileService.writeJson(cacheFileUri, newList);
                // 如果之前没有缓存，加载成功后给出提示
                if (!cachedList) {
                    prompt.showToast({ message: `加载完成，共 ${newList.length} 首` });
                }
            } else {
                console.log("歌单无更新。");
            }
        } catch (error) {
            console.error('从网络加载歌单失败:', error);
            // 只有在连缓存都没有的情况下，才提示加载失败
            if (!cachedList) {
                prompt.showToast({ message: `加载失败: ${error.code || '网络错误'}` });
            }
        } finally {
            this.isLoading = false;
        }
    },

    // 将网络请求部分独立成一个函数
    async fetchSonglistFromNetwork() {
        const BASE_URL = 'https://163api.qijieya.cn/playlist/track/all';
        const PAGE_LIMIT = 10;
        const TOTAL_LIMIT = 50;
        let offset = 0;
        let hasMore = true;
        let allSongs = [];

        while (hasMore && allSongs.length < TOTAL_LIMIT ) {
            const currentLimit = Math.min(PAGE_LIMIT, TOTAL_LIMIT - allSongs.length);
            if (currentLimit <= 0) break;

            const url = `${BASE_URL}?id=${this.songlistId}&limit=${currentLimit}&offset=${offset}`;
            
            const response = await new Promise((resolve, reject) => {
                fetch.fetch({ url, success: resolve, fail: (data, code) => reject({ data, code }) });
            });

            const songs = response.data?.songs;

            if (songs && songs.length > 0) {
                const formattedSongs = songs.map(song => ({
                    id: song.id,
                    name: song.name,
                    artists: song.ar.map(artist => artist.name).join(' / '),
                }));
                allSongs.push(...formattedSongs);

                if (songs.length < currentLimit) {
                    hasMore = false;
                } else {
                    offset += songs.length;
                }
            } else {
                hasMore = false;
            }
        }
        return allSongs;
    },
    // --- 修正结束 ---

    // (deleteSong, play, goBack 等其他函数保持不变)
    deleteSong(songToDelete) {
        switch (this.listType) {
            case 'downloadlist':
                this.deleteFromDownloaded(songToDelete);
                break;
            case 'favorites':
                this.deleteFromFavorites(songToDelete.id);
                break;
            case 'songlist':
                prompt.showToast({ message: '暂不支持从在线歌单中删除' });
                break;
            case 'playlist':
            default:
                this.deleteFromPlayList(songToDelete.id);
                break;
        }
    },

    async deleteFromPlayList(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            await this.savePlayList();
            prompt.showToast({ message: '已从播放列表移除' });
        }
    },

    async deleteFromDownloaded(songToDelete) {
        const songId = songToDelete.id;
        prompt.showToast({ message: `正在删除 ${songToDelete.name}...` });
        try {
            const index = this.songList.findIndex(item => item.id === songId);
            if (index > -1) this.songList.splice(index, 1);

            await fileService.delete(`${this.musicDir}${songId}.mp3`);
            await fileService.delete(`${this.lyricDir}${songId}.json`);

            const downloadedSongs = await fileService.readJson(this.downloadedFileUri, {});
            delete downloadedSongs[songId];
            await fileService.writeJson(this.downloadedFileUri, downloadedSongs);

            const playList = await fileService.readJson(this.listFileUri, []);
            const songInList = playList.find(s => s.id === songId);
            if (songInList) {
                songInList.downloadState = 'none';
                await fileService.writeJson(this.listFileUri, playList);
            }
            prompt.showToast({ message: '删除成功' });
        } catch (error) {
            prompt.showToast({ message: `删除失败: ${error.message || '未知错误'}` });
            this.loadData();
        }
    },

    async deleteFromFavorites(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            const favorites = await fileService.readJson(this.favoritesFileUri, {});
            delete favorites[songId];
            await fileService.writeJson(this.favoritesFileUri, favorites);
            prompt.showToast({ message: '已从收藏列表移除' });
        }
    },

    async savePlayList() {
        await fileService.writeJson(this.listFileUri, this.songList);
    },

    async play(songId) {
        await this.savePlayList();
        
        router.replace({
            uri: "/pages/player",
            params: {
                songId: songId,
                playList: JSON.stringify(this.songList) 
            },
        });
    },

    goBack() {
        router.back();
    },
};
</script>

<style>
/* 样式部分无需修改，保持原样即可 */
.list-container {
	width: 100%;
	height: 100%;
	flex-direction: column;
	align-items: center;
	background-color: black;
}

.time-display {
  font-size: 28px;
  color: #ffffff;
  padding: 5px;
  text-align: center;
}

.title {
	font-size: 32px;
	padding: 5px;
	text-align: center;
  font-weight: bold;
	color: #fff;
}

.delete-btn {
	width: 64px;
	height: 64px;
}

.list {
	flex-direction: column;
	padding-bottom: 60px;
}

.song-item {
	padding: 25px;
	width: 360px;
	margin: 5px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	justify-content: space-between;
}

.item-index {
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
}

.song-info {
    width: 200px;
	flex-direction: column;
}

.song-title {
	font-size: 26px;
	color: #fff;
}

.song-artist {
	font-size: 22px;
	color: #888;
}

.clear-btn {
    width: 200px;
    height: 60px;
    font-size: 26px;
    color: #fff;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 36px;
    text-align: center;
}
</style>
