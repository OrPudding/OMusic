<template>
    <!-- 1. 容器绑定了滚动到底部事件 onscrollbottom -->
    <scroll id="songListScroll" class="list-container" scroll-y="true" bounces="true" 
    onscrolltop="handleScrollTop" 
    onscrollbottom="handleScrollBottom">
        
        <!-- 头部信息 -->
        <div class="header">
            <text class="time-display">{{currentTime}}</text>
            <text class="title" onclick="goBack">‹{{ pageTitle }}</text>
        </div>
        
        <!-- 2. 列表内容包裹在一个容器内，用于精确计算滚动 -->
        <div class="list-content">
            <!-- 循环渲染的是 displaySongList (窗口数据)，而不是 fullSongList (完整数据) -->
            <div for="{{ displaySongList }}" class="song-item">
                <!-- 索引是动态计算的，以保证在任何窗口位置都正确 -->
                <text class="item-index">{{ $item.displayIndex }}</text>
                <div class="song-info" onclick="play($item.id)">
                    <text class="song-title">{{ $item.name }}</text>
                    <text class="song-artist">{{ $item.artists }}</text>
                </div>
                <image class="delete-btn" src="/common/icon/cancel.png" onclick="deleteSong($item)"></image>
            </div>
        </div>

        <!-- 3. 底部加载状态提示 -->
        <text class="loading-tip" if="{{ isLoading }}">正在加载...</text>
        <text class="loading-tip" if="{{ !isLoading && fullSongList.length === 0 }}">列表为空</text>
        <text class="loading-tip" if="{{ !isLoading && hasMoreData === false && fullSongList.length > 0 }}">已加载全部</text>

    </scroll>
</template>
<style>
    .list-container {
        width: 100%;
        height: 100%;
        flex-direction: column;
        align-items: center;
        background-color: black;
    }

    .header {
        width: 100%;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .time-display {
        font-size: 28px;
        color: #ffffff;
        padding: 5px;
        text-align: center;
    }

    .title {
        font-size: 32px;
        padding: 5px;
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    .list-content {
        flex-direction: column;
        padding-bottom: 60px;
    }

    .song-item {
        padding: 25px 25px 25px 5px;
        width: 360px;
        /* **关键**: 必须为列表项设置一个固定的高度，用于精确计算滚动补偿 */
        height: 120px; 
        margin: 5px;
        background-color: rgba(255, 255, 255, 0.06);
        border-radius: 36px;
        justify-content: space-between;
    }

    .item-index {
        text-align: center;
        font-size: 28px;
        color: rgba(255, 255, 255, 0.6);
    }

    .song-info {
        width: 200px;
        flex-direction: column;
    }

    .song-title {
        font-size: 26px;
        color: #fff;
    }

    .song-artist {
        font-size: 22px;
        color: #888;
    }

    .delete-btn {
        width: 64px;
        height: 64px;
    }

    .loading-tip {
        width: 100%;
        text-align: center;
        color: #888;
        font-size: 24px;
        padding: 30px;
    }
</style>
<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import fetch from "@system.fetch";

// 文件服务封装
const fileService = {
    _promisify(fn, options) {
        return new Promise((resolve, reject) => {
            fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) });
        });
    },
    async readJson(uri, defaultValue = null) {
        try {
            const data = await this._promisify(file.readText, { uri });
            return JSON.parse(data.text);
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] readJson 失败: ${uri}`, error);
            return defaultValue;
        }
    },
    async writeJson(uri, data) {
        try {
            await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) });
            return true;
        } catch (error) {
            console.error(`[FileService] writeJson 失败: ${uri}`, error);
            return false;
        }
    },
    async delete(uri) {
        try {
            await this._promisify(file.delete, { uri });
            return true;
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] delete 失败: ${uri}`, error);
            return false;
        }
    },
    async ensureDirExists(uri) {
        try {
            await this._promisify(file.mkdir, { uri });
        } catch (error) { /* 忽略错误 */ }
    }
};

const SETTINGS_FILE_URI = 'internal://files/settings.json';

export default {
    protected: {
        listType: 'playlist',
        songlistId: null,
    },

    private: {
        fullSongList: [],
        displaySongList: [],
        
        // --- 懒加载与网络参数 (提供默认值) ---
        WINDOW_SIZE: 30,
        PAGE_SIZE: 15,
        ITEM_HEIGHT: 130,
        TOTAL_LIMIT: 200,
        API_PAGE_SIZE: 50,
        
        displayStartIndex: 0,
        isLoading: false,
        isScrolling: false,
        hasMoreUp: false,
        hasMoreDown: true,

        pageTitle: "播放列表",
        currentTime: "00:00",
        songlistsDir: 'internal://files/songlists/',
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
        favoritesFileUri: 'internal://files/favorites.json',
        musicDir: 'internal://files/music/',
        lyricDir: 'internal://files/lyrics/',
    },

    async onInit() {
        await this.applySettings();
        await fileService.ensureDirExists(this.songlistsDir);
        this.updatePageTitle();
        this.loadData();
        this.updateTime();
        setInterval(() => this.updateTime(), 1000);
    },

    onShow() {
        // 可以在此处决定是否需要刷新数据，例如：
        // if (!this.isLoading) { this.loadData(); }
    },

    async applySettings() {
        try {
            const data = await fileService.readJson(SETTINGS_FILE_URI);
            if (data) {
                if (data.performance) {
                    this.WINDOW_SIZE = data.performance.windowSize || this.WINDOW_SIZE;
                    this.PAGE_SIZE = data.performance.pageSize || this.PAGE_SIZE;
                }
                if (data.network) {
                    this.TOTAL_LIMIT = data.network.totalLimit || this.TOTAL_LIMIT;
                    this.API_PAGE_SIZE = data.network.apiPageSize || this.API_PAGE_SIZE;
                }
                console.log(`列表页设置已应用: Perf(Win:${this.WINDOW_SIZE}, Page:${this.PAGE_SIZE}), Net(Total:${this.TOTAL_LIMIT}, APIPage:${this.API_PAGE_SIZE})`);
            }
        } catch (e) {
            console.log("列表页无法加载设置，使用默认值。");
        }
    },

    updateTime() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        this.currentTime = `${hours}:${minutes}`;
    },

    updatePageTitle() {
        const titles = {
            'downloadlist': "已下载", 'songlist': "歌单详情",
            'favorites': "我的收藏", 'playlist': "播放列表",
        };
        this.pageTitle = titles[this.listType] || "播放列表";
    },

    async loadData() {
        if (this.isLoading) return;
        this.isLoading = true;
        let sourceData = [];
        try {
            switch (this.listType) {
                case 'downloadlist':
                    const downloaded = await fileService.readJson(this.downloadedFileUri, {});
                    sourceData = Object.values(downloaded);
                    break;
                case 'favorites':
                    const favorites = await fileService.readJson(this.favoritesFileUri, {});
                    sourceData = Object.values(favorites);
                    break;
                case 'songlist':
                    sourceData = await this.loadSonglistWithCache();
                    break;
                case 'playlist':
                default:
                    sourceData = await fileService.readJson(this.listFileUri, []);
                    break;
            }
        } catch (error) {
            console.error("加载数据源失败:", error);
            prompt.showToast({ message: "数据加载失败" });
        }
        this.fullSongList = sourceData.map((song, index) => ({ ...song, originalIndex: index + 1 }));
        this.hasMoreDown = this.fullSongList.length > 0;
        this.isLoading = false;
        this.updateDisplayList(0);
    },

    updateDisplayList(startIndex) {
        this.displayStartIndex = Math.max(0, Math.min(startIndex, this.fullSongList.length - this.PAGE_SIZE));
        const endIndex = Math.min(this.displayStartIndex + this.WINDOW_SIZE, this.fullSongList.length);
        this.displaySongList = this.fullSongList.slice(this.displayStartIndex, endIndex).map((song, index) => ({
            ...song,
            displayIndex: this.displayStartIndex + index + 1,
        }));
        this.hasMoreUp = this.displayStartIndex > 0;
        this.hasMoreDown = endIndex < this.fullSongList.length;
    },

    handleScrollTop() {
        if (this.isScrolling || !this.hasMoreUp) return;
        this.isScrolling = true;
        const prevStartIndex = this.displayStartIndex - this.PAGE_SIZE;
        if (prevStartIndex < 0) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(prevStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('songListScroll').scrollTo({ top: scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    handleScrollBottom() {
        if (this.isScrolling || !this.hasMoreDown) return;
        this.isScrolling = true;
        const nextStartIndex = this.displayStartIndex + this.PAGE_SIZE;
        if (nextStartIndex >= this.fullSongList.length) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(nextStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('songListScroll').scrollBy({ top: -scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    async loadSonglistWithCache() {
        if (!this.songlistId) {
            prompt.showToast({ message: '未提供歌单ID' });
            return [];
        }
        const cacheFileUri = `${this.songlistsDir}${this.songlistId}.json`;
        const cachedList = await fileService.readJson(cacheFileUri, null);
        if (cachedList) {
            this.fullSongList = cachedList; // 立即使用缓存数据
            this.updateDisplayList(0);
        } else {
            prompt.showToast({ message: '正在加载歌单...' });
        }
        try {
            const newList = await this.fetchSonglistFromNetwork();
            if (JSON.stringify(cachedList) !== JSON.stringify(newList)) {
                await fileService.writeJson(cacheFileUri, newList);
                if (!cachedList) prompt.showToast({ message: `加载完成` });
                return newList;
            }
            return cachedList || newList;
        } catch (error) {
            if (!cachedList) prompt.showToast({ message: `加载失败` });
            return cachedList || [];
        }
    },

    async fetchSonglistFromNetwork() {
        const BASE_URL = 'https://163api.qijieya.cn/playlist/track/all';
        let offset = 0;
        let hasMore = true;
        let allSongs = [];
        while (hasMore && allSongs.length < this.TOTAL_LIMIT ) {
            const url = `${BASE_URL}?id=${this.songlistId}&limit=${this.API_PAGE_SIZE}&offset=${offset}`;
            try {
                const response = await new Promise((resolve, reject) => fetch.fetch({ url, responseType: 'text', success: resolve, fail: reject }));
                const result = JSON.parse(response.data);
                const songs = result?.songs;
                if (songs && songs.length > 0) {
                    allSongs.push(...songs.map(s => ({ id: s.id, name: s.name, artists: s.ar.map(a => a.name).join(' / ') })));
                    offset += songs.length;
                    if (songs.length < this.API_PAGE_SIZE) hasMore = false;
                } else {
                    hasMore = false;
                }
            } catch (error) {
                console.error("分页获取歌单失败:", error);
                hasMore = false;
            }
        }
        return allSongs;
    },

    async deleteSong(songToDelete) {
        const fullIndex = this.fullSongList.findIndex(item => item.id === songToDelete.id);
        if (fullIndex > -1) {
            this.fullSongList.splice(fullIndex, 1);
            this.updateDisplayList(this.displayStartIndex);
            // 此处应有更完善的持久化删除逻辑
            prompt.showToast({ message: '已移除' });
        }
    },

    async play(songId) {
        await fileService.writeJson(this.listFileUri, this.fullSongList);
        router.replace({
            uri: "/pages/player",
            params: { songId: songId, playList: JSON.stringify(this.fullSongList) },
        });
    },

    goBack() {
        router.back();
    },
};
</script>
