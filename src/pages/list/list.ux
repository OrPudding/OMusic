<template>
    <div class="list-container">
        <!-- 1. 标题根据 listType 动态变化 -->
        <text class="time-display">{{currentTime}}</text>
        <text class="title" onclick="goBack">‹{{ pageTitle }}</text>
        <scroll class="list" bounces="true">
            <!-- 2. 循环 songList，并将整个 $item 对象传递给事件处理器 -->
            <div for="{{ songList }}" class="song-item">
                <text class="item-index">{{$idx + 1}}</text>
                <div class="song-info" onclick="play($item.id)">
                    <text class="song-title">{{ $item.name }}</text>
                    <text class="song-artist">{{ $item.artists }}</text>
                </div>
                <image class="delete-btn" src="/common/icon/cancel.png" onclick="deleteSong($item)"></image>
            </div>
        </scroll>
        <!-- <text if="{{ listType === 'downloadlist' }}" class="clear-btn" onclick="clearDownloadQueue">清空队列</text> -->
    </div>
</template>
<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import fetch from "@system.fetch";

// 健壮的文件服务封装，用于所有文件操作
const fileService = {
    _promisify(fn, options) {
        return new Promise((resolve, reject) => {
            fn({ ...options, success: resolve, fail: (data, code) => reject({ data, code }) });
        });
    },
    async readJson(uri, defaultValue = null) {
        try {
            const data = await this._promisify(file.readText, { uri });
            return JSON.parse(data.text);
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] readJson 失败: ${uri}`, error);
            return defaultValue;
        }
    },
    async writeJson(uri, data) {
        try {
            await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) });
            return true;
        } catch (error) {
            console.error(`[FileService] writeJson 失败: ${uri}`, error);
            return false;
        }
    },
    async delete(uri) {
        try {
            await this._promisify(file.delete, { uri });
            return true;
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] delete 失败: ${uri}`, error);
            return false;
        }
    }
};


export default {
    protected: {
        listType: 'playlist', // 可由外部传入: 'playlist', 'downloadlist', 'songlist', 'favorites'
        songlistId: null,     // 为 'songlist' 类型传入的歌单ID
    },

    private: {
        songList: [],
        pageTitle: "播放列表",
        currentTime: "00:00",
        isLoading: false, // 防止重复加载
        // 文件路径常量
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
        favoritesFileUri: 'internal://files/favorites.json',
        musicDir: 'internal://files/music/',
        lyricDir: 'internal://files/lyrics/',
    },

    onInit() {
        this.updatePageTitle();
        this.loadData();
        this.updateTime();
        // 设置定时器每秒更新时间
        setInterval(() => {
            this.updateTime();
        }, 1000);
    },

    onShow() {
        // 每次页面显示时，如果不在加载中，则重新加载数据以同步状态
        if (!this.isLoading) {
            this.loadData();
        }
    },

    updateTime() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        this.currentTime = `${hours}:${minutes}`;
    },

    updatePageTitle() {
        const titles = {
            'downloadlist': "已下载",
            'songlist': "歌单详情",
            'favorites': "我的收藏",
            'playlist': "播放列表",
        };
        this.pageTitle = titles[this.listType] || "播放列表";
    },

    loadData() {
        switch (this.listType) {
            case 'downloadlist':
                this.loadDownloadedList();
                break;
            case 'favorites':
                this.loadFavoritesList();
                break;
            case 'songlist':
                this.loadSonglist();
                break;
            case 'playlist':
            default:
                this.loadPlayList();
                break;
        }
    },

    async loadPlayList() {
        this.songList = await fileService.readJson(this.listFileUri, []);
    },

    async loadDownloadedList() {
        const downloadedSongs = await fileService.readJson(this.downloadedFileUri, {});
        this.songList = Object.values(downloadedSongs);
    },

    async loadFavoritesList() {
        const favoriteSongs = await fileService.readJson(this.favoritesFileUri, {});
        this.songList = Object.values(favoriteSongs);
    },

    async loadSonglist() {
        if (!this.songlistId) {
            prompt.showToast({ message: '未提供歌单ID' });
            return;
        }
        if (this.isLoading) return;

        this.isLoading = true;
        this.songList = [];
        prompt.showToast({ message: '正在加载歌单...' });

        const BASE_URL = 'https://163api.qijieya.cn/playlist/track/all';
        const PAGE_LIMIT = 50;
        const TOTAL_LIMIT = 200;
        let offset = 0;
        let hasMore = true;

        try {
            while (hasMore && this.songList.length < TOTAL_LIMIT ) {
                const currentLimit = Math.min(PAGE_LIMIT, TOTAL_LIMIT - this.songList.length);
                if (currentLimit <= 0) break;

                const url = `${BASE_URL}?id=${this.songlistId}&limit=${currentLimit}&offset=${offset}`;
                
                const response = await new Promise((resolve, reject) => {
                    fetch.fetch({ url, success: resolve, fail: (data, code) => reject({ data, code }) });
                });

                const songs = response.data?.songs;

                if (songs && songs.length > 0) {
                    const formattedSongs = songs.map(song => ({
                        id: song.id,
                        name: song.name,
                        artists: song.ar.map(artist => artist.name).join(' / '),
                    }));
                    
                    this.songList = [...this.songList, ...formattedSongs];

                    if (songs.length < currentLimit) {
                        hasMore = false;
                    } else {
                        offset += songs.length;
                    }
                } else {
                    hasMore = false;
                }
            }

            if (this.songList.length > 0) {
                const message = this.songList.length >= TOTAL_LIMIT ? `已加载前${TOTAL_LIMIT}首` : `加载完成，共 ${this.songList.length} 首`;
                prompt.showToast({ message });
            } else {
                prompt.showToast({ message: '歌单为空或加载失败' });
            }

        } catch (error) {
            console.error('加载歌单失败:', error);
            prompt.showToast({ message: `加载失败: ${error.code || '网络错误'}` });
        } finally {
            this.isLoading = false;
        }
    },

    deleteSong(songToDelete) {
        switch (this.listType) {
            case 'downloadlist':
                this.deleteFromDownloaded(songToDelete);
                break;
            case 'favorites':
                this.deleteFromFavorites(songToDelete.id);
                break;
            case 'songlist':
                prompt.showToast({ message: '暂不支持从在线歌单中删除' });
                break;
            case 'playlist':
            default:
                this.deleteFromPlayList(songToDelete.id);
                break;
        }
    },

    async deleteFromPlayList(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            await this.savePlayList();
            prompt.showToast({ message: '已从播放列表移除' });
        }
    },

    async deleteFromDownloaded(songToDelete) {
        const songId = songToDelete.id;
        prompt.showToast({ message: `正在删除 ${songToDelete.name}...` });
        try {
            const index = this.songList.findIndex(item => item.id === songId);
            if (index > -1) this.songList.splice(index, 1);

            await fileService.delete(`${this.musicDir}${songId}.mp3`);
            await fileService.delete(`${this.lyricDir}${songId}.json`);

            const downloadedSongs = await fileService.readJson(this.downloadedFileUri, {});
            delete downloadedSongs[songId];
            await fileService.writeJson(this.downloadedFileUri, downloadedSongs);

            const playList = await fileService.readJson(this.listFileUri, []);
            const songInList = playList.find(s => s.id === songId);
            if (songInList) {
                songInList.downloadState = 'none';
                await fileService.writeJson(this.listFileUri, playList);
            }
            prompt.showToast({ message: '删除成功' });
        } catch (error) {
            prompt.showToast({ message: `删除失败: ${error.message || '未知错误'}` });
            this.loadData();
        }
    },

    async deleteFromFavorites(songId) {
        const index = this.songList.findIndex(item => item.id === songId);
        if (index > -1) {
            this.songList.splice(index, 1);
            const favorites = await fileService.readJson(this.favoritesFileUri, {});
            delete favorites[songId];
            await fileService.writeJson(this.favoritesFileUri, favorites);
            prompt.showToast({ message: '已从收藏列表移除' });
        }
    },

    async savePlayList() {
        await fileService.writeJson(this.listFileUri, this.songList);
    },

    async play(songId) {
        // 任何列表的播放都会覆盖当前的播放列表
        await this.savePlayList();
        
        router.replace({
            uri: "/pages/player",
            params: {
                songId: songId,
                playList: JSON.stringify(this.songList) 
            },
        });
    },

    goBack() {
        router.back();
    },
};
</script>

<style>
/* 样式部分无需修改，保持原样即可 */
.list-container {
	width: 100%;
	height: 100%;
	flex-direction: column;
	align-items: center;
	background-color: black;
}

.time-display {
  font-size: 28px;
  color: #ffffff;
  padding: 5px;
  text-align: center;
}

.title {
	font-size: 32px;
	padding: 5px;
	text-align: center;
  font-weight: bold;
	color: #fff;
}

.delete-btn {
	width: 64px;
	height: 64px;
}

.list {
	flex-direction: column;
	padding-bottom: 60px;
}

.song-item {
	padding: 25px;
	width: 360px;
	margin: 5px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	justify-content: space-between;
}

.item-index {
	text-align: center;
	color: rgba(255, 255, 255, 0.6);
}

.song-info {
    width: 200px;
	flex-direction: column;
}

.song-title {
	font-size: 26px;
	color: #fff;
}

.song-artist {
	font-size: 22px;
	color: #888;
}

.clear-btn {
    width: 200px;
    height: 60px;
    font-size: 26px;
    color: #fff;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 36px;
    text-align: center;
}
</style>
