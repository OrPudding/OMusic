<template>
    <div class="page-container">
        <!-- 1. 固定的顶部栏 -->
        <div class="header" onclick="goBack">
            <text class="time-display">{{currentTime}}</text>
            <text class="title">‹{{ pageTitle }}</text>
        </div>

        <!-- 2. 独立滚动的内容区 -->
        <scroll id="songListScroll" class="scroll-wrapper" scroll-y="true" bounces="true" onscrolltop="handleScrollTop">

            <!-- 按钮容器 -->
            <div class="button-container" if="{{ fullSongList.length > 0 }}">
                <!-- 歌单页 (songlist) -->
                <div if="{{ listType === 'songlist' }}" class="button-group">
                    <div class="group-button little-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                    <div class="group-button little-buttons" onclick="addAllToFavorites"><image class="button-icon" src="/common/icon/list-liked.png"></image><text class="button-text dark">添加收藏</text></div>
                    <div class="group-button little-buttons" onclick="toggleDownloadMode">
                        <image class="button-icon" src="{{ isDownloadMode ? '/common/icon/check.png' : '/common/icon/download_dark.png' }}"></image>
                        <text class="button-text dark">{{ isDownloadMode ? '完成' : '下载' }}</text>
                    </div>
                </div>
                <!-- 每日推荐/播放列表 (daily_recommend, playlist) -->
                <div if="{{ listType === 'daily_recommend' || listType === 'playlist' }}" class="button-group">
                    <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                    <div class="group-button normal-buttons" onclick="toggleDownloadMode">
                        <image class="button-icon" src="{{ isDownloadMode ? '/common/icon/check.png' : '/common/icon/download_dark.png' }}"></image>
                        <text class="button-text dark">{{ isDownloadMode ? '完成' : '下载' }}</text>
                    </div>
                </div>
                <!-- 私人FM (personal_fm) -->
                <div if="{{ listType === 'personal_fm' }}" class="button-group">
                     <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">开启FM</text></div>
                     <div class="group-button normal-buttons" onclick="refreshFm"><image class="button-icon" src="/common/icon/refresh.png"></image><text class="button-text dark">换一批</text></div>
                </div>
                <!-- 已下载 (downloadlist) -->
                <div if="{{ listType === 'downloadlist' }}" class="button-group">
                     <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                     <div class="group-button normal-buttons" onclick="goToStorage"><image class="button-icon" src="/common/icon/storage.png"></image><text class="button-text dark">存储空间</text></div>
                </div>
            </div>

            <div class="status-container">
                <!-- 1. 加载中状态：只在 isLoading 为 true 时显示 -->
                <div if="{{ isLoading }}" class="loading-wrapper">
                    <!-- a. 如果确定是从网络获取，则显示进度条 -->
                    <div if="{{ isFetchingFromNetwork }}" class="loading-progress-container">
                        <text class="loading-progress-text">{{ loadingText }} {{ networkSongsCount }} / {{ totalTrackCount }}</text>
                        <progress class="loading-progress-bar" type="horizontal" percent="{{ networkLoadProgress }}"></progress>
                    </div>
                    <!-- b. 否则 (缓存加载或本地列表加载)，只显示动态文本 -->
                    <text else class="loading-tip">{{ loadingText }}</text>
                </div>

                <!-- 2. 加载失败状态：只在加载结束且有错误时显示 -->
                <div if="{{ !isLoading && loadError }}" class="error-wrapper">
                    <text class="error-tip">加载失败: {{ loadError }}</text>
                    <text class="retry-button" onclick="retryLoad">点击重试</text>
                </div>

                <!-- 3. 列表为空状态：只在加载结束、无错误且列表为空时显示 -->
                <text if="{{ !isLoading && !loadError && fullSongList.length === 0 }}" class="loading-tip">列表为空</text>
            </div>

            <!-- 列表内容 -->
            <div class="list-content" if="{{ !isLoading && !loadError && fullSongList.length > 0 }}">
                <div for="{{(index, item) in displaySongList}}" class="song-item" onclick="handleItemClick(item)">
                    <div class="item-prefix">
                        <text class="item-index">{{ item.displayIndex }}</text>
                    </div>
                    <div class="song-info">
                        <text class="song-title">{{ item.name }}</text>
                        <text class="song-artist">{{ item.artists }}</text>
                        <div class="song-meta" if="{{item.isDownloaded && !isDownloadMode}}">
                            <text class="download-tag">已下载</text>
                        </div>
                    </div>
                    <div class="action-btn-wrapper">
                        <div if="{{ isDownloadMode && (listType === 'songlist' || listType === 'daily_recommend' || listType === 'playlist') }}" class="download-status-wrapper">
                            <image if="{{ item.isDownloaded }}" class="action-btn" src="/common/icon/check_light.png"></image>
                            <image elif="{{ downloadingIds.includes(item.id) }}" class="action-btn" src="/common/icon/more_light.png"></image>
                            <image else class="action-btn" src="/common/icon/downloaded.png"></image>
                        </div>
                        <div else>
                            <div if="{{ listType === 'playlist' || listType === 'favorites' || listType === 'downloadlist' }}" onclick="deleteSong(item)">
                                <image class="action-btn" src="/common/icon/cancel.png"></image>
                            </div>
                            <div if="{{ listType === 'songlist' }}" onclick="addSongToNext(item)">
                                <image class="action-btn" src="/common/icon/plus.png"></image>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </scroll>

        <!-- 翻页栏 -->
        <div class="pagination-footer" if="{{ !isLoading && !loadError && fullSongList.length > PAGE_SIZE }}">
            <text class="item-value-btn {{ currentPage === 1 ? 'item-value-btn-disabled' : '' }}" onclick="loadPrevPage">上一页</text>
            <text class="pagination-text">{{ currentPage }} / {{ totalPages }}</text>
            <text class="item-value-btn {{ currentPage >= totalPages ? 'item-value-btn-disabled' : '' }}" onclick="loadNextPage">下一页</text>
        </div>
    </div>
</template>

<style>
    .page-container { width: 100%; height: 100%; background-color: black; position: relative; }
    .header { width: 100%; height: 90px; flex-direction: column; justify-content: center; align-items: center; background-color: black; }
    .time-display { font-size: 28px; font-weight: bold; color: #ffffff; padding-top: 5px; text-align: center; }
    .title { font-size: 32px; padding: 5px; text-align: center; font-weight: bold; color: #fff; }
    .scroll-wrapper { position: absolute; top: 90px; bottom: 0; left: 0; right: 0; width: 100%; flex-direction: column; align-items: center; }
    .button-container { width: 392px; margin: 10px 0; }
    .button-group { width: 100%; flex-direction: row; justify-content: space-around; }
    .group-button { height: 100px; border-radius: 24px; justify-content: center; align-items: center; flex-direction: column; background-color: #BAC3FF; }
    .normal-buttons { width: 160px; }
    .little-buttons { width: 124px; }
    .button-icon { width: 36px; height: 36px; }
    .button-text { font-size: 26px; font-weight: bold; margin-top: 4px; }
    .button-text.dark { color: #000000; }
    .list-content { flex-direction: column; padding-bottom: 90px; width: 100%; align-items: center; }
.song-item { padding: 0 10px 0 0; width: 400px; height: 120px; margin: 5px; background-color: #191821; border-radius: 60px; justify-content: flex-start; align-items: center; }
    .item-prefix { width: 80px; height: 100%; justify-content: center; align-items: center; flex-shrink: 0; }
    .item-index { text-align: center; font-size: 28px; font-weight: bold; color: rgba(255, 255, 255, 0.6); }
    .song-info { flex-grow: 1; width: 0; flex-direction: column; justify-content: center; }
    .song-title { font-size: 26px; font-weight: bold; color: #fff; lines: 1; text-overflow: ellipsis; }
    .song-artist { font-size: 22px; font-weight: bold; color: #888; lines: 1; text-overflow: ellipsis; }
    .song-meta { flex-direction: row; align-items: center; margin-top: 4px; }
    .download-tag { background-color: #2E323C; color: #BAC3FF; font-size: 18px; font-weight: bold; padding: 2px 8px; border-radius: 6px; }
    .action-btn-wrapper { width: 80px; height: 120px; justify-content: center; align-items: center; flex-shrink: 0; }
    .download-status-wrapper { width: 80px; height: 120px; justify-content: center; align-items: center; }
    .action-btn { width: 64px; height: 64px; }
    .pagination-footer { position: absolute; bottom: 0; left: 0; right: 0; width: 100%; height: 100px; flex-direction: row; padding: 0 20px; justify-content: space-around; align-items: center; }
    .pagination-text { font-size: 28px; font-weight: bold; color: #ffffff; }
    .item-value-btn { height: 50px; padding: 0 20px; background-color: #2E323C; border-radius: 25px; color: #BAC3FF; font-size: 26px; font-weight: bold; text-align: center; line-height: 50px; }
    .item-value-btn-disabled { background-color: #2E323C; color: #888; }
    .status-container { width: 100%; flex-direction: column; align-items: center; justify-content: center; }
    .loading-wrapper, .error-wrapper { flex-direction: column; align-items: center; }
    .loading-progress-container { width: 360px; flex-direction: column; }
    .loading-progress-text { font-size: 26px; font-weight: bold;text-align: center; color: #888; margin-bottom: 8px; }
    .loading-progress-bar { width: 100%; color: #BAC3FF; stroke-width: 16px; }
    .loading-tip { width: 100%; padding:50px 0;text-align: center; color: #888; font-weight: bold; font-size: 26px; }
    .error-tip { color: #FF453A; font-size: 24px; margin-bottom: 20px; text-align: center; }
    .retry-button { padding: 10px 30px; font-size: 26px; color: #BAC3FF; border: 1px solid #BAC3FF; border-radius: 30px; }
    @media (shape: rect) { .header { height: 65px; flex-direction: row-reverse; padding-top: 10px; justify-content: space-around; } .scroll-wrapper { top: 65px; } .time-display { font-size: 32px; padding-top: 0px; } }
    @media (shape: circle) { .list-content { padding-bottom: 114px; } .pagination-footer { width: 100%; justify-content: center; } .item-value-btn { margin: 0 22px 50px 22px; } .pagination-text { position: absolute; bottom: 10px; } .loading-tip { padding-bottom: 120px; } }
</style>
<script>
// 【最终净化版，请用此版本完整替换 list.ux 的 <script> 部分】

import router from "@system.router";
import prompt from "@system.prompt";

// 【核心修正】不再需要导入 file, brightness, 也不需要 screenKeep
// import file from "@system.file";
// import brightness from "@system.brightness";
// import screenKeep from '../../utils/screenKeep.js';

const SETTINGS_FILE_URI = 'internal://files/settings.json';
const DIR_MUSIC = 'internal://files/music/';
const DIR_LYRICS = 'internal://files/lyrics/';

export default {
    protected: {
        listType: 'playlist',
        songlistId: null,
        targetSongId: null,
        trackCount: 0,
    },
    private: {
        fullSongList: [],
        displaySongList: [],
        PAGE_SIZE: 10,
        currentPage: 1,
        totalPages: 1,
        TOTAL_LIMIT: 200,
        API_PAGE_SIZE: 20,
        ITEM_HEIGHT: 130,
        isLoading: false,
        isRefreshing: false,
        justReachedTop: false,
        isDownloadMode: false,
        downloadingIds: [], // 保留，用于UI展示“下载中”的状态
        pageTitle: "播放列表",
        currentTime: "00:00",
        updateTimeInterval: null,
        justReachedTopTimeoutId: null,
        songlistsDir: 'internal://files/songlists/',
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
        favoritesFileUri: 'internal://files/favorites.json',
        isFetchingFromNetwork: false,
        networkSongsCount: 0,
        totalTrackCount: ' ',
        networkLoadProgress: 0,
        loadError: null,
        loadingText: '正在加载...',
        didLoadFromCache: false,
    },

    onInit: function() {
        console.log(`list页面初始化: listType=${this.listType}, songlistId=${this.songlistId}`);
        if (this.targetSongId) {
            console.log(`接收到定位请求，目标歌曲ID: ${this.targetSongId}`);
        }
        this.updateTime();
        this.updateTimeInterval = setInterval(() => this.updateTime(), 60000);
        this.updatePageTitle();

        (async () => {
            const { file } = this.getServices();
            await this.applySettings();
            await file.ensureDirExists(this.songlistsDir);
            this.loadData(!!this.targetSongId);
        })();
    },

    onDestroy: function() {
        if (this.updateTimeInterval) clearInterval(this.updateTimeInterval);
        if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
    },

    getServices() {
        return {
            player: this.$app.$def.player,
            download: this.$app.$def.download,
            file: this.$app.$def.file,
            api: this.$app.$def.api,
            settings: this.$app.$def.settings,
        };
    },

    async applySettings() {
        const { file } = this.getServices();
        const data = await file.readJson(SETTINGS_FILE_URI, {});
        if (data.performance) this.PAGE_SIZE = data.performance.windowSize || this.PAGE_SIZE;
        if (data.network) {
            this.TOTAL_LIMIT = data.network.totalLimit || this.TOTAL_LIMIT;
            this.API_PAGE_SIZE = data.network.apiPageSize || this.API_PAGE_SIZE;
        }
    },

    updatePageTitle: function() {
        const titles = {
            'downloadlist': "已下载", 'songlist': "歌单详情", 'favorites': "我的收藏",
            'playlist': "播放列表", 'daily_recommend': "每日推荐", 'personal_fm': "私人FM",
        };
        this.pageTitle = titles[this.listType] || "播放列表";
    },

    updateTime: function() {
        const now = new Date();
        this.currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    },

    async loadData(shouldLocate = false, force = false) {
        if (this.isLoading) return;
        this.isLoading = true;
        this.loadError = null;
        this.isFetchingFromNetwork = false;
        this.didLoadFromCache = false;
        
        const loadingTexts = {
            'songlist': '正在加载歌单...', 'daily_recommend': '正在获取今日推荐...',
            'personal_fm': '正在开启私人FM...',
        };
        this.loadingText = loadingTexts[this.listType] || '正在读取列表...';

        if (force) {
            this.fullSongList = [];
            this.displaySongList = [];
        }
        this.currentPage = 1;

        try {
            const { file } = this.getServices();
            let sourceData;
            switch (this.listType) {
                case 'songlist':
                    sourceData = await this._getSourceData_songlist(force);
                    break;
                case 'daily_recommend':
                    sourceData = await this._getSourceData_dailyRecommend();
                    break;
                case 'personal_fm':
                    sourceData = await this._getSourceData_personalFm();
                    break;
                case 'downloadlist':
                    sourceData = Object.values(await file.readJson(this.downloadedFileUri, {}));
                    break;
                case 'favorites':
                    sourceData = Object.values(await file.readJson(this.favoritesFileUri, {}));
                    break;
                default: // 'playlist'
                    sourceData = await file.readJson(this.listFileUri, []);
                    break;
            }

            if (sourceData?.length > 0) {
                const downloadedData = await file.readJson(this.downloadedFileUri, {});
                const downloadedIds = new Set(Object.keys(downloadedData));
                this.fullSongList = sourceData.map(song => ({
                    ...song,
                    isDownloaded: downloadedIds.has(String(song.id))
                }));
                this.totalPages = Math.ceil(this.fullSongList.length / this.PAGE_SIZE) || 1;
                if (shouldLocate) this.locateSongAndLoadPage();
                else this.loadPage(1);
            } else {
                this.fullSongList = [];
                this.displaySongList = [];
                this.totalPages = 1;
            }
        } catch (error) {
            console.error("loadData失败:", error);
            this.loadError = error.message || '未知错误';
            this.fullSongList = [];
            this.displaySongList = [];
        } finally {
            this.isLoading = false;
            this.isFetchingFromNetwork = false;
            if (this.didLoadFromCache) {
                setTimeout(() => { this.didLoadFromCache = false; }, 500);
            }
        }
    },

    retryLoad: function() {
        this.loadData();
    },

    async _getSourceData_songlist(force = false) {
        const { api, file } = this.getServices();
        if (!this.songlistId) throw new Error("未提供歌单ID");

        const cacheFileUri = `${this.songlistsDir}${this.songlistId}.json`;

        if (!force) {
            const cachedList = await file.readJson(cacheFileUri, null);
            if (cachedList?.length > 0) {
                this.didLoadFromCache = true;
                return cachedList;
            }
        }

        this.isFetchingFromNetwork = true;
        // 【移除】screenKeep.enable();

        try {
            const detail = await api.getPlaylistDetail(this.songlistId);
            const playlist = detail?.playlist;
            if (!playlist) throw new Error("获取歌单详情失败");

            let totalSongs = Math.min(playlist.trackCount || 0, this.TOTAL_LIMIT);
            this.totalTrackCount = totalSongs.toString();
            
            let allSongs = playlist.tracks.map(s => ({
                id: s.id, name: s.name, artists: s.ar?.map(a => a.name).join(' / ')
            }));
            this.networkSongsCount = allSongs.length;

            let offset = allSongs.length;
            while (allSongs.length < totalSongs) {
                const remaining = totalSongs - allSongs.length;
                const limit = Math.min(this.API_PAGE_SIZE, remaining);
                
                const nextPage = await api.getPlaylistAllTracks(this.songlistId, limit, offset);
                const newSongs = nextPage?.songs;

                if (!newSongs || newSongs.length === 0) break;

                allSongs.push(...newSongs.map(s => ({
                    id: s.id, name: s.name, artists: s.ar?.map(a => a.name).join(' / ')
                })));
                
                offset += newSongs.length;
                this.networkSongsCount = allSongs.length;
                this.networkLoadProgress = Math.floor((allSongs.length / totalSongs) * 100);
                await new Promise(resolve => setTimeout(resolve, 200));
            }

            if (allSongs.length > 0) {
                await file.writeJson(cacheFileUri, allSongs);
            }
            return allSongs;

        } catch (error) {
            console.error("获取歌单数据失败:", error);
            const cachedList = await file.readJson(cacheFileUri, null);
            if (cachedList?.length > 0) return cachedList;
            throw error;
        } finally {
            this.isFetchingFromNetwork = false;
            // 【移除】screenKeep.disable();
        }
    },

    async _getSourceData_dailyRecommend() {
        const { api, file } = this.getServices();
        const today = new Date();
        const dateKey = `${today.getFullYear()}-${(today.getMonth() + 1).toString().padStart(2, '0')}-${today.getDate().toString().padStart(2, '0')}`;
        const cacheFileUri = `internal://files/daily_recommend_${dateKey}.json`;

        const cachedData = await file.readJson(cacheFileUri);
        if (cachedData?.length > 0) {
            this.didLoadFromCache = true;
            return cachedData;
        }

        const songs = await api.getDailyRecommendSongs();
        const formattedSongs = songs.map(s => ({ id: s.id, name: s.name, artists: s.ar.map(a => a.name).join(' / ') }));
        await file.writeJson(cacheFileUri, formattedSongs);
        return formattedSongs;
    },

    async _getSourceData_personalFm() {
        const { api } = this.getServices();
        return await api.getPersonalFmSongs();
    },

    locateSongAndLoadPage: function() {
        const targetId = this.targetSongId;
        if (!targetId || !this.fullSongList || this.fullSongList.length === 0) {
            this.loadPage(1);
            return;
        }
        const songIndex = this.fullSongList.findIndex(song => String(song.id) === String(targetId));
        if (songIndex !== -1) {
            const targetPage = Math.floor(songIndex / this.PAGE_SIZE) + 1;
            this.loadPage(targetPage);
            this.$nextTick(() => {
                const indexInPage = songIndex % this.PAGE_SIZE;
                const scrollOffset = indexInPage * this.ITEM_HEIGHT;
                this.$element('songListScroll').scrollTo({ top: scrollOffset, behavior: 'smooth' });
            });
        } else {
            prompt.showToast({ message: '未在列表中找到指定歌曲' });
            this.loadPage(1);
        }
        this.targetSongId = null;
    },

    loadPage: function(pageNumber) {
        if (pageNumber < 1 || (pageNumber > this.totalPages && this.totalPages > 0)) return;
        const startIndex = (pageNumber - 1) * this.PAGE_SIZE;
        const endIndex = startIndex + this.PAGE_SIZE;
        this.displaySongList = this.fullSongList.slice(startIndex, endIndex).map((song, index) => ({ ...song, displayIndex: startIndex + index + 1 }));
        this.currentPage = pageNumber;
        this.$nextTick(() => { this.$element('songListScroll').scrollTo({ top: 1 }); });
    },

    loadPrevPage: function() {
        if (this.currentPage > 1) this.loadPage(this.currentPage - 1);
    },

    loadNextPage: function() {
        if (this.currentPage < this.totalPages) this.loadPage(this.currentPage + 1);
    },

    async handleScrollTop() {
        if (this.isLoading || this.isRefreshing) return;
        const isRefreshable = ['songlist', 'personal_fm', 'daily_recommend'].includes(this.listType);
        if (!isRefreshable) return;

        if (this.justReachedTop) {
            this.isRefreshing = true;
            prompt.showToast({ message: '正在刷新...' });
            if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
            this.justReachedTopTimeoutId = null;
            this.justReachedTop = false;

            try {
                await this.loadData(false, true);
            } finally {
                this.isRefreshing = false;
            }
        } else {
            prompt.showToast({ message: '再次下拉刷新' });
            this.justReachedTop = true;
            if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
            this.justReachedTopTimeoutId = setTimeout(() => { this.justReachedTop = false; }, 3000);
        }
    },

    async deleteSong(songToDelete) {
        const fullIndex = this.fullSongList.findIndex(item => item.id === songToDelete.id);
        if (fullIndex > -1) {
            this.fullSongList.splice(fullIndex, 1);
            this.totalPages = Math.ceil(this.fullSongList.length / this.PAGE_SIZE) || 1;
            const targetPage = this.currentPage > this.totalPages ? Math.max(1, this.totalPages) : this.currentPage;
            this.loadPage(targetPage);
            prompt.showToast({ message: '已移除' });
            await this.persistDeletion(songToDelete);
        }
    },

    async persistDeletion(songToDelete) {
        const { file } = this.getServices();
        const songId = songToDelete.id;
        if (this.listType === 'playlist') {
            await file.writeJson(this.listFileUri, this.fullSongList);
        } else if (this.listType === 'favorites') {
            await file.deleteFromJson(this.favoritesFileUri, songId);
        } else if (this.listType === 'downloadlist') {
            await file.delete(`${DIR_MUSIC}${songId}.mp3`);
            await file.delete(`${DIR_LYRICS}${songId}.json`);
            await file.deleteFromJson(this.downloadedFileUri, songId);
        }
    },

    async playAll() {
        if (!this.fullSongList || this.fullSongList.length === 0) {
            prompt.showToast({ message: '列表为空' });
            return;
        }
        if (this.listType === 'personal_fm') {
            this.play(this.fullSongList[0].id);
            return;
        }
        const { file } = this.getServices();
        await file.writeJson(this.listFileUri, this.fullSongList);
        this.play(this.fullSongList[0].id);
    },

    play: function(songId) {
        const songToPlay = this.fullSongList.find(song => song.id === songId);
        if (!songToPlay) {
            prompt.showToast({ message: '找不到歌曲信息' });
            return;
        }
        const params = { songId: songId, songInfo: JSON.stringify({ id: songToPlay.id, name: songToPlay.name, artists: songToPlay.artists }) };
        if (this.listType === 'personal_fm') params.startFmMode = true;
        router.push({ uri: "/pages/player", params });
    },

    clearPlaylist: function() {
        prompt.showDialog({
            title: '清空播放列表',
            message: '您确定要清空当前播放列表中的所有歌曲吗？',
            buttons: [{ text: '取消' }, { text: '确定清空', color: '#FF453A' }],
            success: async () => {
                const { file } = this.getServices();
                this.fullSongList = [];
                this.displaySongList = [];
                this.totalPages = 1;
                await file.writeJson(this.listFileUri, []);
                prompt.showToast({ message: '播放列表已清空' });
            }
        });
    },

    goBack: function() {
        router.back();
    },

    goToStorage: function() {
        router.push({ uri: '/pages/storage' });
    },

    refreshFm: function() {
        this.loadData(false, true);
    },

    async addAllToFavorites() {
        if (!this.fullSongList || this.fullSongList.length === 0) {
            prompt.showToast({ message: '列表为空，无法添加' });
            return;
        }
        prompt.showToast({ message: '正在添加到收藏...' });
        const { file } = this.getServices();
        const favorites = await file.readJson(this.favoritesFileUri, {});
        let addedCount = 0;
        this.fullSongList.forEach(song => {
            if (!favorites[String(song.id)]) {
                favorites[String(song.id)] = { id: song.id, name: song.name, artists: song.artists, duration: song.duration || 0 };
                addedCount++;
            }
        });
        if (addedCount > 0) {
            const success = await file.writeJson(this.favoritesFileUri, favorites);
            prompt.showToast({ message: success ? `成功添加 ${addedCount} 首歌曲到收藏` : '保存收藏失败' });
        } else {
            prompt.showToast({ message: '所有歌曲均已在收藏中' });
        }
    },

    addSongToNext: function() {
        prompt.showToast({ message: '此功能正在开发中' });
    },

    handleItemClick: function(item) {
        if (this.isDownloadMode) {
            if (item.isDownloaded || this.downloadingIds.includes(item.id)) {
                prompt.showToast({ message: item.isDownloaded ? '已下载' : '正在下载中' });
                return;
            }
            
            const { download } = this.getServices();
            const settings = this.$app.$def.settings || { audioQuality: { download: 128 } };

            download.addTask(
                item,
                { downloadBitrate: settings.audioQuality.download },
                {
                    onStart: (song) => {
                        this.downloadingIds.push(song.id);
                    },
                    onSuccess: (downloadedInfo) => {
                        const songInList = this.fullSongList.find(s => s.id === downloadedInfo.id);
                        if (songInList) songInList.isDownloaded = true;
                    },
                    onFinish: () => {
                        const index = this.downloadingIds.indexOf(item.id);
                        if (index > -1) this.downloadingIds.splice(index, 1);
                    }
                }
            );
        } else {
            this.play(item.id);
        }
    },

    toggleDownloadMode: function() {
        this.isDownloadMode = !this.isDownloadMode;
    }
};
</script>
