<template>
    <div class="page-container">
        <!-- 1. 固定的顶部栏 -->
        <div class="header" onclick="goBack">
            <text class="time-display">{{currentTime}}</text>
            <text class="title">‹{{ pageTitle }}</text>
        </div>

        <!-- 2. 独立滚动的内容区 -->
        <scroll id="songListScroll" class="scroll-wrapper" scroll-y="true" bounces="true" onscrolltop="handleScrollTop">

            <!-- 按钮容器 -->
            <div class="button-container" if="{{ fullSongList.length > 0 }}">
                <!-- 歌单页 (songlist) -->
                <div if="{{ listType === 'songlist' }}" class="button-group">
                    <div class="group-button little-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                    <div class="group-button little-buttons" onclick="addAllToFavorites"><image class="button-icon" src="/common/icon/list-liked.png"></image><text class="button-text dark">添加收藏</text></div>
                    <div class="group-button little-buttons" onclick="toggleDownloadMode">
                        <image class="button-icon" src="{{ isDownloadMode ? '/common/icon/check.png' : '/common/icon/download_dark.png' }}"></image>
                        <text class="button-text dark">{{ isDownloadMode ? '完成' : '下载' }}</text>
                    </div>
                </div>
                <!-- 每日推荐/播放列表 (daily_recommend, playlist) -->
                <div if="{{ listType === 'daily_recommend' || listType === 'playlist' }}" class="button-group">
                    <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                    <div class="group-button normal-buttons" onclick="toggleDownloadMode">
                        <image class="button-icon" src="{{ isDownloadMode ? '/common/icon/check.png' : '/common/icon/download_dark.png' }}"></image>
                        <text class="button-text dark">{{ isDownloadMode ? '完成' : '下载' }}</text>
                    </div>
                </div>
                <!-- 私人FM (personal_fm) -->
                <div if="{{ listType === 'personal_fm' }}" class="button-group">
                     <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">开启FM</text></div>
                     <div class="group-button normal-buttons" onclick="refreshFm"><image class="button-icon" src="/common/icon/refresh.png"></image><text class="button-text dark">换一批</text></div>
                </div>
                <!-- 已下载 (downloadlist) -->
                <div if="{{ listType === 'downloadlist' }}" class="button-group">
                     <div class="group-button normal-buttons" onclick="playAll"><image class="button-icon" src="/common/icon/play-arrow.png"></image><text class="button-text dark">播放全部</text></div>
                     <div class="group-button normal-buttons" onclick="goToStorage"><image class="button-icon" src="/common/icon/storage.png"></image><text class="button-text dark">存储空间</text></div>
                </div>
            </div>

            <div class="status-container">
                <!-- 1. 加载中状态：只在 isLoading 为 true 时显示 -->
                <div if="{{ isLoading }}" class="loading-wrapper">
                    <!-- a. 如果确定是从网络获取，则显示进度条 -->
                    <div if="{{ isFetchingFromNetwork }}" class="loading-progress-container">
                        <text class="loading-progress-text">{{ loadingText }} {{ networkSongsCount }} / {{ totalTrackCount }}</text>
                        <progress class="loading-progress-bar" type="horizontal" percent="{{ networkLoadProgress }}"></progress>
                    </div>
                    <!-- b. 否则 (缓存加载或本地列表加载)，只显示动态文本 -->
                    <text else class="loading-tip">{{ loadingText }}</text>
                </div>

                <!-- 2. 加载失败状态：只在加载结束且有错误时显示 -->
                <div if="{{ !isLoading && loadError }}" class="error-wrapper">
                    <text class="error-tip">加载失败: {{ loadError }}</text>
                    <text class="retry-button" onclick="retryLoad">点击重试</text>
                </div>

                <!-- 3. 列表为空状态：只在加载结束、无错误且列表为空时显示 -->
                <text if="{{ !isLoading && !loadError && fullSongList.length === 0 }}" class="loading-tip">列表为空</text>
            </div>

            <!-- 列表内容 -->
            <div class="list-content" if="{{ !isLoading && !loadError && fullSongList.length > 0 }}">
                <div for="{{(index, item) in displaySongList}}" class="song-item" onclick="handleItemClick(item)">
                    <div class="item-prefix">
                        <text class="item-index">{{ item.displayIndex }}</text>
                    </div>
                    <div class="song-info">
                        <text class="song-title">{{ item.name }}</text>
                        <text class="song-artist">{{ item.artists }}</text>
                        <div class="song-meta" if="{{item.isDownloaded && !isDownloadMode}}">
                            <text class="download-tag">已下载</text>
                        </div>
                    </div>
                    <div class="action-btn-wrapper">
                        <div if="{{ isDownloadMode && (listType === 'songlist' || listType === 'daily_recommend' || listType === 'playlist') }}" class="download-status-wrapper">
                            <image if="{{ item.isDownloaded }}" class="action-btn" src="/common/icon/check_light.png"></image>
                            <image elif="{{ downloadingIds.includes(item.id) }}" class="action-btn" src="/common/icon/more_light.png"></image>
                            <image else class="action-btn" src="/common/icon/downloaded.png"></image>
                        </div>
                        <div else>
                            <div if="{{ listType === 'playlist' || listType === 'favorites' || listType === 'downloadlist' }}" onclick="deleteSong(item)">
                                <image class="action-btn" src="/common/icon/cancel.png"></image>
                            </div>
                            <div if="{{ listType === 'songlist' }}" onclick="addSongToNext(item)">
                                <image class="action-btn" src="/common/icon/plus.png"></image>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </scroll>

        <!-- 翻页栏 -->
        <div class="pagination-footer" if="{{ !isLoading && !loadError && fullSongList.length > PAGE_SIZE }}">
            <text class="item-value-btn {{ currentPage === 1 ? 'item-value-btn-disabled' : '' }}" onclick="loadPrevPage">上一页</text>
            <text class="pagination-text">{{ currentPage }} / {{ totalPages }}</text>
            <text class="item-value-btn {{ currentPage >= totalPages ? 'item-value-btn-disabled' : '' }}" onclick="loadNextPage">下一页</text>
        </div>
    </div>
</template>

<style>
    .page-container { width: 100%; height: 100%; background-color: black; position: relative; }
    .header { width: 100%; height: 90px; flex-direction: column; justify-content: center; align-items: center; background-color: black; }
    .time-display { font-size: 28px; font-weight: bold; color: #ffffff; padding-top: 5px; text-align: center; }
    .title { font-size: 32px; padding: 5px; text-align: center; font-weight: bold; color: #fff; }
    .scroll-wrapper { position: absolute; top: 90px; bottom: 0; left: 0; right: 0; width: 100%; flex-direction: column; align-items: center; }
    .button-container { width: 392px; margin: 10px 0; }
    .button-group { width: 100%; flex-direction: row; justify-content: space-around; }
    .group-button { height: 100px; border-radius: 24px; justify-content: center; align-items: center; flex-direction: column; background-color: #BAC3FF; }
    .normal-buttons { width: 160px; }
    .little-buttons { width: 124px; }
    .button-icon { width: 36px; height: 36px; }
    .button-text { font-size: 26px; font-weight: bold; margin-top: 4px; }
    .button-text.dark { color: #000000; }
    .list-content { flex-direction: column; padding-bottom: 90px; width: 100%; align-items: center; }
    .song-item { padding: 0 10px 0 0; width: 400px; height: 120px; margin: 5px; background-color: #191821; border-radius: 60px; justify-content: flex-start; align-items: center; }
    .item-prefix { width: 80px; height: 100%; justify-content: center; align-items: center; flex-shrink: 0; }
    .item-index { text-align: center; font-size: 28px; font-weight: bold; color: rgba(255, 255, 255, 0.6); }
    .song-info { flex-grow: 1; width: 0; flex-direction: column; justify-content: center; }
    .song-title { font-size: 26px; font-weight: bold; color: #fff; lines: 1; text-overflow: ellipsis; }
    .song-artist { font-size: 22px; font-weight: bold; color: #888; lines: 1; text-overflow: ellipsis; }
    .song-meta { flex-direction: row; align-items: center; margin-top: 4px; }
    .download-tag { background-color: #2E323C; color: #BAC3FF; font-size: 18px; font-weight: bold; padding: 2px 8px; border-radius: 6px; }
    .action-btn-wrapper { width: 80px; height: 120px; justify-content: center; align-items: center; flex-shrink: 0; }
    .download-status-wrapper { width: 80px; height: 120px; justify-content: center; align-items: center; }
    .action-btn { width: 64px; height: 64px; }
    .pagination-footer { position: absolute; bottom: 0; left: 0; right: 0; width: 100%; height: 100px; flex-direction: row; padding: 0 20px; justify-content: space-around; align-items: center; }
    .pagination-text { font-size: 28px; font-weight: bold; color: #ffffff; }
    .item-value-btn { height: 50px; padding: 0 20px; background-color: #2E323C; border-radius: 25px; color: #BAC3FF; font-size: 26px; font-weight: bold; text-align: center; line-height: 50px; }
    .item-value-btn-disabled { background-color: #2E323C; color: #888; }
    .status-container { width: 100%; flex-direction: column; align-items: center; justify-content: center; }
    .loading-wrapper, .error-wrapper { flex-direction: column; align-items: center; }
    .loading-progress-container { width: 360px; flex-direction: column; }
    .loading-progress-text { font-size: 26px; font-weight: bold;text-align: center; color: #888; margin-bottom: 8px; }
    .loading-progress-bar { width: 100%; color: #BAC3FF; stroke-width: 16px; }
    .loading-tip { width: 100%; padding:50px 0;text-align: center; color: #888; font-weight: bold; font-size: 26px; }
    .error-tip { color: #FF453A; font-size: 24px; margin-bottom: 20px; text-align: center; }
    .retry-button { padding: 10px 30px; font-size: 26px; color: #BAC3FF; border: 1px solid #BAC3FF; border-radius: 30px; }
    @media (shape: rect) { .header { height: 65px; flex-direction: row-reverse; padding-top: 10px; justify-content: space-around; } .scroll-wrapper { top: 65px; } .time-display { font-size: 32px; padding-top: 0px; } }
    @media (shape: circle) { .list-content { padding-bottom: 114px; } .pagination-footer { width: 100%; justify-content: center; } .item-value-btn { margin: 0 22px 50px 22px; } .pagination-text { position: absolute; bottom: 10px; } .loading-tip { padding-bottom: 120px; } }
</style>
<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import brightness from "@system.brightness";

const fileService = {
    _promisify(fn, options) {
    return new Promise((resolve, reject) => {
        fn({
            ...options,
            success: resolve,
            fail: (data, code) => {
                const err = new Error(`Error code ${code}: ${data}`);
                err.code = code;
                reject(err);
            }
        });
    });
},

    async readJson(uri, defaultValue = null) {
        try {
            const data = await this._promisify(file.readText, { uri });
            return JSON.parse(data.text || '{}');
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] readJson 失败: ${uri}`, error);
            return defaultValue;
        }
    },
    async writeJson(uri, data) {
        try {
            await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) });
            return true;
        } catch (error) {
            console.error(`[FileService] writeJson 失败: ${uri}`, error);
            return false;
        }
    },
    async delete(uri) {
        try {
            await this._promisify(file.delete, { uri });
            return true;
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] delete 失败: ${uri}`, error);
            return false;
        }
    },
    async ensureDirExists(uri) {
        try {
            await this._promisify(file.mkdir, { uri });
        } catch (error) { /* 忽略目录已存在的错误 */ }
    }
};

const SETTINGS_FILE_URI = 'internal://files/settings.json';
const DIR_MUSIC = 'internal://files/music/';
const DIR_LYRICS = 'internal://files/lyrics/';

export default {
    protected: {
        listType: 'playlist',
        songlistId: null,
        targetSongId: null, 
    },
    private: {
        fullSongList: [],
        displaySongList: [],
        PAGE_SIZE: 10,
        currentPage: 1,
        totalPages: 1,
        TOTAL_LIMIT: 200,
        API_PAGE_SIZE: 20,
        ITEM_HEIGHT: 130, 
        isLoading: false,
        isRefreshing: false,
        justReachedTop: false,
        isDownloadMode: false,
        isDownloadingLocked: false,
        downloadingIds: [],
        downloadQueue: [],
        pageTitle: "播放列表",
        currentTime: "00:00",
        updateTimeInterval: null,
        justReachedTopTimeoutId: null,
        songlistsDir: 'internal://files/songlists/',
        listFileUri: 'internal://files/play_list.json',
        downloadedFileUri: 'internal://files/downloaded_songs.json',
        favoritesFileUri: 'internal://files/favorites.json',
        isFetchingFromNetwork: false,
        networkSongsCount: 0,
        totalTrackCount: ' ',
        networkLoadProgress: 0,
        loadError: null,
        loadingText: '正在加载...',
        didLoadFromCache: false,
    },

    onInit: function() {
        var that = this;
        if (that.targetSongId) {
            console.log(`接收到定位请求，目标歌曲ID: ${that.targetSongId}`);
        }
        that.updateTime();
        that.updateTimeInterval = setInterval(function() { that.updateTime(); }, 1000 * 60);
        that.updatePageTitle();

        (async () => {
            await that.applySettings();
            await fileService.ensureDirExists(that.songlistsDir);
            that.loadData(!!that.targetSongId);
        })();
    },

    onDestroy: function() {
        if (this.updateTimeInterval) clearInterval(this.updateTimeInterval);
        if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
    },

    async applySettings() {
        const data = await fileService.readJson(SETTINGS_FILE_URI, {});
        if (data) {
            if (data.performance) this.PAGE_SIZE = data.performance.windowSize || this.PAGE_SIZE;
            if (data.network) {
                this.TOTAL_LIMIT = data.network.totalLimit || this.TOTAL_LIMIT;
                this.API_PAGE_SIZE = data.network.apiPageSize || this.API_PAGE_SIZE;
            }
        }
    },

    updatePageTitle: function() {
        const titles = {
            'downloadlist': "已下载", 'songlist': "歌单详情", 'favorites': "我的收藏",
            'playlist': "播放列表", 'daily_recommend': "每日推荐", 'personal_fm': "私人FM",
        };
        this.pageTitle = titles[this.listType] || "播放列表";
    },

    updateTime: function() {
        const now = new Date();
        this.currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    },

    async loadData(shouldLocate = false, force = false) {
        if (this.isLoading) return;

        this.isLoading = true;
        this.loadError = null;
        this.isFetchingFromNetwork = false;
        this.didLoadFromCache = false;
        
        switch (this.listType) {
            case 'songlist': this.loadingText = '正在加载歌单...'; break;
            case 'daily_recommend': this.loadingText = '正在获取今日推荐...'; break;
            case 'personal_fm': this.loadingText = '正在开启私人FM...'; break;
            default: this.loadingText = '正在读取列表...';
        }
        
        if (force) {
            this.fullSongList = [];
            this.displaySongList = [];
        }
        this.currentPage = 1;

        try {
            let sourceData;
            switch (this.listType) {
                case 'songlist':
                    sourceData = await this._getSourceData_songlist(force);
                    break;
                case 'daily_recommend':
                    sourceData = await this._getSourceData_dailyRecommend();
                    break;
                case 'personal_fm':
                    sourceData = await this._getSourceData_personalFm();
                    break;
                case 'downloadlist':
                    sourceData = Object.values(await fileService.readJson(this.downloadedFileUri, {}));
                    break;
                case 'favorites':
                    sourceData = Object.values(await fileService.readJson(this.favoritesFileUri, {}));
                    break;
                case 'playlist':
                default:
                    sourceData = await fileService.readJson(this.listFileUri, []);
                    break;
            }

            if (sourceData && sourceData.length > 0) {
                const downloadedData = await fileService.readJson(this.downloadedFileUri, {});
                const downloadedIds = new Set(Object.keys(downloadedData));
                
                this.fullSongList = sourceData;
                this.fullSongList.forEach(song => {
                    song.isDownloaded = downloadedIds.has(String(song.id));
                });

                this.totalPages = Math.ceil(this.fullSongList.length / this.PAGE_SIZE) || 1;

                if (shouldLocate) this.locateSongAndLoadPage();
                else this.loadPage(1);
            } else {
                this.fullSongList = [];
                this.displaySongList = [];
                this.totalPages = 1;
            }
        } catch (error) {
            this.loadError = error.message || '未知错误';
            this.fullSongList = [];
            this.displaySongList = [];
        } finally {
            this.isLoading = false;
            this.isFetchingFromNetwork = false;
            if (this.didLoadFromCache) {
                setTimeout(() => { this.didLoadFromCache = false; }, 500);
            }
        }
    },

    retryLoad: function() { this.loadData(); },

    async _getSourceData_songlist(forceAll = false) {
    if (!this.songlistId) throw new Error("未提供歌单ID");

    const cacheFileUri = `${this.songlistsDir}${this.songlistId}.json`;

    // 1. 读取缓存 (含cover，不重复请求)
    if (!forceAll) {
        const cachedList = await fileService.readJson(cacheFileUri, null);
        if (Array.isArray(cachedList) && cachedList.length > 0) {
            console.log('[songlist] 使用缓存歌单，长度 =', cachedList.length);
            this.didLoadFromCache = true;
            this.totalTrackCount = cachedList.length;
            return cachedList;
        }
    }

    // 2. 请求 detail 但只用于 tracks → 映射轻量对象版本
    const request = this.$app.$def.requestService;
    if (!request) throw new Error("内部服务错误");

    console.log('[songlist] 请求歌单详情 /playlist/detail, id =', this.songlistId);

    let detailResponse;
    try {
        detailResponse = await request.fetch({
            url: `https://163api.qijieya.cn/playlist/detail?id=${this.songlistId}`
        });
    } catch (e) {
        console.error('[songlist] 详情获取失败', e);
        throw new Error("获取歌单失败");
    }

    const playlist = detailResponse.data?.playlist;
    const tracks = playlist?.tracks;

    if (!Array.isArray(tracks) || tracks.length === 0) {
        console.warn('[songlist] 歌单无数据');
        return [];
    }

    // ⚠ 内存关键优化：逐条映射到轻量对象并释放原 tracks 项
    const songs = [];
    for (let i = 0; i < tracks.length; i++) {
        const s = tracks[i];
        songs.push({
            id: s.id,
            name: s.name,
            artists: (s.ar || s.artists)?.map(a => a.name).join(' / ') || '',
            cover: s.al?.picUrl || ""       // ← 你要保留的
        });
        tracks[i] = null;                  // ← 立即丢掉大对象，降低峰值内存
    }

    playlist.tracks = null; // ← 彻底释放原始大数组引用

    this.totalTrackCount = songs.length;
    console.log('[songlist] 一次加载完成，歌曲数量 =', songs.length);

    // 3. 写缓存（轻量对象，已无大字段，安全）
    await fileService.writeJson(cacheFileUri, songs);

    return songs;
},

    async _getSourceData_dailyRecommend() {
        const request = this.$app.$def.requestService;
        if (!request) throw new Error("内部服务错误");
        const response = await request.fetch({ url: `https://163api.qijieya.cn/recommend/songs` } );
        const songs = response.data?.data?.dailySongs;
        if (songs) {
            return songs.map(s => ({ id: s.id, name: s.name, artists: s.ar.map(a => a.name).join(' / ') }));
        }
        throw new Error("获取每日推荐失败");
    },

    async _getSourceData_personalFm() {
        const request = this.$app.$def.requestService;
        if (!request) throw new Error("内部服务错误");
        // 添加时间戳参数避免缓存，确保每次请求都能获取最新数据
        const timestamp = Date.now();
        const response = await request.fetch({ url: `https://163api.qijieya.cn/personal_fm?timestamp=${timestamp}` } );
        const songs = response.data?.data;
        if (songs) {
            return songs.map(s => ({ id: s.id, name: s.name, artists: s.artists.map(a => a.name).join(' / ') }));
        }
        throw new Error("获取私人FM失败");
    },


    locateSongAndLoadPage: function() {
        const targetId = this.targetSongId;
        if (!targetId || !this.fullSongList || this.fullSongList.length === 0) {
            this.loadPage(1);
            return;
        }
        const songIndex = this.fullSongList.findIndex(song => String(song.id) === String(targetId));
        if (songIndex !== -1) {
            const targetPage = Math.floor(songIndex / this.PAGE_SIZE) + 1;
            this.loadPage(targetPage);
            this.$nextTick(() => {
                const indexInPage = songIndex % this.PAGE_SIZE;
                const scrollOffset = indexInPage * this.ITEM_HEIGHT;
                this.$element('songListScroll').scrollTo({ top: scrollOffset, behavior: 'smooth' });
            });
        } else {
            prompt.showToast({ message: '未在列表中找到指定歌曲' });
            this.loadPage(1);
        }
        this.targetSongId = null;
    },

    loadPage: function(pageNumber) {
        if (pageNumber < 1 || (pageNumber > this.totalPages && this.totalPages > 0)) return;
        const startIndex = (pageNumber - 1) * this.PAGE_SIZE;
        const endIndex = startIndex + this.PAGE_SIZE;
        this.displaySongList = this.fullSongList.slice(startIndex, endIndex).map((song, index) => ({ ...song, displayIndex: startIndex + index + 1 }));
        this.currentPage = pageNumber;
        this.$nextTick(() => { this.$element('songListScroll').scrollTo({ top: 1 }); });
    },

    loadPrevPage: function() { if (this.currentPage > 1) this.loadPage(this.currentPage - 1); },
    loadNextPage: function() { if (this.currentPage < this.totalPages) this.loadPage(this.currentPage + 1); },

    async handleScrollTop() {
        if (this.isLoading || this.isRefreshing) return;
        const isRefreshable = ['songlist', 'personal_fm', 'daily_recommend'].includes(this.listType);
        if (!isRefreshable) return;

        if (this.justReachedTop) {
            this.isRefreshing = true; 
            prompt.showToast({ message: '正在刷新...' });
            if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
            this.justReachedTopTimeoutId = null;
            this.justReachedTop = false;

            try {
                await this.loadData(false, true);
            } finally {
                this.isRefreshing = false;
            }
        } else {
            prompt.showToast({ message: '再次下拉刷新' });
            this.justReachedTop = true;
            if (this.justReachedTopTimeoutId) clearTimeout(this.justReachedTopTimeoutId);
            this.justReachedTopTimeoutId = setTimeout(() => { this.justReachedTop = false; }, 3000);
        }
    },

    async deleteSong(songToDelete) {
        const fullIndex = this.fullSongList.findIndex(item => item.id === songToDelete.id);
        if (fullIndex > -1) {
            this.fullSongList.splice(fullIndex, 1);
            this.totalPages = Math.ceil(this.fullSongList.length / this.PAGE_SIZE) || 1;
            const targetPage = this.currentPage > this.totalPages ? Math.max(1, this.totalPages) : this.currentPage;
            this.loadPage(targetPage);
            prompt.showToast({ message: '已移除' });
            await this.persistDeletion(songToDelete);
        }
    },

    async persistDeletion(songToDelete) {
        const songId = songToDelete.id;
        if (this.listType === 'playlist') {
            await fileService.writeJson(this.listFileUri, this.fullSongList);
        } else if (this.listType === 'favorites') {
            const favorites = await fileService.readJson(this.favoritesFileUri, {});
            if (favorites[songId]) {
                delete favorites[songId];
                await fileService.writeJson(this.favoritesFileUri, favorites);
            }
        } else if (this.listType === 'downloadlist') {
            await fileService.delete(`${DIR_MUSIC}${songId}.mp3`);
            await fileService.delete(`${DIR_LYRICS}${songId}.json`);
            const downloaded = await fileService.readJson(this.downloadedFileUri, {});
            if (downloaded[songId]) {
                delete downloaded[songId];
                await fileService.writeJson(this.downloadedFileUri, downloaded);
            }
        }
    },

    async playAll() {
        if (!this.fullSongList || this.fullSongList.length === 0) {
            prompt.showToast({ message: '列表为空' });
            return;
        }
        if (this.listType === 'personal_fm') {
            this.play(this.fullSongList[0].id);
            return;
        }
        await fileService.writeJson(this.listFileUri, this.fullSongList);
        this.play(this.fullSongList[0].id);
    },

    play: function(songId) {
        const songToPlay = this.fullSongList.find(song => song.id === songId);
        if (!songToPlay) {
            prompt.showToast({ message: '找不到歌曲信息' });
            return;
        }
        const params = { songId: songId, songInfo: JSON.stringify({ id: songToPlay.id, name: songToPlay.name, artists: songToPlay.artists }) };
        if (this.listType === 'personal_fm') params.startFmMode = true;
        router.push({ uri: "/pages/player", params });
    },

    clearPlaylist: function() {
        prompt.showDialog({
            title: '清空播放列表',
            message: '您确定要清空当前播放列表中的所有歌曲吗？',
            buttons: [{ text: '取消' }, { text: '确定清空', color: '#FF453A' }],
            success: async () => {
                this.fullSongList = [];
                this.displaySongList = [];
                this.totalPages = 1;
                await fileService.writeJson(this.listFileUri, []);
                prompt.showToast({ message: '播放列表已清空' });
            }
        });
    },

    goBack: function() { router.back(); },
    goToStorage: function() { router.push({ uri: '/pages/storage' }); },
    refreshFm: function() { this.loadData(false, true); },

    async addAllToFavorites() {
        if (!this.fullSongList || this.fullSongList.length === 0) {
            prompt.showToast({ message: '列表为空，无法添加' });
            return;
        }
        prompt.showToast({ message: '正在添加到收藏...' });
        const favorites = await fileService.readJson(this.favoritesFileUri, {});
        let addedCount = 0;
        this.fullSongList.forEach(song => {
            if (!favorites[String(song.id)]) {
                favorites[String(song.id)] = { id: song.id, name: song.name, artists: song.artists, duration: song.duration || 0 };
                addedCount++;
            }
        });
        if (addedCount > 0) {
            const success = await fileService.writeJson(this.favoritesFileUri, favorites);
            prompt.showToast({ message: success ? `成功添加 ${addedCount} 首歌曲到收藏` : '保存收藏失败' });
        } else {
            prompt.showToast({ message: '所有歌曲均已在收藏中' });
        }
    },

    addSongToNext: function() { prompt.showToast({ message: '此功能正在开发中' }); },

    handleItemClick: function(item) {
        if (this.isDownloadMode && (this.listType === 'songlist' || this.listType === 'daily_recommend' || this.listType === 'playlist')) {
            if (item.isDownloaded || this.downloadingIds.includes(item.id) || this.downloadQueue.some(q => q.id === item.id)) {
                prompt.showToast({ message: item.isDownloaded ? '已下载' : '已在下载队列中' });
                return;
            }
            this.downloadQueue.push(item);
            prompt.showToast({ message: `已将 ${item.name} 加入下载队列` });
            this._processDownloadQueue();
        } else {
            this.play(item.id);
        }
    },

    _processDownloadQueue: function() {
        var that = this;
        if (that.isDownloadingLocked || that.downloadQueue.length === 0) {
            if (!that.isDownloadingLocked && that.downloadQueue.length === 0) {
                if (brightness && typeof brightness.setKeepScreenOn === 'function') {
                    brightness.setKeepScreenOn({ keepScreenOn: false });
                }
            }
            return;
        }

        if (!that.isDownloadingLocked) {
            if (brightness && typeof brightness.setKeepScreenOn === 'function') {
                brightness.setKeepScreenOn({ keepScreenOn: true });
            }
        }

        that.isDownloadingLocked = true;
        const songToDownload = that.downloadQueue.shift();

        const downloadService = that.$app.$def.downloadService;
        if (!downloadService) {
            prompt.showToast({ message: '下载服务不可用' });
            that.isDownloadingLocked = false;
            if (brightness && typeof brightness.setKeepScreenOn === 'function') {
                brightness.setKeepScreenOn({ keepScreenOn: false });
            }
            return;
        }

        const settings = that.$app.$def.settings || { audioQuality: { download: 128 } };
        const cookie = that.$app.$def.cookie || null;

        downloadService.start(
            songToDownload,
            { cookie: cookie, downloadBitrate: settings.audioQuality.download },
            {
                onStart: function(song) {
                    that.downloadingIds.push(song.id);
                },
                onSuccess: async function(downloadedInfo) {
                    try {
                        const currentDownloadedSongs = await fileService.readJson(that.downloadedFileUri, {});
                        const completeSongInfo = {
                            id: songToDownload.id, name: songToDownload.name, artists: songToDownload.artists,
                            duration: downloadedInfo.duration, localUri: downloadedInfo.localUri, localLyricUri: downloadedInfo.localLyricUri
                        };
                        const updatedSongs = { ...currentDownloadedSongs, [songToDownload.id]: completeSongInfo };
                        
                        await fileService.writeJson(that.downloadedFileUri, updatedSongs);

                        const songIndex = that.fullSongList.findIndex(s => s.id === songToDownload.id);
                        if (songIndex > -1) {
                            that.fullSongList[songIndex].isDownloaded = true;
                            const startIndex = (that.currentPage - 1) * that.PAGE_SIZE;
                            const endIndex = startIndex + that.PAGE_SIZE;
                            that.displaySongList = that.fullSongList.slice(startIndex, endIndex).map((song, index) => ({
                                ...song, displayIndex: startIndex + index + 1,
                            }));
                        }
                        prompt.showToast({ message: `${songToDownload.name} 下载成功` });
                    } catch (e) {
                        console.error("下载成功后处理失败:", e);
                    } finally {
                        const index = that.downloadingIds.indexOf(songToDownload.id);
                        if (index > -1) that.downloadingIds.splice(index, 1);
                        that.isDownloadingLocked = false;
                        that._processDownloadQueue();
                    }
                },
                onError: function(errorMessage) {
                    prompt.showToast({ message: `下载失败: ${errorMessage}` });
                    const index = that.downloadingIds.indexOf(songToDownload.id);
                    if (index > -1) that.downloadingIds.splice(index, 1);
                    that.isDownloadingLocked = false;
                    that._processDownloadQueue();
                }
            }
        );
    },
    toggleDownloadMode: function() { this.isDownloadMode = !this.isDownloadMode; }
};
</script>
