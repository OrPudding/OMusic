<import
	name="input-method"
	src="../../components/InputMethod/InputMethod.ux"
></import>

<template>
    <scroll id="searchScroll" class="page" scroll-y="true" bounces="true" onscrollbottom="handleScrollBottom" onscrolltop="handleScrollTop">
        <div class="header">
            <text class="title" onclick="goBack">‹搜索</text>
            <text class="text" @click="changeState">{{ textValue || ' ' }}_</text>
            <scroll class="history-scroll" scroll-x="true" if="{{ searchHistory.length > 0 }}" bounces="true">
                <text for="{{ searchHistory }}" class="history-tag" onclick="() => searchFromHistory($item)">{{ $item }}</text>
            </scroll>
        </div>

		<input-method
			hide="{{ hide }}"
			keyboardtype="{{ keyboardtype }}"
			maxlength="5"
			vibratemode="{{ vibratemode }}"
			screentype="{{ screentype }}"
			@visibility-change="onVisibilityChange"
            @delete="onDelete"
			@complete="onComplete"
		></input-method>

		<div class="result-list" show="{{ hide }}">
			<block for="{{ displayResultList }}">
				<div class="song-item" onclick="playSong($item)">
					<text class="song-title">{{ $item.name }}</text>
					<text class="song-artist">
						{{ $item.artists.map((a) => a.name).join(", ") }}
					</text>
				</div>
			</block>
            <text class="loading-tip" if="{{ isLoading }}">正在加载更多...</text>
            <text class="loading-tip" if="{{ !isLoading && hasMoreData === false && fullResultList.length > 0 }}">已加载全部 {{ fullResultList.length }} 条结果</text>
            <text class="loading-tip" if="{{ !isLoading && fullResultList.length === 0 && searchInitiated }}">无结果</text>
		</div>
	</scroll>
</template>

<style>
.page {
    flex-direction: column;
	width: 100%;
	height: 100%;
	background-color: black;
}
.header {
    flex-direction: column;
    padding-bottom:10px;
}
.title {
    font-size: 32px;
    padding: 10px;
	font-weight: bold;
    text-align: center;
    color: #fff;
}
.text {
    border-radius: 25px;
    margin-left: 96px;
	width: 60%;
	height: 80px;
	text-align: center;
	color: white;
    border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.03);
}
.result-list {
	flex-direction: column;
	padding-bottom:60px;
}

.song-item {
    padding: 15px;
	margin: 5px 60px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	flex-direction: column;
    /* **关键**: 必须为列表项设置一个固定的高度，用于精确计算滚动补偿 */
    height: 100px;
}

.song-title {
	font-size: 26px;
	color: #fff;
    lines: 1;
    text-overflow: ellipsis;
}

.song-artist {
	font-size: 22px;
	color: #888;
    lines: 1;
    text-overflow: ellipsis;
}

.history-scroll {
    width: 100%;
    padding: 10px;
    margin: 5px 10px;
}
.history-tag {
    padding: 8px 20px;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 20px;
    margin-right: 15px;
    font-size: 22px;
    color: #eee;
    lines: 1;
}
.loading-tip {
    width: 100%;
    text-align: center;
    color: #888;
    font-size: 24px;
    padding: 30px;
}
@media screen and (shape: rect) {
    .header {
        padding-top: 10px;
    }
  }
</style>
<script>
import fetch from "@system.fetch";
import router from "@system.router";
import file from "@system.file";
// **新增**: 导入 device 模块
import device from "@system.device";

const SETTINGS_FILE_URI = 'internal://files/settings.json';

export default {
    private: {
        textValue: "",
        
        fullResultList: [],
        displayResultList: [],

        // --- 搜索专用的懒加载与网络参数 ---
        WINDOW_SIZE: 10,
        PAGE_SIZE: 5,
        ITEM_HEIGHT: 110,
        TOTAL_LIMIT: 25,
        API_PAGE_SIZE: 10,

        displayStartIndex: 0,
        isLoading: false,
        searchInitiated: false,
        isScrolling: false,
        hasMoreUp: false,
        hasMoreDown: true,
        
        searchHistoryFileUri: 'internal://files/search_history.json',
        searchHistory: [],
        hide: true,
        keyboardtype: "QWERTY",
        vibratemode: "short",
        // **修改**: 提供一个安全的默认值
        screentype: "rect", 
    },
    
    /**
     * **核心修改**: 在 onInit 中检测屏幕类型
     */
    async onInit() {
        // 1. 异步获取设备信息
        device.getInfo({
            success: (data) => {
                if (data.screenShape) {
                    console.log(`检测到屏幕形状: ${data.screenShape}`);
                    // 2. 将获取到的屏幕形状赋值给 screentype
                    this.screentype = data.screenShape;
                }
            },
            fail: (data, code) => {
                console.error(`获取设备信息失败, code=${code}, data=${data}. 将使用默认屏幕类型: ${this.screentype}`);
            }
        });

        // 3. 其他初始化操作继续执行
        await this.applySettings();
        this.loadSearchHistory();
    },

    async applySettings() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: SETTINGS_FILE_URI, success: resolve, fail: reject }));
            const settings = JSON.parse(data.text);
            if (settings) {
                if (settings.search) {
                    this.TOTAL_LIMIT = settings.search.totalLimit || this.TOTAL_LIMIT;
                    this.API_PAGE_SIZE = settings.search.apiPageSize || this.API_PAGE_SIZE;
                }
                if (settings.performance) {
                    this.WINDOW_SIZE = settings.performance.windowSize || this.WINDOW_SIZE;
                    this.PAGE_SIZE = settings.performance.pageSize || this.PAGE_SIZE;
                }
                console.log(`搜索页设置已应用: Search(Total:${this.TOTAL_LIMIT}, APIPage:${this.API_PAGE_SIZE}), Perf(Win:${this.WINDOW_SIZE}, Page:${this.PAGE_SIZE})`);
            }
        } catch (e) {
            console.log("搜索页无法加载设置，使用默认值。");
        }
    },

    onVisibilityChange() {
        if (this.hide) {
            this.handleSearch();
        }
    },

    changeState() {
        this.hide = !this.hide;
    },

    onDelete() {
        this.textValue = this.textValue.slice(0, -1);
    },

    onComplete(evt) {
        this.textValue += evt.detail.content;
    },

    loadSearchHistory() {
        file.readText({
            uri: this.searchHistoryFileUri,
            success: (data) => {
                try { this.searchHistory = JSON.parse(data.text || "[]"); } catch (e) { this.searchHistory = []; }
            },
            fail: () => { this.searchHistory = []; }
        });
    },

    saveSearchHistory() {
        file.writeText({
            uri: this.searchHistoryFileUri,
            text: JSON.stringify(this.searchHistory, null, 2),
        });
    },

    addAndSaveHistory(keyword) {
        if (!keyword) return;
        const index = this.searchHistory.indexOf(keyword);
        if (index > -1) this.searchHistory.splice(index, 1);
        this.searchHistory.unshift(keyword);
        if (this.searchHistory.length > 10) this.searchHistory.pop();
        this.saveSearchHistory();
    },

    searchFromHistory(keyword) {
        this.textValue = keyword;
        this.handleSearch();
    },

    async handleSearch() {
        const keywords = this.textValue.trim();
        if (!keywords || this.isLoading) return;
        
        this.addAndSaveHistory(keywords);
        
        this.isLoading = true;
        this.searchInitiated = true;
        this.fullResultList = [];
        this.displayResultList = [];
        this.displayStartIndex = 0;
        this.hasMoreUp = false;
        this.hasMoreDown = true;

        await this.fetchAllSearchResults();
        
        this.isLoading = false;
        this.updateDisplayList(this.displayStartIndex);
    },

    async fetchAllSearchResults() {
        let offset = 0;
        let hasMore = true;
        while (hasMore && this.fullResultList.length < this.TOTAL_LIMIT) {
            const apiUrl = `https:///search?keywords=${encodeURIComponent(this.textValue  )}&limit=${this.API_PAGE_SIZE}&offset=${offset}`;
            try {
                const response = await new Promise((resolve, reject) => {
                    fetch.fetch({ url: apiUrl, responseType: 'text', success: resolve, fail: reject });
                });
                const result = JSON.parse(response.data);
                if (result.code === 200 && result.result?.songs?.length > 0) {
                    const newSongs = result.result.songs.map(s => ({ id: s.id, name: s.name, artists: s.artists || [] }));
                    
                    this.fullResultList.push(...newSongs);
                    this.updateDisplayList(this.displayStartIndex);

                    offset += newSongs.length;
                    if (newSongs.length < this.API_PAGE_SIZE) {
                        hasMore = false;
                        this.hasMoreDown = false;
                    }
                } else {
                    hasMore = false;
                    this.hasMoreDown = false;
                }
            } catch (error) {
                console.error("分页搜索失败:", error);
                hasMore = false;
                this.hasMoreDown = false;
            }
        }
    },

    updateDisplayList(startIndex) {
        this.displayStartIndex = Math.max(0, Math.min(startIndex, this.fullResultList.length - this.PAGE_SIZE));
        const endIndex = Math.min(this.displayStartIndex + this.WINDOW_SIZE, this.fullResultList.length);
        this.displayResultList = this.fullResultList.slice(this.displayStartIndex, endIndex);
        this.hasMoreUp = this.displayStartIndex > 0;
    },

    handleScrollTop() {
        if (this.isScrolling || !this.hasMoreUp) return;
        this.isScrolling = true;
        const prevStartIndex = this.displayStartIndex - this.PAGE_SIZE;
        if (prevStartIndex < 0) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(prevStartIndex);
        prompt.showToast({ message: `加载上页，避免操作` });
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('searchScroll').scrollTo({ top: scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    handleScrollBottom() {
        if (this.isScrolling || !this.hasMoreDown) return;
        this.isScrolling = true;
        const nextStartIndex = this.displayStartIndex + this.PAGE_SIZE;
        if (nextStartIndex >= this.fullResultList.length) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(nextStartIndex);
        prompt.showToast({ message: `加载下页，避免操作` });
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('searchScroll').scrollBy({ top: -scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    playSong(songItem) {
        const songInfoForPlayer = {
            id: songItem.id,
            name: songItem.name,
            artists: songItem.artists.map(a => a.name).join(' / '),
        };

        router.push({
            uri: 'pages/player',
            params: { 
                songId: songItem.id,
                songInfo: JSON.stringify(songInfoForPlayer)
            }
        });
    },
    
    goBack() {
        router.back();
    }
};
</script>
