<import
	name="input-method"
	src="../../components/InputMethod/InputMethod.ux"
></import>
<template>
	<scroll class="page" scroll-y="true" bounces="true">
        <div class="header">
    <text class="title">搜索</text>
		<text class="text" @click="changeState">{{ textValue }}_</text>
		<scroll class="history-scroll" scroll-x="true" if="{{ searchHistory.length > 0 }}" bounces="true">
			<text for="{{ searchHistory }}" class="history-tag" onclick="() => searchFromHistory($item)">{{ $item }}</text>
		</scroll>
        </div>
		<input-method
			hide="{{ hide }}"
			keyboardtype="{{ keyboardtype }}"
			maxlength="5"
			vibratemode="{{ vibratemode }}"
			screentype="{{ screentype }}"
			@visibility-change="onVisibilityChange"
            @delete="onDelete"
			@complete="onComplete"
		></input-method>
		<!-- 新增搜索结果列表 -->
		<div class="result-list" show="{{ hide }}">
			<block for="{{ songList }}">
				<div class="song-item" onclick="playSong($item.id, $item.name, $item.artists)">
					<text class="song-title">{{ $item.name }}</text>
					<text class="song-artist">
						{{ $item.artists.map((a) => a.name).join(", ") }}
					</text>
				</div>
			</block>
		</div>
	</scroll>
</template>

<script>
import fetch from "@system.fetch";
import router from "@system.router";
import file from "@system.file";


export default {
	private: {
		listFileUri: 'internal://files/play_list.json',
		textValue: "",
		songList: [], // 新增歌曲列表存储
		searchParams: {
			keywords: "killkiss",
			limit: 30,
			offset: 0,
			type: 1,
		},
		searchHistoryFileUri: 'internal://files/search_history.json',
        searchHistory: [],
		hide: false,
		keyboardtype: "QWERTY", //QWERTY, T9
		vibratemode: "short",
		screentype: "circle", //pill-shaped, rect, circle
	},
	onInit() {
        this.loadSearchHistory();
    },
	onVisibilityChange(evt) {
		// 仅当hide=true时才触发搜索
		if (this.hide) {
			this.handleSearch(evt);
		}
	},
    changeState() {
        this.hide = !this.hide;
    },
    onDelete() {
        this.textValue = this.textValue.slice(0, -1);
        console.log("删除字符");
    },
	onComplete(evt) {
		this.textValue += evt.detail.content;
		console.log("返回字符:" + JSON.stringify(evt));
	},
	loadSearchHistory() {
        file.readText({
            uri: this.searchHistoryFileUri,
            success: (data) => {
                try { this.searchHistory = JSON.parse(data.text || "[]"); } catch (e) { this.searchHistory = []; }
            },
            fail: () => { this.searchHistory = []; }
        });
    },
    saveSearchHistory() {
        file.writeText({
            uri: this.searchHistoryFileUri,
            text: JSON.stringify(this.searchHistory, null, 2),
        });
    },
    addAndSaveHistory(keyword) {
        if (!keyword) return;
        const index = this.searchHistory.indexOf(keyword);
        if (index > -1) {
            this.searchHistory.splice(index, 1);
        }
        this.searchHistory.unshift(keyword);
        if (this.searchHistory.length > 10) {
            this.searchHistory = this.searchHistory.slice(0, 10);
        }
        this.saveSearchHistory();
    },
    searchFromHistory(keyword) {
        this.textValue = keyword;
        this.handleSearch();
    },
	// 新增搜索处理方法
	handleSearch() {
		this.addAndSaveHistory(this.textValue.trim());
		this.searchParams.keywords = this.textValue;
		this.fetchSearchResults();
	},

	fetchSearchResults() {
		const apiUrl = `https://163api.qijieya.cn/search?keywords=${encodeURIComponent(
			this.searchParams.keywords
		)}&limit=10`;

		fetch.fetch({
			url: apiUrl,
			responseType: "text",
			success: (response) => {
				// 移除了不必要的调试输出
				try {
					const result = JSON.parse(response.data);
					if (result.code === 200 && result.result && result.result.songs) {
						// 提取歌曲的id、name和artist字段
						this.songList = result.result.songs.map((song) => ({
							id: song.id,
							name: song.name,
							artists: song.artists || [],
						}));
					} else {
						console.log("响应中未找到歌曲");
						this.songList = [];
					}
				} catch (error) {
					console.error("解析响应数据失败:", error);
					this.songList = [];
				}
			},
			fail: (data, code) => {
				// 保留必要的错误处理日志
				console.log(`处理失败，错误信息 = ${data}`);
				console.log(`处理失败，错误代码 = ${code}`);
				this.songList = [];
			},
		});
	},

	playSong(songId, name, artists) {
    // --- 使用 file 模块更新播放历史 ---
    // 1. 先读取现有历史
    file.readText({
        uri: this.listFileUri,
        success: (data) => {
            // 文件存在，解析并更新
            let list = [];
            try {
                list = JSON.parse(data.text || '[]');
            } catch (e) {
                console.error("解析历史记录失败，将创建新的历史记录。");
                list = [];
            }
            this.updateAndSaveHistory(list, songId, name, artists);
        },
        fail: () => {
            // 文件不存在或读取失败，直接创建新的历史记录
            console.log("无法读取历史记录（可能首次播放），将创建新文件。");
            this.updateAndSaveHistory([], songId, name, artists);
        }
    });
},

updateAndSaveHistory(list, songId, name, artists) {
    // 2. 更新历史记录数组
    const existingIndex = list.findIndex(item => item.id == songId); // 使用宽松比较
    if (existingIndex > -1) {
        list.splice(existingIndex, 1);
    }

    list.unshift({
        id: songId,
        name: name,
        // 确保 artists 字段格式与 player 页面期望的一致
        artists: artists.map(a => a.name).join('/') 
    });

    if (list.length > 50) {
        list = list.slice(0, 50);
    }

    // 【关键修改】将更新后的列表保存到组件的 data 中，以便传递
    const updatedList = list;

    // 3. 将更新后的数组写回文件
    file.writeText({
        uri: this.listFileUri,
        text: JSON.stringify(updatedList, null, 2),
        success: () => {
            console.log("[搜索页] 播放列表已成功保存到文件。");
            // 4. 保存成功后，使用新列表和 songId 进行跳转
            this.navigateToPlayer(songId, updatedList);
        },
        fail: (data, code) => {
            console.error(`[搜索页] 保存播放列表失败, code = ${code}`);
            // 即使保存失败，也应该用新列表继续播放
            this.navigateToPlayer(songId, updatedList);
        }
    });
},

// --- 修改这个辅助方法来处理跳转逻辑 ---
navigateToPlayer(songId, playList) {
    // 【关键修改】传递 songId 和序列化后的完整播放列表
    router.replace({
        uri: 'pages/player',
        params: {
            songId: songId,
            playList: JSON.stringify(playList)
        }
    });
}



}
</script>

<style>
.page {
    flex-direction: column;
	width: 466px;
	height: 466px;
	background-color: black;
}
.header {
    flex-direction: column;
    padding-bottom:10px;
}
.title {
    font-size: 32px;
    padding: 10px;
	font-weight: bold;
    text-align: center;
    color: #fff;
}
.text {
    border-radius: 25px;
    margin-left: 96px;
	width: 60%;
	height: 80px;
	text-align: center;
	color: white;
    border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.03);
}
/* 新增列表样式 */
.result-list {
	flex-direction: column;
	padding-bottom:60px;
}

.song-item {
    padding:15px;
	margin: 5px 60px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	flex-direction: column;
}

.song-title {
	font-size: 26px;
	color: #fff;
}

.song-artist {
	font-size: 22px;
	color: #888;
}

.history-scroll {
    width: 100%;
    padding: 10px;
    margin: 5px 10px;
}
.history-tag {
    padding: 8px 20px;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 20px;
    margin-right: 15px;
    font-size: 22px;
    color: #eee;
    lines: 1;
}
</style>