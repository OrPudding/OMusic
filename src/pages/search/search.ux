<import
	name="input-method"
	src="../../components/InputMethod/InputMethod.ux"
></import>

<template>
    <!-- 1. 给 scroll 组件添加 id 和 onscrollbottom 事件 -->
	<scroll id="searchScroll" class="page" scroll-y="true" bounces="true" onscrollbottom="handleScrollBottom" onscrolltop="handleScrollTop">
        <div class="header">
            <text class="title" onclick="goBack">‹搜索</text>
            <text class="text" @click="changeState">{{ textValue || ' ' }}_</text>
            <scroll class="history-scroll" scroll-x="true" if="{{ searchHistory.length > 0 }}" bounces="true">
                <text for="{{ searchHistory }}" class="history-tag" onclick="() => searchFromHistory($item)">{{ $item }}</text>
            </scroll>
        </div>

		<input-method
			hide="{{ hide }}"
			keyboardtype="{{ keyboardtype }}"
			maxlength="5"
			vibratemode="{{ vibratemode }}"
			screentype="{{ screentype }}"
			@visibility-change="onVisibilityChange"
            @delete="onDelete"
			@complete="onComplete"
		></input-method>

		<!-- 搜索结果列表 -->
		<div class="result-list" show="{{ hide }}">
            <!-- 2. 循环渲染的是 displayResultList (窗口数据) -->
			<block for="{{ displayResultList }}">
				<div class="song-item" onclick="playSong($item.id, $item.name, $item.artists)">
					<text class="song-title">{{ $item.name }}</text>
					<text class="song-artist">
						{{ $item.artists.map((a) => a.name).join(", ") }}
					</text>
				</div>
			</block>
            <!-- 3. 底部加载状态提示 -->
            <text class="loading-tip" if="{{ isLoading }}">正在加载更多...</text>
            <text class="loading-tip" if="{{ !isLoading && hasMoreData === false && fullResultList.length > 0 }}">已加载全部 {{ fullResultList.length }} 条结果</text>
            <text class="loading-tip" if="{{ !isLoading && fullResultList.length === 0 && searchInitiated }}">无结果</text>
		</div>
	</scroll>
</template>
<style>
.page {
    flex-direction: column;
	width: 466px;
	height: 466px;
	background-color: black;
}
.header {
    flex-direction: column;
    padding-bottom:10px;
}
.title {
    font-size: 32px;
    padding: 10px;
	font-weight: bold;
    text-align: center;
    color: #fff;
}
.text {
    border-radius: 25px;
    margin-left: 96px;
	width: 60%;
	height: 80px;
	text-align: center;
	color: white;
    border: 3px solid rgba(255, 255, 255, 0.06);
	background-color: rgba(255, 255, 255, 0.03);
}
.result-list {
	flex-direction: column;
	padding-bottom:60px;
}

.song-item {
    padding: 15px;
	margin: 5px 60px;
	background-color: rgba(255, 255, 255, 0.06);
	border-radius: 36px;
	flex-direction: column;
    /* **关键**: 必须为列表项设置一个固定的高度，用于精确计算滚动补偿 */
    height: 100px;
}

.song-title {
	font-size: 26px;
	color: #fff;
    lines: 1;
    text-overflow: ellipsis;
}

.song-artist {
	font-size: 22px;
	color: #888;
    lines: 1;
    text-overflow: ellipsis;
}

.history-scroll {
    width: 100%;
    padding: 10px;
    margin: 5px 10px;
}
.history-tag {
    padding: 8px 20px;
    background-color: rgba(255, 255, 255, 0.06);
    border-radius: 20px;
    margin-right: 15px;
    font-size: 22px;
    color: #eee;
    lines: 1;
}
.loading-tip {
    width: 100%;
    text-align: center;
    color: #888;
    font-size: 24px;
    padding: 30px;
}
</style>
<script>
import fetch from "@system.fetch";
import router from "@system.router";
import file from "@system.file";

const SETTINGS_FILE_URI = 'internal://files/settings.json';

export default {
    private: {
        listFileUri: 'internal://files/play_list.json',
        textValue: "",
        
        fullResultList: [],
        displayResultList: [],

        // --- 懒加载与网络参数 (提供默认值) ---
        WINDOW_SIZE: 10,
        PAGE_SIZE: 5,
        ITEM_HEIGHT: 110,
        TOTAL_LIMIT: 50,
        API_PAGE_SIZE: 10, // 搜索的API分页可以小一些

        displayStartIndex: 0,
        isLoading: false,
        searchInitiated: false,
        isScrolling: false,
        hasMoreUp: false,
        hasMoreDown: true,
        
        searchHistoryFileUri: 'internal://files/search_history.json',
        searchHistory: [],
        hide: false,
        keyboardtype: "QWERTY",
        vibratemode: "short",
        screentype: "circle",
    },

    async onInit() {
        await this.applySettings();
        this.loadSearchHistory();
    },

    async applySettings() {
        try {
            const data = await new Promise((resolve, reject) => file.readText({ uri: SETTINGS_FILE_URI, success: resolve, fail: reject }));
            const settings = JSON.parse(data.text);
            if (settings) {
                if (settings.performance) {
                    this.WINDOW_SIZE = settings.performance.windowSize || this.WINDOW_SIZE;
                    this.PAGE_SIZE = settings.performance.pageSize || this.PAGE_SIZE;
                }
                if (settings.network) {
                    this.TOTAL_LIMIT = settings.network.totalLimit || this.TOTAL_LIMIT;
                    this.API_PAGE_SIZE = settings.network.apiPageSize || this.API_PAGE_SIZE;
                }
                console.log(`搜索页设置已应用: Perf(Win:${this.WINDOW_SIZE}, Page:${this.PAGE_SIZE}), Net(Total:${this.TOTAL_LIMIT}, APIPage:${this.API_PAGE_SIZE})`);
            }
        } catch (e) {
            console.log("搜索页无法加载设置，使用默认值。");
        }
    },

    onVisibilityChange(evt) {
        if (this.hide) {
            this.handleSearch();
        }
    },

    changeState() {
        this.hide = !this.hide;
    },

    onDelete() {
        this.textValue = this.textValue.slice(0, -1);
    },

    onComplete(evt) {
        this.textValue += evt.detail.content;
    },

    loadSearchHistory() {
        file.readText({
            uri: this.searchHistoryFileUri,
            success: (data) => {
                try { this.searchHistory = JSON.parse(data.text || "[]"); } catch (e) { this.searchHistory = []; }
            },
            fail: () => { this.searchHistory = []; }
        });
    },

    saveSearchHistory() {
        file.writeText({
            uri: this.searchHistoryFileUri,
            text: JSON.stringify(this.searchHistory, null, 2),
        });
    },

    addAndSaveHistory(keyword) {
        if (!keyword) return;
        const index = this.searchHistory.indexOf(keyword);
        if (index > -1) this.searchHistory.splice(index, 1);
        this.searchHistory.unshift(keyword);
        if (this.searchHistory.length > 10) this.searchHistory.pop();
        this.saveSearchHistory();
    },

    searchFromHistory(keyword) {
        this.textValue = keyword;
        this.handleSearch();
    },

    async handleSearch() {
        const keywords = this.textValue.trim();
        if (!keywords || this.isLoading) return;
        
        this.addAndSaveHistory(keywords);
        
        this.isLoading = true;
        this.searchInitiated = true;
        this.fullResultList = [];
        this.displayResultList = [];
        this.displayStartIndex = 0;
        this.hasMoreUp = false;
        this.hasMoreDown = true;

        this.fullResultList = await this.fetchAllSearchResults();
        
        this.isLoading = false;
        this.updateDisplayList(0);
    },

    async fetchAllSearchResults() {
        let allSongs = [];
        let offset = 0;
        let hasMore = true;
        while (hasMore && allSongs.length < this.TOTAL_LIMIT) {
            const apiUrl = `https://163api.qijieya.cn/search?keywords=${encodeURIComponent(this.textValue )}&limit=${this.API_PAGE_SIZE}&offset=${offset}`;
            try {
                const response = await new Promise((resolve, reject) => {
                    fetch.fetch({ url: apiUrl, responseType: 'text', success: resolve, fail: reject });
                });
                const result = JSON.parse(response.data);
                if (result.code === 200 && result.result?.songs?.length > 0) {
                    const newSongs = result.result.songs.map(s => ({ id: s.id, name: s.name, artists: s.artists || [] }));
                    allSongs.push(...newSongs);
                    offset += newSongs.length;
                    if (newSongs.length < this.API_PAGE_SIZE) hasMore = false;
                } else {
                    hasMore = false;
                }
            } catch (error) {
                console.error("分页搜索失败:", error);
                hasMore = false;
            }
        }
        return allSongs;
    },

    updateDisplayList(startIndex) {
        this.displayStartIndex = Math.max(0, Math.min(startIndex, this.fullResultList.length - this.PAGE_SIZE));
        const endIndex = Math.min(this.displayStartIndex + this.WINDOW_SIZE, this.fullResultList.length);
        this.displayResultList = this.fullResultList.slice(this.displayStartIndex, endIndex);
        this.hasMoreUp = this.displayStartIndex > 0;
        this.hasMoreDown = endIndex < this.fullResultList.length;
    },

    handleScrollTop() {
        if (this.isScrolling || !this.hasMoreUp) return;
        this.isScrolling = true;
        const prevStartIndex = this.displayStartIndex - this.PAGE_SIZE;
        if (prevStartIndex < 0) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(prevStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('searchScroll').scrollTo({ top: scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    handleScrollBottom() {
        if (this.isScrolling || !this.hasMoreDown) return;
        this.isScrolling = true;
        const nextStartIndex = this.displayStartIndex + this.PAGE_SIZE;
        if (nextStartIndex >= this.fullResultList.length) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(nextStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('searchScroll').scrollBy({ top: -scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    playSong(songId, name, artists) {
        file.readText({
            uri: this.listFileUri,
            success: (data) => {
                let list = [];
                try { list = JSON.parse(data.text || '[]'); } catch (e) { list = []; }
                this.updateAndSaveHistory(list, songId, name, artists);
            },
            fail: () => {
                this.updateAndSaveHistory([], songId, name, artists);
            }
        });
    },

    updateAndSaveHistory(list, songId, name, artists) {
        const existingIndex = list.findIndex(item => item.id == songId);
        if (existingIndex > -1) list.splice(existingIndex, 1);
        list.unshift({
            id: songId, name: name, artists: artists.map(a => a.name).join('/') 
        });
        if (list.length > 50) list = list.slice(0, 50);
        const updatedList = list;
        file.writeText({
            uri: this.listFileUri,
            text: JSON.stringify(updatedList, null, 2),
            success: () => this.navigateToPlayer(songId, updatedList),
            fail: () => this.navigateToPlayer(songId, updatedList)
        });
    },

    navigateToPlayer(songId, playList) {
        router.replace({
            uri: 'pages/player',
            params: { songId: songId, playList: JSON.stringify(playList) }
        });
    },
    
    goBack() {
        router.back();
    }
};
</script>

