<template>
    <!-- FIX: 根组件使用 div，并将滚动限制在内容区，以固定顶栏 -->
    <div class="page-container">
        <!-- 1. 固定的顶部栏 -->
        <div class="header" onclick="goBack">
            <text class="time-display">{{currentTime}}</text>
            <text class="title">‹存储管理</text>
        </div>

        <!-- 2. 独立滚动的内容区 -->
        <scroll id="songListScroll" class="scroll-wrapper" scroll-y="true" bounces="true" 
                onscrolltop="handleScrollTop" onscrollbottom="handleScrollBottom">
            
            <!-- 存储概览 -->
            <div class="storage-overview">
                <text class="storage-text">{{ usedStorageText }} / {{ totalStorageText }}</text>
                <progress class="storage-progress" type="horizontal" percent="{{ usedPercent }}"></progress>
                <div class="storage-details">
                    <div class="detail-item">
                        <div class="color-box music-color"></div>
                        <text class="detail-text">歌曲: {{ musicSizeText }}</text>
                    </div>
                    <div class="detail-item">
                        <div class="color-box lyrics-color"></div>
                        <text class="detail-text">歌词: {{ lyricsSizeText }}</text>
                    </div>
                    <div class="detail-item">
                        <div class="color-box free-color"></div>
                        <text class="detail-text">可用: {{ availableStorageText }}</text>
                    </div>
                </div>
                <!-- 一键修复按钮 -->
                <div class="header-action-btn-wrapper" if="{{ hasUnknownSongs }}" onclick="fixAllUnknownSongs">
                    <image class="header-action-btn-icon" src="/common/icon/fix.png"></image>
                    <text class="header-action-btn-text">修复未知歌曲</text>
                </div>
            </div>
            
            <!-- 歌曲列表 -->
            <div class="list-content">
                <div for="{{(index, item) in displaySongList}}" class="song-item">
                   <text class="item-index">{{ item.displayIndex }}</text>
                   <div class="song-info">
                       <text class="song-title {{ item.isUnknown ? 'unknown-title' : '' }}">{{ item.name }}</text>
                       <text class="song-artist">{{ item.artists }}</text>
                       <div class="file-size-details">
                           <text class="size-tag music">{{ formatSize(item.musicFileSize, 'MB') }}</text>
                           <text class="size-tag lyric">{{ formatSize(item.lyricFileSize, 'KB') }}</text>
                       </div>
                   </div>
                   <div class="action-btn-wrapper" onclick="deleteSong(item)">
                       <image class="action-btn-icon" src="/common/icon/cancel.png"></image>
                   </div>
                </div>
            </div>

            <!-- 底部提示 -->
            <text class="loading-tip" if="{{ isLoading }}">正在计算存储...</text>
            <text class="loading-tip" if="{{ !isLoading && fullSongList.length === 0 }}">没有已下载的歌曲</text>
            <text class="loading-tip" if="{{ !isLoading && !hasMoreDown && fullSongList.length > 0 }}">已显示全部</text>
        </scroll>
    </div>
</template>

<style>
    /* --- 页面整体布局 (已修正顶栏固定问题) --- */
    .page-container {
        width: 100%;
        height: 100%;
        background-color: black;
    }

    /* 关键: 使用 fixed 定位将顶栏固定在屏幕顶部 */
    .header {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 90px;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: black; /* 确保顶栏有背景色 */
        z-index: 10; /* 确保顶栏在最上层 */
    }
    .time-display {
        font-size: 28px;
        font-weight: bold;
        color: #ffffff;
        padding-top: 5px;
        text-align: center;
    }
    .title {
        font-size: 32px;
        padding: 5px;
        text-align: center;
        font-weight: bold;
        color: #fff;
    }

    /* 关键: 滚动区域从顶栏下方开始，并占据剩余全部高度 */
    .scroll-wrapper {
        position: absolute;
        top: 90px; /* 从顶栏高度(90px)的位置开始 */
        bottom: 0;
        left: 0;
        right: 0;
        width: 100%;
        flex-direction: column;
        align-items: center;
    }

    /* --- 内容样式 (保持不变) --- */
    .list-content { flex-direction: column; padding-bottom: 60px; width: 100%; align-items: center; }
    .song-item { padding: 0 25px; width: 392px; height: 118px; margin: 5px; background-color: #191821; border-radius: 59px; justify-content: space-between; align-items: center; }
    .item-index { text-align: center; font-size: 28px;font-weight: bold; color: rgba(255, 255, 255, 0.6); width: 50px; }
    .song-info { width: 200px; flex-direction: column; justify-content: center; }
    .song-title { font-size: 26px; color: #fff; font-weight: bold; lines: 1; text-overflow: ellipsis; }
    .song-artist { font-size: 22px; color: #888; font-weight: bold; lines: 1; text-overflow: ellipsis; margin-top: 2px; }
    .loading-tip { width: 100%; text-align: center; color: #888; font-size: 24px; padding: 30px; }
    .storage-overview { display: flex; flex-direction: column; margin: 10px 0 20px 0; padding: 15px; background-color: #191821; border-radius: 20px; width: 360px; }
    .storage-text { font-size: 24px; color: #ffffff; font-weight: bold; margin-bottom: 10px; }
    .storage-progress { width: 100%; height: 12px; stroke-width: 12px; color: #BAC3FF; background-color: #333; }
    .storage-details { flex-direction: column; display: flex; justify-content: space-around; width: 100%; margin-top: 15px; }
    .detail-item { display: flex; align-items: center; font-size: 20px; font-weight: bold; color: #cccccc; }
    .detail-text { font-size: 20px; font-weight: bold; color: #cccccc; }
    .color-box { width: 12px; height: 12px; border-radius: 3px; margin-right: 8px; }
    .music-color { background-color: #BAC3FF; }
    .lyrics-color { background-color: #697699; }
    .free-color { background-color: #555555; }
    .file-size-details { display: flex; flex-direction: row; margin-top: 6px; }
    .size-tag { font-size: 18px; font-weight: bold; padding: 2px 6px; border-radius: 5px; margin-right: 8px; }
    .size-tag.music { background-color: #2E323C; color: #BAC3FF; }
    .size-tag.lyric { background-color: rgba(200, 200, 200, 0.2); color: #cccccc; }
    .unknown-title { color: #FFCC00; }
    .action-btn-wrapper { width: 80px; height: 80px; justify-content: center; align-items: center; }
    .action-btn-icon { width: 64px; height: 64px; }
    .header-action-btn-wrapper { margin-top: 15px; display: flex; flex-direction: row; align-items: center; padding: 8px 15px; background-color: rgba(255, 204, 0, 0.2); border-radius: 20px; align-self: flex-start; }
    .header-action-btn-icon { width: 32px; height: 32px; margin-right: 8px; }
    .header-action-btn-text { color: #FFCC00; font-size: 22px; font-weight: bold; }
    
    /* --- 媒体查询 (同步调整) --- */
    @media screen and (shape: rect) {
        .header {
            height: 65px; /* 顶栏高度变化 */
            flex-direction: row-reverse;
            padding-top: 10px;
            justify-content: space-around;
        }
        /* 关键: 滚动区域的起始位置也要相应调整 */
        .scroll-wrapper {
            top: 65px; /* 与变化后的顶栏高度保持一致 */
        }
        .time-display {
		font-size: 32px;
		padding-top: 0px;
	}
    }
</style>

<script>
// --- script 部分与你提供的完全一致，无需修改 ---
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import device from "@system.device";
import fetch from "@system.fetch";

const DIR_MUSIC = 'internal://files/music/';
const DIR_LYRICS = 'internal://files/lyrics/';
const FILE_DOWNLOADED_SONGS = 'internal://files/downloaded_songs.json';
const API_SONG_DETAIL = 'https://163api.qijieya.cn/song/detail?ids=';

export default {
    private: {
        totalStorage: 0,
        availableStorage: 0,
        musicSize: 0,
        lyricsSize: 0,
        fullSongList: [],
        displaySongList: [],
        WINDOW_SIZE: 30,
        PAGE_SIZE: 15,
        ITEM_HEIGHT: 150,
        displayStartIndex: 0,
        hasMoreUp: false,
        hasMoreDown: true,
        isLoading: true,
        isScrolling: false,
        currentTime: "00:00",
        hasUnknownSongs: false,
    },

    computed: {
        usedStorage(  ) { return this.totalStorage - this.availableStorage; },
        usedPercent() { return this.totalStorage > 0 ? Math.round((this.usedStorage / this.totalStorage) * 100) : 0; },
        totalStorageText() { return this.formatSize(this.totalStorage); },
        availableStorageText() { return this.formatSize(this.availableStorage); },
        usedStorageText() { return this.formatSize(this.usedStorage); },
        musicSizeText() { return this.formatSize(this.musicSize); },
        lyricsSizeText() { return this.formatSize(this.lyricsSize); }
    },

    onInit() {
        this.updateTime();
        setInterval(() => this.updateTime(), 1000 * 60);
    },

    onShow() {
        this.loadAndScanStorage();
    },

    updateTime() {
        const now = new Date();
        this.currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    },

// 修正后的 loadAndScanStorage 函数
loadAndScanStorage() {
    if (this.isLoading && this.fullSongList.length > 0) return;
    this.isLoading = true;
    this.fullSongList = [];
    this.hasUnknownSongs = false;

    let downloadedMeta = {};
    let musicFiles = [];
    let lyricFiles = [];

    // 最终数据处理函数
    const processScannedData = () => {
        console.log("所有异步文件操作完成，开始处理数据...");
        try {
            const musicFileMap = new Map(musicFiles.map(f => {
                const songId = f.uri.split('/').pop().replace('.mp3', '');
                return [songId, { uri: f.uri, size: f.length }];
            }));
            const lyricFileMap = new Map(lyricFiles.map(f => {
                const songId = f.uri.split('/').pop().replace('.json', '');
                return [songId, { uri: f.uri, size: f.length }];
            }));

            let newFullSongList = [], updatedDownloadedMeta = {}, totalMusicSize = 0, totalLyricsSize = 0, hasDataChanged = false, unknownCount = 0;

            for (const [songId, musicFileInfo] of musicFileMap.entries()) {
                const meta = downloadedMeta[songId];
                const lyricFileInfo = lyricFileMap.get(songId);
                if (meta) {
                    newFullSongList.push({ ...meta, isUnknown: false, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                    updatedDownloadedMeta[songId] = meta;
                } else {
                    unknownCount++;
                    newFullSongList.push({ id: songId, name: '未知歌曲', artists: `ID: ${songId}`, isUnknown: true, localUri: musicFileInfo.uri, localLyricUri: lyricFileInfo ? lyricFileInfo.uri : null, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                }
                totalMusicSize += musicFileInfo.size;
                if (lyricFileInfo) totalLyricsSize += lyricFileInfo.size;
            }

            if (Object.keys(downloadedMeta).length !== Object.keys(updatedDownloadedMeta).length) hasDataChanged = true;
            if (hasDataChanged) file.writeText({ uri: FILE_DOWNLOADED_SONGS, text: JSON.stringify(updatedDownloadedMeta, null, 2) });

            this.fullSongList = newFullSongList;
            this.musicSize = totalMusicSize;
            this.lyricsSize = totalLyricsSize;
            this.hasUnknownSongs = unknownCount > 0;
            this.updateDisplayList(0);
            this.hasMoreDown = this.fullSongList.length > this.displaySongList.length;
        } catch (e) {
            console.error("处理扫描数据时出错:", e);
        } finally {
            this.isLoading = false;
        }
    };

    // 4. 列出歌词文件 (任务链的倒数第二步)
    const task4_listLyrics = () => {
        file.list({
            uri: DIR_LYRICS,
            success: (data) => { lyricFiles = data.fileList || []; },
            fail: () => { lyricFiles = []; },
            complete: processScannedData // 完成后执行最终数据处理
        });
    };

    // 3. 列出音乐文件
    const task3_listMusic = () => {
        file.list({
            uri: DIR_MUSIC,
            success: (data) => { musicFiles = data.fileList || []; },
            fail: () => { musicFiles = []; },
            complete: task4_listLyrics // 完成后执行下一步
        });
    };

    // 2. 读取已下载歌曲元数据
    const task2_readMeta = () => {
        file.readText({
            uri: FILE_DOWNLOADED_SONGS,
            success: (data) => { try { downloadedMeta = JSON.parse(data.text) || {}; } catch (e) { downloadedMeta = {}; } },
            fail: () => { downloadedMeta = {}; },
            complete: task3_listMusic // 完成后执行下一步
        });
    };

    // 1. 获取设备存储信息 (任务链的起点)
    // getDeviceStorage 内部会等待两个存储API都完成后，才会调用 task2_readMeta
    this.getDeviceStorage(task2_readMeta);
},


    getDeviceStorage(callback) {
        let totalStorageDone = false;
        let availableStorageDone = false;

        const checkDone = () => {
            if (totalStorageDone && availableStorageDone) {
                callback();
            }
        };

        device.getTotalStorage({
            success: (data) => { this.totalStorage = data.totalStorage; },
            fail: () => { this.totalStorage = 0; },
            complete: () => {
                totalStorageDone = true;
                checkDone();
            }
        });

        device.getAvailableStorage({
            success: (data) => { this.availableStorage = data.availableStorage; },
            fail: () => { this.availableStorage = 0; },
            complete: () => {
                availableStorageDone = true;
                checkDone();
            }
        });
    },

    deleteSong(songToDelete) {
        prompt.showDialog({
            title: '删除歌曲',
            message: `您确定要删除《${songToDelete.name}》吗？`,
            buttons: [{ text: '取消' }, { text: '确定', color: '#FF453A' }],
            success: () => {
                prompt.showToast({ message: '正在删除...' });
                const musicUri = `${DIR_MUSIC}${songToDelete.id}.mp3`;
                const lyricUri = `${DIR_LYRICS}${songToDelete.id}.json`;

                let deleteTasks = [];
                // 检查文件是否存在再决定是否删除
                file.get({
                    uri: musicUri,
                    success: () => deleteTasks.push(musicUri),
                    complete: () => {
                        file.get({
                            uri: lyricUri,
                            success: () => deleteTasks.push(lyricUri),
                            complete: () => {
                                if (deleteTasks.length === 0) {
                                    this.updateMetaAfterDelete(songToDelete.id);
                                    return;
                                }
                                let deleteCount = deleteTasks.length;
                                const onOneFileDeleted = () => {
                                    deleteCount--;
                                    if (deleteCount === 0) this.updateMetaAfterDelete(songToDelete.id);
                                };
                                deleteTasks.forEach(uri => file.delete({ uri: uri, complete: onOneFileDeleted }));
                            }
                        })
                    }
                });
            },
            cancel: () => prompt.showToast({ message: '操作已取消' })
        });
    },

    updateMetaAfterDelete(songId) {
        file.readText({
            uri: FILE_DOWNLOADED_SONGS,
            success: (data) => {
                let downloaded = {};
                try { downloaded = JSON.parse(data.text) || {}; } catch (e) {}
                if (downloaded[String(songId)]) {
                    delete downloaded[String(songId)];
                    file.writeText({
                        uri: FILE_DOWNLOADED_SONGS,
                        text: JSON.stringify(downloaded, null, 2),
                        success: () => {
                            prompt.showToast({ message: '删除成功' });
                            this.loadAndScanStorage();
                        },
                        fail: () => {
                            prompt.showToast({ message: '更新列表失败，但文件已删除' });
                            this.loadAndScanStorage();
                        }
                    });
                } else {
                    prompt.showToast({ message: '记录已不在，刷新列表' });
                    this.loadAndScanStorage();
                }
            },
            fail: () => {
                prompt.showToast({ message: '元数据文件不存在，刷新列表' });
                this.loadAndScanStorage();
            }
        });
    },

    fixAllUnknownSongs() {
        const unknownSongIds = this.fullSongList.filter(song => song.isUnknown).map(song => song.id);
        if (unknownSongIds.length === 0) {
            prompt.showToast({ message: '没有需要修复的歌曲' });
            return;
        }
        prompt.showToast({ message: `正在批量修复 ${unknownSongIds.length} 首歌曲...` });
        const idsString = unknownSongIds.join(',');
        fetch.fetch({
            url: `${API_SONG_DETAIL}${idsString}`,
            responseType: 'text',
            success: (response) => {
                try {
                    const data = JSON.parse(response.data);
                    const songDetails = data?.songs;
                    if (!songDetails || songDetails.length === 0) throw new Error("API未返回有效的歌曲信息");
                    file.readText({
                        uri: FILE_DOWNLOADED_SONGS,
                        success: (metaFileData) => {
                            let downloaded = {};
                            try { downloaded = JSON.parse(metaFileData.text) || {}; } catch (e) {}
                            let fixedCount = 0;
                            songDetails.forEach(songDetail => {
                                const originalSong = this.fullSongList.find(s => s.id == songDetail.id);
                                if (originalSong) {
                                    downloaded[String(songDetail.id)] = { id: songDetail.id, name: songDetail.name, artists: songDetail.ar.map(a => a.name).join(' / '), duration: Math.floor(songDetail.dt / 1000) };
                                    fixedCount++;
                                }
                            });
                            if (fixedCount > 0) {
                                file.writeText({
                                    uri: FILE_DOWNLOADED_SONGS,
                                    text: JSON.stringify(downloaded, null, 2),
                                    success: () => {
                                        prompt.showToast({ message: `成功修复 ${fixedCount} 首歌曲！` });
                                        this.loadAndScanStorage();
                                    },
                                    fail: () => prompt.showToast({ message: '保存修复信息失败' })
                                });
                            } else {
                                prompt.showToast({ message: '未能从返回数据中匹配到可修复的歌曲' });
                            }
                        },
                        fail: () => prompt.showToast({ message: '读取元数据文件失败' })
                    });
                } catch (e) {
                    console.error("批量修复失败:", e);
                    prompt.showToast({ message: '修复失败，请检查网络或API' });
                }
            },
            fail: () => prompt.showToast({ message: '网络请求失败' })
        });
    },

    updateDisplayList(startIndex) {
        this.displayStartIndex = Math.max(0, Math.min(startIndex, this.fullSongList.length - this.PAGE_SIZE));
        const endIndex = Math.min(this.displayStartIndex + this.WINDOW_SIZE, this.fullSongList.length);
        this.displaySongList = this.fullSongList.slice(this.displayStartIndex, endIndex).map((song, index) => ({ ...song, displayIndex: this.displayStartIndex + index + 1 }));
        this.hasMoreDown = endIndex < this.fullSongList.length;
    },

    handleScrollTop() {
        if (this.isScrolling || !this.hasMoreUp) return;
        this.isScrolling = true;
        const prevStartIndex = this.displayStartIndex - this.PAGE_SIZE;
        if (prevStartIndex < 0) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(prevStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('songListScroll').scrollTo({ top: scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    handleScrollBottom() {
        if (this.isScrolling || !this.hasMoreDown) return;
        if (this.displayStartIndex + this.PAGE_SIZE < this.fullSongList.length) {
            this.isScrolling = true;
            const nextStartIndex = this.displayStartIndex + this.PAGE_SIZE;
            this.updateDisplayList(nextStartIndex);
            const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
            this.$element('songListScroll').scrollBy({ top: -scrollOffset, behavior: 'instant' });
            setTimeout(() => { this.isScrolling = false; }, 100);
        }
    },

    formatSize(bytes, forceUnit = null) {
        if (bytes < 0 || isNaN(bytes)) bytes = 0;
        if (bytes === 0) return `0 ${forceUnit || 'B'}`;
        const k = 1024;
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i;
        if (forceUnit && units.includes(forceUnit)) {
            i = units.indexOf(forceUnit);
        } else {
            i = Math.floor(Math.log(bytes) / Math.log(k));
        }
        const value = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
        return `${value} ${units[i]}`;
    },

    goBack() {
        router.back();
    }
};
</script>
