<template>
    <!-- 根组件使用 div -->
    <div class="page-container">
        <!-- 1. 固定的顶部栏 -->
        <div class="header" onclick="goBack">
            <text class="time-display">{{currentTime}}</text>
            <text class="title">‹存储管理</text>
        </div>

        <!-- 2. 独立滚动的内容区 -->
        <scroll id="songListScroll" class="scroll-wrapper" scroll-y="true" bounces="true">
            
            <!-- 存储概览 -->
            <div class="storage-overview">
                <text class="storage-text">{{ usedStorageText }} / {{ totalStorageText }}</text>
                <progress class="storage-progress" type="horizontal" percent="{{ usedPercent }}"></progress>
                <div class="storage-details">
                    <div class="detail-item">
                        <div class="color-box music-color"></div>
                        <text class="detail-text">歌曲: {{ musicSizeText }}</text>
                    </div>
                    <div class="detail-item">
                        <div class="color-box lyrics-color"></div>
                        <text class="detail-text">歌词: {{ lyricsSizeText }}</text>
                    </div>
                    <div class="detail-item">
                        <div class="color-box free-color"></div>
                        <text class="detail-text">可用: {{ availableStorageText }}</text>
                    </div>
                </div>
                <!-- 一键修复按钮 -->
                <div class="header-action-btn-wrapper" if="{{ hasUnknownSongs }}" onclick="fixAllUnknownSongs">
                    <image class="header-action-btn-icon" src="/common/icon/fix.png"></image>
                    <text class="header-action-btn-text">修复未知歌曲</text>
                </div>
            </div>
            
            <!-- 歌曲列表 -->
            <div class="list-content">
                <div for="{{(index, item) in displaySongList}}" class="song-item">
                   <div class="item-prefix">
                        <text class="item-index">{{ item.displayIndex }}</text>
                   </div>
                   <div class="song-info">
                       <text class="song-title {{ item.isUnknown ? 'unknown-title' : '' }}">{{ item.name }}</text>
                       <text class="song-artist">{{ item.artists }}</text>
                       <div class="file-size-details">
                           <text class="size-tag music">{{ formatSize(item.musicFileSize, 'MB') }}</text>
                           <text class="size-tag lyric">{{ formatSize(item.lyricFileSize, 'KB') }}</text>
                       </div>
                   </div>
                   <div class="action-btn-wrapper" onclick="deleteSong(item)">
                       <image class="action-btn" src="/common/icon/cancel.png"></image>
                   </div>
                </div>
            </div>

            <!-- 底部提示 -->
            <text class="loading-tip" if="{{ isLoading }}">正在计算存储...</text>
            <text class="loading-tip" if="{{ !isLoading && fullSongList.length === 0 }}">没有已下载的歌曲</text>
        </scroll>

        <!-- 悬浮的底部翻页操作栏 -->
        <div class="pagination-footer" if="{{ !isLoading && fullSongList.length > PAGE_SIZE }}">
            <text class="item-value-btn {{ currentPage === 1 ? 'item-value-btn-disabled' : '' }}" onclick="loadPrevPage">上一页</text>
            <text class="pagination-text">{{ currentPage }} / {{ totalPages }}</text>
            <text class="item-value-btn {{ currentPage >= totalPages ? 'item-value-btn-disabled' : '' }}" onclick="loadNextPage">下一页</text>
        </div>
    </div>
</template>

<style>
    .page-container { width: 100%; height: 100%; background-color: black; position: relative; }
    .header { width: 100%; height: 90px; flex-direction: column; justify-content: center; align-items: center; background-color: black; }
    .time-display { font-size: 28px; font-weight: bold; color: #ffffff; padding-top: 5px; text-align: center; }
    .title { font-size: 32px; padding: 5px; text-align: center; font-weight: bold; color: #fff; }
    .scroll-wrapper { position: absolute; top: 90px; bottom: 0; left: 0; right: 0; width: 100%; flex-direction: column; align-items: center; padding-bottom: 100px; }
    .storage-overview { display: flex; flex-direction: column; align-items: center; margin: 10px 0 20px 0; padding: 15px; background-color: #191821; border-radius: 20px; width: 360px; }
    .storage-text { font-size: 24px; color: #ffffff; font-weight: bold; margin-bottom: 10px; }
    .storage-progress { width: 100%; height: 12px; stroke-width: 12px; color: #BAC3FF; background-color: #333; }
    .storage-details { flex-direction: column; display: flex; justify-content: space-around; width: 100%; margin-top: 15px; }
    .detail-item { display: flex; align-items: center; font-size: 20px; font-weight: bold; color: #cccccc; }
    .detail-text { font-size: 20px; font-weight: bold; color: #cccccc; }
    .color-box { width: 12px; height: 12px; border-radius: 3px; margin-right: 8px; }
    .music-color { background-color: #BAC3FF; }
    .lyrics-color { background-color: #697699; }
    .free-color { background-color: #555555; }
    .header-action-btn-wrapper { margin-top: 15px; display: flex; flex-direction: row; align-items: center; padding: 8px 15px; background-color: rgba(255, 204, 0, 0.2); border-radius: 20px; }
    .header-action-btn-icon { width: 32px; height: 32px; margin-right: 8px; }
    .header-action-btn-text { color: #FFCC00; font-size: 22px; font-weight: bold; }
    .list-content { flex-direction: column; width: 100%; align-items: center; }
    .song-item { padding: 0 10px 0 0; width: 400px; height: 120px; margin: 5px; background-color: #191821; border-radius: 60px; justify-content: flex-start; align-items: center; }
    .item-prefix { width: 80px; height: 100%; justify-content: center; align-items: center; flex-shrink: 0; }
    .item-index { text-align: center; font-size: 28px; font-weight: bold; color: rgba(255, 255, 255, 0.6); }
    .song-info { flex-grow: 1; width: 0; flex-direction: column; justify-content: center; }
    .song-title { font-size: 26px; font-weight: bold; color: #fff; lines: 1; text-overflow: ellipsis; }
    .song-artist { font-size: 22px; font-weight: bold; color: #888; lines: 1; text-overflow: ellipsis; }
    .action-btn-wrapper { width: 80px; height: 120px; justify-content: center; align-items: center; flex-shrink: 0; }
    .action-btn { width: 64px; height: 64px; }
    .loading-tip { width: 100%; text-align: center; color: #888; font-size: 24px; padding: 30px 0; }
    .unknown-title { color: #FFCC00; }
    .file-size-details { display: flex; flex-direction: row; margin-top: 6px; }
    .size-tag { font-size: 18px; font-weight: bold; padding: 2px 6px; border-radius: 5px; margin-right: 8px; }
    .size-tag.music { background-color: #2E323C; color: #BAC3FF; }
    .size-tag.lyric { background-color: rgba(200, 200, 200, 0.2); color: #cccccc; }
    .pagination-footer { position: absolute; bottom: 0; left: 0; right: 0; width: 100%; height: 100px; flex-direction: row; padding: 0 20px; justify-content: space-around; align-items: center; }
    .pagination-text { font-size: 28px; font-weight: bold; color: #ffffff; }
    .item-value-btn { height: 50px; padding: 0 20px; background-color: #2E323C; border-radius: 25px; color: #BAC3FF; font-size: 26px; font-weight: bold; text-align: center; line-height: 50px; }
    .item-value-btn-disabled { background-color: #2E323C; color: #888; }
    @media (shape: rect) { .header { height: 65px; flex-direction: row-reverse; padding-top: 10px; justify-content: space-around; } .scroll-wrapper { top: 65px; } .time-display { font-size: 32px; padding-top: 0px; } }
    @media (shape: circle) { .pagination-footer { width: 100%; justify-content: center; } .item-value-btn { margin: 0 22px 50px 22px; } .pagination-text { position: absolute; bottom: 10px; } }
</style>

<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import device from "@system.device";
import fetch from "@system.fetch";

// 【【【核心新增】】】 将 fileService 封装完整地放入
const fileService = {
    _promisify(fn, options) {
        return new Promise((resolve, reject) => {
            fn({ ...options, success: resolve, fail: (data, code) => reject(new Error(`Error code ${code}: ${data}`)) });
        });
    },
    async readJson(uri, defaultValue = null) {
        try {
            const data = await this._promisify(file.readText, { uri });
            return JSON.parse(data.text || '{}');
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] readJson 失败: ${uri}`, error);
            return defaultValue;
        }
    },
    async writeJson(uri, data) {
        try {
            await this._promisify(file.writeText, { uri, text: JSON.stringify(data, null, 2) });
            return true;
        } catch (error) {
            console.error(`[FileService] writeJson 失败: ${uri}`, error);
            return false;
        }
    },
    async delete(uri) {
        try {
            await this._promisify(file.delete, { uri });
            return true;
        } catch (error) {
            if (error.code !== 301) console.error(`[FileService] delete 失败: ${uri}`, error);
            return false;
        }
    }
};

const DIR_MUSIC = 'internal://files/music/';
const DIR_LYRICS = 'internal://files/lyrics/';
const FILE_DOWNLOADED_SONGS = 'internal://files/downloaded_songs.json';
const API_SONG_DETAIL = 'https://163api.qijieya.cn/song/detail?ids=';

export default {
    private: {
        totalStorage: 0,
        availableStorage: 0,
        musicSize: 0,
        lyricsSize: 0,
        fullSongList: [],
        displaySongList: [],
        PAGE_SIZE: 10,
        ITEM_HEIGHT: 150,
        isLoading: true,
        currentTime: "00:00",
        hasUnknownSongs: false,
        totalPages: 1,
        currentPage: 1,
    },

    computed: {
        usedStorage( ) { return this.totalStorage - this.availableStorage; },
        usedPercent() { return this.totalStorage > 0 ? Math.round((this.usedStorage / this.totalStorage) * 100) : 0; },
        totalStorageText() { return this.formatSize(this.totalStorage); },
        availableStorageText() { return this.formatSize(this.availableStorage); },
        usedStorageText() { return this.formatSize(this.usedStorage); },
        musicSizeText() { return this.formatSize(this.musicSize); },
        lyricsSizeText() { return this.formatSize(this.lyricsSize); },
    },

    onInit() {
        this.updateTime();
        setInterval(() => this.updateTime(), 1000 * 60);
    },

    onShow() {
        this.loadAndScanStorage();
    },

    updateTime() {
        const now = new Date();
        this.currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    },

    loadPage(pageNumber) {
        if (pageNumber < 1 || (pageNumber > this.totalPages && this.totalPages > 0)) {
            return;
        }
        const startIndex = (pageNumber - 1) * this.PAGE_SIZE;
        const endIndex = startIndex + this.PAGE_SIZE;
        this.displaySongList = this.fullSongList.slice(startIndex, endIndex).map((song, index) => ({
            ...song,
            displayIndex: startIndex + index + 1,
        }));
        this.currentPage = pageNumber;
        this.$nextTick(() => {
            this.$element('songListScroll').scrollTo({ top: 1 });
        });
    },

    loadPrevPage() {
        if (this.currentPage > 1) {
            this.loadPage(this.currentPage - 1);
        }
    },

    loadNextPage() {
        if (this.currentPage < this.totalPages) {
            this.loadPage(this.currentPage + 1);
        }
    },

    async loadAndScanStorage() {
        if (this.isLoading && this.fullSongList.length > 0) return;
        this.isLoading = true;
        this.fullSongList = [];
        this.hasUnknownSongs = false;

        try {
            const [
                totalStorageData,
                availableStorageData,
                downloadedMeta,
                musicFilesData,
                lyricFilesData
            ] = await Promise.all([
                fileService._promisify(device.getTotalStorage).catch(() => ({ totalStorage: 0 })),
                fileService._promisify(device.getAvailableStorage).catch(() => ({ availableStorage: 0 })),
                fileService.readJson(FILE_DOWNLOADED_SONGS, {}),
                fileService._promisify(file.list, { uri: DIR_MUSIC }).catch(() => ({ fileList: [] })),
                fileService._promisify(file.list, { uri: DIR_LYRICS }).catch(() => ({ fileList: [] }))
            ]);

            this.totalStorage = totalStorageData.totalStorage;
            this.availableStorage = availableStorageData.availableStorage;

            const musicFiles = musicFilesData.fileList || [];
            const lyricFiles = lyricFilesData.fileList || [];
            const musicFileMap = new Map(musicFiles.map(f => [f.uri.split('/').pop().replace('.mp3', ''), { uri: f.uri, size: f.length }]));
            const lyricFileMap = new Map(lyricFiles.map(f => [f.uri.split('/').pop().replace('.json', ''), { uri: f.uri, size: f.length }]));

            let newFullSongList = [], updatedDownloadedMeta = {}, totalMusicSize = 0, totalLyricsSize = 0, unknownCount = 0;

            for (const [songId, musicFileInfo] of musicFileMap.entries()) {
                const meta = downloadedMeta[songId];
                const lyricFileInfo = lyricFileMap.get(songId);
                if (meta) {
                    newFullSongList.push({ ...meta, isUnknown: false, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                    updatedDownloadedMeta[songId] = meta;
                } else {
                    unknownCount++;
                    newFullSongList.push({ id: songId, name: '未知歌曲', artists: `ID: ${songId}`, isUnknown: true, localUri: musicFileInfo.uri, localLyricUri: lyricFileInfo ? lyricFileInfo.uri : null, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                }
                totalMusicSize += musicFileInfo.size;
                if (lyricFileInfo) totalLyricsSize += lyricFileInfo.size;
            }

            if (Object.keys(downloadedMeta).length !== Object.keys(updatedDownloadedMeta).length) {
                fileService.writeJson(FILE_DOWNLOADED_SONGS, updatedDownloadedMeta);
            }

            this.fullSongList = newFullSongList;
            this.musicSize = totalMusicSize;
            this.lyricsSize = totalLyricsSize;
            this.hasUnknownSongs = unknownCount > 0;
            this.totalPages = Math.ceil(this.fullSongList.length / this.PAGE_SIZE) || 1;
            this.loadPage(1);

        } catch (e) {
            console.error("加载和扫描存储时出错:", e);
            prompt.showToast({ message: `加载失败: ${e.message}` });
        } finally {
            this.isLoading = false;
        }
    },

    /**
     * 【【【核心重构】】】
     * 删除歌曲的入口函数
     */
    deleteSong: function(songToDelete) {
        var that = this;
        prompt.showDialog({
            title: '删除歌曲',
            message: `您确定要删除《${songToDelete.name}》吗？`,
            buttons: [{ text: '取消' }, { text: '确定', color: '#FF453A' }],
            success: function() {
                const songId = songToDelete.id;
                const index = that.fullSongList.findIndex(s => s.id === songId);
                if (index > -1) {
                    that.fullSongList.splice(index, 1);
                    that.totalPages = Math.ceil(that.fullSongList.length / that.PAGE_SIZE) || 1;
                    const targetPage = that.currentPage > that.totalPages ? that.totalPages : that.currentPage;
                    that.loadPage(targetPage);
                    prompt.showToast({ message: '已移除' });
                }
                that.persistDeletion(songId);
            },
            cancel: function() {
                prompt.showToast({ message: '操作已取消' });
            }
        });
    },

    /**
     * 【【【核心重构】】】
     * 持久化删除操作 (删除物理文件和元数据)
     * @param {string} songId - 要删除的歌曲ID
     */
    persistDeletion: async function(songId) {
        try {
            await fileService.delete(`${DIR_MUSIC}${songId}.mp3`);
            await fileService.delete(`${DIR_LYRICS}${songId}.json`);

            const downloaded = await fileService.readJson(FILE_DOWNLOADED_SONGS, {});
            if (downloaded[String(songId)]) {
                delete downloaded[String(songId)];
                await fileService.writeJson(FILE_DOWNLOADED_SONGS, downloaded);
            }
            
            // 删除成功后，重新扫描存储以确保数据完全同步
            this.loadAndScanStorage();

        } catch (error) {
            console.error("持久化删除失败:", error);
            prompt.showToast({ message: '删除文件时发生错误' });
        }
    },

    fixAllUnknownSongs() {
        const unknownSongIds = this.fullSongList.filter(song => song.isUnknown).map(song => song.id);
        if (unknownSongIds.length === 0) {
            prompt.showToast({ message: '没有需要修复的歌曲' });
            return;
        }
        prompt.showToast({ message: `正在批量修复 ${unknownSongIds.length} 首歌曲...` });
        const idsString = unknownSongIds.join(',');
        fetch.fetch({
            url: `${API_SONG_DETAIL}${idsString}`,
            responseType: 'text',
            success: (response) => {
                try {
                    const data = JSON.parse(response.data);
                    const songDetails = data?.songs;
                    if (!songDetails || songDetails.length === 0) throw new Error("API未返回有效的歌曲信息");
                    
                    (async () => {
                        const downloaded = await fileService.readJson(FILE_DOWNLOADED_SONGS, {});
                        let fixedCount = 0;
                        songDetails.forEach(songDetail => {
                            const originalSong = this.fullSongList.find(s => s.id == songDetail.id);
                            if (originalSong) {
                                downloaded[String(songDetail.id)] = { id: songDetail.id, name: songDetail.name, artists: songDetail.ar.map(a => a.name).join(' / '), duration: Math.floor(songDetail.dt / 1000) };
                                fixedCount++;
                            }
                        });
                        if (fixedCount > 0) {
                            const success = await fileService.writeJson(FILE_DOWNLOADED_SONGS, downloaded);
                            prompt.showToast({ message: success ? `成功修复 ${fixedCount} 首歌曲！` : '保存修复信息失败' });
                            this.loadAndScanStorage();
                        } else {
                            prompt.showToast({ message: '未能从返回数据中匹配到可修复的歌曲' });
                        }
                    })();

                } catch (e) {
                    console.error("批量修复失败:", e);
                    prompt.showToast({ message: '修复失败，请检查网络或API' });
                }
            },
            fail: () => prompt.showToast({ message: '网络请求失败' })
        });
    },

    formatSize(bytes, forceUnit = null) {
        if (bytes < 0 || isNaN(bytes)) bytes = 0;
        if (bytes === 0) return `0 ${forceUnit || 'B'}`;
        const k = 1024;
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i;
        if (forceUnit && units.includes(forceUnit)) {
            i = units.indexOf(forceUnit);
        } else {
            i = Math.floor(Math.log(bytes) / Math.log(k));
        }
        const value = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
        return `${value} ${units[i]}`;
    },

    goBack() {
        router.back();
    }
};
</script>
