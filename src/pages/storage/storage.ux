<template>
    <scroll id="songListScroll" class="list-container" scroll-y="true" bounces="true" 
            onscrolltop="handleScrollTop" onscrollbottom="handleScrollBottom">
        
      <!-- 1. 顶部 Header (无变化) -->
      <div class="header">
        <text class="time-display">{{currentTime}}</text>
        <text class="title" onclick="goBack">‹存储管理</text>
    </div>

        <!-- 存储概览 -->
        <div class="storage-overview">
            <text class="storage-text">{{ usedStorageText }} / {{ totalStorageText }}</text>
            <progress class="storage-progress" type="horizontal" percent="{{ usedPercent }}"></progress>
            <div class="storage-details">
                <div class="detail-item">
                    <div class="color-box music-color"></div>
                    <text class="detail-text">歌曲: {{ musicSizeText }}</text>
                </div>
                <div class="detail-item">
                    <div class="color-box lyrics-color"></div>
                    <text class="detail-text">歌词: {{ lyricsSizeText }}</text>
                </div>
                <div class="detail-item">
                    <div class="color-box free-color"></div>
                    <text class="detail-text">可用: {{ availableStorageText }}</text>
                </div>
            </div>
                                <!-- 一键修复按钮 -->
                                <div class="header-action-btn-wrapper" if="{{ hasUnknownSongs }}" onclick="fixAllUnknownSongs">
                                    <image class="header-action-btn-icon" src="/common/icon/fix.png"></image>
                                    <text class="header-action-btn-text">修复未知歌曲</text>
                                </div>
        </div>
        
        <!-- 歌曲列表 -->
        <div class="list-content">
            <div for="{{(index, item) in displaySongList}}" class="song-item">
               <text class="item-index">{{ item.displayIndex }}</text>
               <div class="song-info">
                   <text class="song-title {{ item.isUnknown ? 'unknown-title' : '' }}">{{ item.name }}</text>
                   <text class="song-artist">{{ item.artists }}</text>
                   <div class="file-size-details">
                       <text class="size-tag music">{{ formatSize(item.musicFileSize, 'MB') }}</text>
                       <text class="size-tag lyric">{{ formatSize(item.lyricFileSize, 'KB') }}</text>
                   </div>
               </div>
               <div class="action-btn-wrapper" onclick="deleteSong(item)">
                   <image class="action-btn-icon" src="/common/icon/cancel.png"></image>
               </div>
            </div>
        </div>

        <!-- 底部提示 -->
        <text class="loading-tip" if="{{ isLoading }}">正在计算存储...</text>
        <text class="loading-tip" if="{{ !isLoading && fullSongList.length === 0 }}">没有已下载的歌曲</text>
        <text class="loading-tip" if="{{ !isLoading && !hasMoreDown && fullSongList.length > 0 }}">已显示全部</text>
    </scroll>
</template>

<style>
  .list-container {
      width: 100%;
      height: 100%;
      flex-direction: column;
      align-items: center;
      background-color: black;
  }
  .header {
      width: 100%;
      flex-direction: column;
      justify-content: center;
      align-items: center;
  }
  .time-display {
      font-size: 28px;
      font-weight: bold;
      color: #ffffff;
      padding-top: 5px;
      text-align: center;
  }
  .title {
      font-size: 32px;
      padding: 5px;
      text-align: center;
      font-weight: bold;
      color: #fff;
  }
  .list-content { flex-direction: column; padding-bottom: 60px; }
  .song-item { padding: 0 25px; width: 360px; height: 140px; margin: 5px; background-color: rgba(255, 255, 255, 0.06); border-radius: 36px; justify-content: space-between; align-items: center; }
  .item-index { text-align: center; font-size: 28px; color: rgba(255, 255, 255, 0.6); width: 50px; }
  .song-info { width: 200px; flex-direction: column; justify-content: center; }
  .song-title { font-size: 26px; color: #fff; lines: 1; text-overflow: ellipsis; }
  .song-artist { font-size: 22px; color: #888; lines: 1; text-overflow: ellipsis; margin-top: 2px; }
  .loading-tip { width: 100%; text-align: center; color: #888; font-size: 24px; padding: 30px; }
  .storage-overview { display: flex; flex-direction: column; margin: 10px 25px 20px; padding: 15px; background-color: #1c1c1e; border-radius: 20px; width: 360px; }
  .storage-text { font-size: 24px; color: #ffffff; font-weight: bold; margin-bottom: 10px; }
  .storage-progress { width: 100%; height: 12px; stroke-width: 12px; color: #3ae1ff; background-color: #333; }
  .storage-details { flex-direction: column; display: flex; justify-content: space-around; width: 100%; margin-top: 15px; }
  .detail-item { display: flex; align-items: center; font-size: 20px; color: #cccccc; }
  .detail-text { font-size: 20px; color: #cccccc; }
  .color-box { width: 12px; height: 12px; border-radius: 3px; margin-right: 8px; }
  .music-color { background-color: #3ae1ff; }
  .lyrics-color { background-color: rgba(58, 225, 255, 0.5); }
  .free-color { background-color: #555555; }
  .file-size-details { display: flex; flex-direction: row; margin-top: 6px; }
  .size-tag { font-size: 18px; padding: 2px 6px; border-radius: 5px; margin-right: 8px; }
  .size-tag.music { background-color: rgba(58, 225, 255, 0.2); color: #3ae1ff; }
  .size-tag.lyric { background-color: rgba(200, 200, 200, 0.2); color: #cccccc; }
  .unknown-title { color: #FFCC00; font-style: italic; }
  .action-btn-wrapper { width: 80px; height: 140px; justify-content: center; align-items: center; }
  .action-btn-icon { width: 64px; height: 64px; }
  .header-action-btn-wrapper { display: flex; flex-direction: row; align-items: center; padding: 8px 15px; background-color: rgba(255, 204, 0, 0.2); border-radius: 20px; }
  .header-action-btn-icon { width: 32px; height: 32px; margin-right: 8px; }
  .header-action-btn-text { color: #FFCC00; font-size: 22px; font-weight: bold; }
  @media screen and (shape: rect) {
      .header {
          flex-direction: row-reverse;
          padding-top: 10px;
          justify-content:space-around
      }
      .time-display {
          font-size: 32px;
      }
  }
</style>

<script>
import router from "@system.router";
import file from "@system.file";
import prompt from "@system.prompt";
import device from "@system.device";
import fetch from "@system.fetch";

const DIR_MUSIC = 'internal://files/music/';
const DIR_LYRICS = 'internal://files/lyrics/';
const FILE_DOWNLOADED_SONGS = 'internal://files/downloaded_songs.json';
const API_SONG_DETAIL = 'https://163api.qijieya.cn/song/detail?ids=';

export default {
    private: {
        totalStorage: 0,
        availableStorage: 0,
        musicSize: 0,
        lyricsSize: 0,
        fullSongList: [],
        displaySongList: [],
        WINDOW_SIZE: 30,
        PAGE_SIZE: 15,
        ITEM_HEIGHT: 150,
        displayStartIndex: 0,
        hasMoreUp: false,
        hasMoreDown: true,
        isLoading: true,
        isScrolling: false,
        currentTime: "00:00",
        hasUnknownSongs: false,
    },

    computed: {
        usedStorage( ) { return this.totalStorage - this.availableStorage; },
        usedPercent() { return this.totalStorage > 0 ? Math.round((this.usedStorage / this.totalStorage) * 100) : 0; },
        totalStorageText() { return this.formatSize(this.totalStorage); },
        availableStorageText() { return this.formatSize(this.availableStorage); },
        usedStorageText() { return this.formatSize(this.usedStorage); },
        musicSizeText() { return this.formatSize(this.musicSize); },
        lyricsSizeText() { return this.formatSize(this.lyricsSize); }
    },

    onInit() {
        this.updateTime();
        setInterval(() => this.updateTime(), 1000 * 60);
    },

    onShow() {
        this.loadAndScanStorage();
    },

    updateTime() {
        const now = new Date();
        this.currentTime = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}`;
    },

    loadAndScanStorage() {
        if (this.isLoading && this.fullSongList.length > 0) return;
        this.isLoading = true;
        this.fullSongList = [];
        this.hasUnknownSongs = false;

        let asyncTasksCompleted = 0;
        const totalAsyncTasks = 4;

        let downloadedMeta = {};
        let musicFiles = [];
        let lyricFiles = [];

        const onAllTasksDone = () => {
            asyncTasksCompleted++;
            if (asyncTasksCompleted < totalAsyncTasks) return;

            console.log("所有异步文件操作完成，开始处理数据...");
            try {
                const musicFileMap = new Map(musicFiles.map(f => {
                    const songId = f.uri.split('/').pop().replace('.mp3', '');
                    return [songId, { uri: f.uri, size: f.length }];
                }));
                const lyricFileMap = new Map(lyricFiles.map(f => {
                    const songId = f.uri.split('/').pop().replace('.json', '');
                    return [songId, { uri: f.uri, size: f.length }];
                }));

                let newFullSongList = [], updatedDownloadedMeta = {}, totalMusicSize = 0, totalLyricsSize = 0, hasDataChanged = false, unknownCount = 0;

                for (const [songId, musicFileInfo] of musicFileMap.entries()) {
                    const meta = downloadedMeta[songId];
                    const lyricFileInfo = lyricFileMap.get(songId);
                    if (meta) {
                        newFullSongList.push({ ...meta, isUnknown: false, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                        updatedDownloadedMeta[songId] = meta;
                    } else {
                        unknownCount++;
                        newFullSongList.push({ id: songId, name: '未知歌曲', artists: `ID: ${songId}`, isUnknown: true, localUri: musicFileInfo.uri, localLyricUri: lyricFileInfo ? lyricFileInfo.uri : null, musicFileSize: musicFileInfo.size, lyricFileSize: lyricFileInfo ? lyricFileInfo.size : 0 });
                    }
                    totalMusicSize += musicFileInfo.size;
                    if (lyricFileInfo) totalLyricsSize += lyricFileInfo.size;
                }

                if (Object.keys(downloadedMeta).length !== Object.keys(updatedDownloadedMeta).length) hasDataChanged = true;
                if (hasDataChanged) file.writeText({ uri: FILE_DOWNLOADED_SONGS, text: JSON.stringify(updatedDownloadedMeta, null, 2) });

                this.fullSongList = newFullSongList;
                this.musicSize = totalMusicSize;
                this.lyricsSize = totalLyricsSize;
                this.hasUnknownSongs = unknownCount > 0;
                this.updateDisplayList(0);
                this.hasMoreDown = this.fullSongList.length > this.displaySongList.length;
            } catch (e) {
                console.error("处理扫描数据时出错:", e);
            } finally {
                this.isLoading = false;
            }
        };

        this.getDeviceStorage(onAllTasksDone);
        file.readText({ uri: FILE_DOWNLOADED_SONGS, success: (data) => { try { downloadedMeta = JSON.parse(data.text) || {}; } catch (e) { downloadedMeta = {}; } }, fail: () => { downloadedMeta = {}; }, complete: onAllTasksDone });
        file.list({ uri: DIR_MUSIC, success: (data) => { musicFiles = data.fileList || []; }, fail: () => { musicFiles = []; }, complete: onAllTasksDone });
        file.list({ uri: DIR_LYRICS, success: (data) => { lyricFiles = data.fileList || []; }, fail: () => { lyricFiles = []; }, complete: onAllTasksDone });
    },

    // 【核心修正】确保 getDeviceStorage 无论如何都会调用 callback
    getDeviceStorage(callback) {
        let totalStorageDone = false;
        let availableStorageDone = false;

        const checkDone = () => {
            if (totalStorageDone && availableStorageDone) {
                callback();
            }
        };

        device.getTotalStorage({
            success: (data) => { this.totalStorage = data.totalStorage; },
            fail: () => { this.totalStorage = 0; },
            complete: () => {
                totalStorageDone = true;
                checkDone();
            }
        });

        device.getAvailableStorage({
            success: (data) => { this.availableStorage = data.availableStorage; },
            fail: () => { this.availableStorage = 0; },
            complete: () => {
                availableStorageDone = true;
                checkDone();
            }
        });
    },

    deleteSong(songToDelete) {
        prompt.showDialog({
            title: '删除歌曲',
            message: `您确定要删除《${songToDelete.name}》吗？`,
            buttons: [{ text: '取消' }, { text: '确定', color: '#FF453A' }],
            success: () => {
                prompt.showToast({ message: '正在删除...' });
                file.readText({
                    uri: FILE_DOWNLOADED_SONGS,
                    success: (data) => {
                        let downloaded = {};
                        try { downloaded = JSON.parse(data.text) || {}; } catch (e) {}
                        const songInfo = downloaded[String(songToDelete.id)];
                        if (!songInfo) {
                            prompt.showToast({ message: '记录已不存在，将刷新' });
                            this.loadAndScanStorage();
                            return;
                        }
                        let deleteTasks = [];
                        if (songInfo.localUri) deleteTasks.push(songInfo.localUri);
                        if (songInfo.localLyricUri) deleteTasks.push(songInfo.localLyricUri);
                        if (deleteTasks.length === 0) {
                            this.updateMetaAfterDelete(downloaded, songToDelete.id);
                            return;
                        }
                        let deleteCount = deleteTasks.length;
                        const onOneFileDeleted = () => {
                            deleteCount--;
                            if (deleteCount === 0) this.updateMetaAfterDelete(downloaded, songToDelete.id);
                        };
                        deleteTasks.forEach(uri => file.delete({ uri: uri, complete: onOneFileDeleted }));
                    },
                    fail: () => prompt.showToast({ message: '读取歌曲列表失败，无法删除' })
                });
            },
            cancel: () => prompt.showToast({ message: '操作已取消' })
        });
    },

    updateMetaAfterDelete(downloadedData, songId) {
        delete downloadedData[String(songId)];
        file.writeText({
            uri: FILE_DOWNLOADED_SONGS,
            text: JSON.stringify(downloadedData, null, 2),
            success: () => {
                prompt.showToast({ message: '删除成功' });
                this.loadAndScanStorage();
            },
            fail: () => {
                prompt.showToast({ message: '更新列表失败，但文件已删除' });
                this.loadAndScanStorage();
            }
        });
    },

    fixAllUnknownSongs() {
        const unknownSongIds = this.fullSongList.filter(song => song.isUnknown).map(song => song.id);
        if (unknownSongIds.length === 0) {
            prompt.showToast({ message: '没有需要修复的歌曲' });
            return;
        }
        prompt.showToast({ message: `正在批量修复 ${unknownSongIds.length} 首歌曲...` });
        const idsString = unknownSongIds.join(',');
        fetch.fetch({
            url: `${API_SONG_DETAIL}${idsString}`,
            responseType: 'text',
            success: (response) => {
                try {
                    const data = JSON.parse(response.data);
                    const songDetails = data?.songs;
                    if (!songDetails || songDetails.length === 0) throw new Error("API未返回有效的歌曲信息");
                    file.readText({
                        uri: FILE_DOWNLOADED_SONGS,
                        success: (metaFileData) => {
                            let downloaded = {};
                            try { downloaded = JSON.parse(metaFileData.text) || {}; } catch (e) {}
                            let fixedCount = 0;
                            songDetails.forEach(songDetail => {
                                const originalSong = this.fullSongList.find(s => s.id == songDetail.id);
                                if (originalSong) {
                                    downloaded[String(songDetail.id)] = { id: songDetail.id, name: songDetail.name, artists: songDetail.ar.map(a => a.name).join(' / '), duration: Math.floor(songDetail.dt / 1000), localUri: originalSong.localUri, localLyricUri: originalSong.localLyricUri };
                                    fixedCount++;
                                }
                            });
                            if (fixedCount > 0) {
                                file.writeText({
                                    uri: FILE_DOWNLOADED_SONGS,
                                    text: JSON.stringify(downloaded, null, 2),
                                    success: () => {
                                        prompt.showToast({ message: `成功修复 ${fixedCount} 首歌曲！` });
                                        this.loadAndScanStorage();
                                    },
                                    fail: () => prompt.showToast({ message: '保存修复信息失败' })
                                });
                            } else {
                                prompt.showToast({ message: '未能从返回数据中匹配到可修复的歌曲' });
                            }
                        },
                        fail: () => prompt.showToast({ message: '读取元数据文件失败' })
                    });
                } catch (e) {
                    console.error("批量修复失败:", e);
                    prompt.showToast({ message: '修复失败，请检查网络或API' });
                }
            },
            fail: () => prompt.showToast({ message: '网络请求失败' })
        });
    },

    updateDisplayList(startIndex) {
        this.displayStartIndex = Math.max(0, Math.min(startIndex, this.fullSongList.length - this.PAGE_SIZE));
        const endIndex = Math.min(this.displayStartIndex + this.WINDOW_SIZE, this.fullSongList.length);
        this.displaySongList = this.fullSongList.slice(this.displayStartIndex, endIndex).map((song, index) => ({ ...song, displayIndex: this.displayStartIndex + index + 1 }));
        this.hasMoreDown = endIndex < this.fullSongList.length;
    },

    handleScrollTop() {
        if (this.isScrolling || !this.hasMoreUp) return;
        this.isScrolling = true;
        const prevStartIndex = this.displayStartIndex - this.PAGE_SIZE;
        if (prevStartIndex < 0) {
            this.isScrolling = false;
            return;
        }
        this.updateDisplayList(prevStartIndex);
        const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
        this.$element('songListScroll').scrollTo({ top: scrollOffset, behavior: 'instant' });
        setTimeout(() => { this.isScrolling = false; }, 100);
    },

    handleScrollBottom() {
        if (this.isScrolling || !this.hasMoreDown) return;
        if (this.displayStartIndex + this.PAGE_SIZE < this.fullSongList.length) {
            this.isScrolling = true;
            const nextStartIndex = this.displayStartIndex + this.PAGE_SIZE;
            this.updateDisplayList(nextStartIndex);
            const scrollOffset = this.PAGE_SIZE * this.ITEM_HEIGHT;
            this.$element('songListScroll').scrollBy({ top: -scrollOffset, behavior: 'instant' });
            setTimeout(() => { this.isScrolling = false; }, 100);
        }
    },

    formatSize(bytes, forceUnit = null) {
        if (bytes < 0 || isNaN(bytes)) bytes = 0;
        if (bytes === 0) return `0 ${forceUnit || 'B'}`;
        const k = 1024;
        const units = ['B', 'KB', 'MB', 'GB', 'TB'];
        let i;
        if (forceUnit && units.includes(forceUnit)) {
            i = units.indexOf(forceUnit);
        } else {
            i = Math.floor(Math.log(bytes) / Math.log(k));
        }
        const value = parseFloat((bytes / Math.pow(k, i)).toFixed(1));
        return `${value} ${units[i]}`;
    },

    goBack() {
        router.back();
    }
};
</script>
