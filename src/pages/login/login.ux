<template>
  <div class="page-container">
    <div class="header" onclick="back">
    <text class="time-display">{{currentTime}}</text>
      <text class="title">‹扫码登录</text>
    </div>
      <div class="qrcode-wrapper">
          <!-- 当 qrCodeValue 有效时，显示二维码 -->
          <qrcode if="{{ qrCodeValue }}"
                  value="{{ qrCodeValue }}"
                  class="qrcode-component"
                  onclick="startLoginFlow">
          </qrcode>
          <!-- 加载中或失败时，显示提示文本 -->
          <div class="status-overlay" if="{{ !qrCodeValue || loginStatus !== '等待扫码' }}">
              <text class="status-text">{{ loginStatus }}</text>
          </div>
      </div>
      <text class="tip">请使用网易云音乐APP扫码</text>
  </div>
</template>
<style>
    .page-container {
        width: 100%;
        height: 100%;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        background-color: #000000; /* 统一背景色 */
    }

    .header {
        width: 100%;
        flex-direction: column;
        justify-content: center;
        align-items: center;
    }

    .time-display {
  font-size: 28px;
  color: #ffffff;
  padding: 5px;
  text-align: center;
}

.title {
	font-size: 32px;
	padding: 5px;
	text-align: center;
  font-weight: bold;
	color: #fff;
}

    .qrcode-wrapper {
        width: 260px; /* 稍作调整以适应整体布局 */
        height: 260px;
        justify-content: center;
        align-items: center;
        border-radius: 20px; /* 添加圆角 */
    }

    .qrcode-component {
        width: 240px; /* 内部二维码留出边距 */
        height: 240px;
    }

    .status-overlay {
        position: absolute;
        width: 200px;
        height: 200px;
        /* 使用更深的遮罩，突出文字 */
        background-color: rgba(0, 0, 0, 0.8);
        border-radius: 20px;
        justify-content: center;
        align-items: center;
    }

    .status-text {
        font-size: 24px;
        color: #ffffff; /* 状态文字使用白色 */
        text-align: center;
    }

    .tip {
        font-size: 26px; /* 统一辅助文字大小 */
        color: rgba(255, 255, 255, 1); /* 使用半透明白色 */
        margin-top: 8px;
        margin-bottom: 65px;
    }

    /* 针对小屏或药丸屏的媒体查询，保持统一性 */
    @media (shape: pill-shaped) or (max-width: 106) {
        .title {
            font-size: 28px;
            margin-bottom: 20px;
        }
        .qrcode-wrapper, .status-overlay {
            width: 280px;
            height: 280px;
        }
        .qrcode-component {
            width: 260px;
            height: 260px;
        }
        .tip {
            font-size: 24px;
            margin-top: 20px;
        }
        .refresh-btn {
            width: 280px;
            height: 60px;
            margin-top: 25px;
            font-size: 26px;
        }
    }
</style>

<script>
import fetch from '@system.fetch';
import router from '@system.router';
import prompt from '@system.prompt';
import file from '@system.file';

const API_BASE = 'https://163api.qijieya.cn';
const COOKIE_FILE_URI = 'internal://files/cookie.txt';

export default {
    private: {
        qrCodeValue: '',      // 用于生成二维码的内容 (qrurl )
        loginKey: '',         // 从API获取的唯一key
        loginStatus: '正在生成二维码...', // 向用户展示的状态文本
        pollingTimer: null,   // 轮询定时器的引用
    },

    onInit() {
        this.startLoginFlow();
        this.updateTime();
    // 每分钟更新一次时间
    setInterval(() => {
      this.updateTime();
    }, 1000);
  },

  updateTime() {
    const now = new Date();
    const hours = now.getHours().toString().padStart(2, '0');
    const minutes = now.getMinutes().toString().padStart(2, '0');
    this.currentTime = `${hours}:${minutes}`;
  },

    onDestroy() {
        // 页面销毁时，必须清除定时器，防止内存泄漏和后台错误
        if (this.pollingTimer) {
            clearTimeout(this.pollingTimer);
            this.pollingTimer = null;
        }
    },

    /**
     * 开始完整的登录流程
     */
    async startLoginFlow() {
        // 1. 清理旧的定时器和状态
        if (this.pollingTimer) {
            clearTimeout(this.pollingTimer);
            this.pollingTimer = null;
        }
        this.qrCodeValue = '';
        this.loginStatus = '正在生成二维码...';

        try {
            // 2. 获取登录key
            const keyData = await this.getLoginKey();
            this.loginKey = keyData.data.unikey;

            // 3. 使用key生成二维码内容
            const qrData = await this.createQrCode(this.loginKey);
            this.qrCodeValue = qrData.data.qrurl;
            this.loginStatus = '等待扫码'; // 更新状态

            // 4. 开始轮询检查扫码状态
            this.pollLoginStatus();

        } catch (error) {
            this.loginStatus = '初始化失败，请刷新';
            prompt.showToast({ message: `操作失败: ${error.message || '网络错误'}` });
            console.error("登录流程初始化失败:", error);
        }
    },

    /**
     * 1. 二维码 key 生成接口
     */
    async getLoginKey() {
        const url = `${API_BASE}/login/qr/key?timestamp=${Date.now()}`;
        const response = await this.fetchPromise({ url });
        if (response.data.code === 200) {
            return response.data;
        } else {
            throw new Error('获取Key失败');
        }
    },

    /**
     * 2. 二维码生成接口
     */
    async createQrCode(key) {
        const url = `${API_BASE}/login/qr/create?key=${key}&qrimg=true&timestamp=${Date.now()}`;
        const response = await this.fetchPromise({ url });
        if (response.data.code === 200) {
            return response.data;
        } else {
            throw new Error('生成二维码失败');
        }
    },

    /**
     * 3. 轮询检测扫码状态接口
     */
    async pollLoginStatus() {
        if (!this.loginKey) return;

        const url = `${API_BASE}/login/qr/check?key=${this.loginKey}&timestamp=${Date.now()}`;
        
        try {
            const response = await this.fetchPromise({ url });
            const { code, message, cookie } = response.data;

            switch (code) {
                case 800: // 二维码过期
                    this.loginStatus = '二维码已过期，请刷新';
                    this.qrCodeValue = ''; // 清空二维码
                    return; // 停止轮询
                case 801: // 等待扫码
                    this.loginStatus = '等待扫码';
                    break;
                case 802: // 待确认
                    this.loginStatus = '扫码成功，请在手机上确认';
                    break;
                case 803: // 授权登录成功
                    this.loginStatus = '登录成功！';
                    prompt.showToast({ message: '登录成功！' });
                    await this.saveCookie(cookie); // 保存Cookie
                    // 登录成功后，可以跳转到其他页面
                    setTimeout(() => {
                        router.replace({ uri: '/pages/player' }); // 跳转到播放器页
                    }, 1000);
                    return; // 停止轮询
                default:
                    this.loginStatus = `未知状态: ${code}`;
                    break;
            }

            // 如果流程未终止，则设置下一次轮询 (例如2秒后)
            this.pollingTimer = setTimeout(() => {
                this.pollLoginStatus();
            }, 2000);

        } catch (error) {
            console.error("轮询失败:", error);
            // 网络错误等，可以稍后重试
            this.pollingTimer = setTimeout(() => {
                this.pollLoginStatus();
            }, 5000);
        }
    },

    /**
     * 将获取到的Cookie保存到文件中
     */
    async saveCookie(cookieString) {
        return new Promise((resolve, reject) => {
            file.writeText({
                uri: COOKIE_FILE_URI,
                text: cookieString,
                success: () => {
                    console.log("Cookie保存成功！");
                    // 通知全局服务重新加载Cookie
                    if (this.$app.$def.requestService) {
                        this.$app.$def.requestService.loadCookie();
                    }
                    resolve();
                },
                fail: (data, code) => {
                    console.error(`Cookie保存失败, code=${code}`);
                    reject(new Error('保存Cookie失败'));
                }
            });
        });
    },

    /**
     * 封装 fetch 为 Promise
     */
    fetchPromise(options) {
        return new Promise((resolve, reject) => {
            fetch.fetch({
                ...options,
                success: resolve,
                fail: (data, code) => reject({ data, code }),
            });
        });
    },

    back() {
      router.replace({ uri: '/pages/user' });
    }
};
</script>
